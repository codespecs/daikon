package DataStructures;

// CursorList class
//
// CONSTRUCTION: with no initializer
// Access is via CursorListItr class
//
// ******************PUBLIC OPERATIONS*********************
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// CursorListItr zeroth( )--> Return position to prior to first
// CursorListItr first( ) --> Return first position
// void insert( x, p )    --> Insert x after current iterator position p
// void remove( x )       --> Remove x
// CursorListItr find( x )
//                        --> Return position that views x
// CursorListItr findPrevious( x )
//                        --> Return position prior to x
// ******************ERRORS********************************
// No special errors

/**
 * Linked list implementation of the list
 *    using a header node; cursor version.
 * Access to the list is via CursorListItr.
 * @author Mark Allen Weiss
 * @see CursorListItr
 */
public class CursorList
{
  /*@ invariant this.header < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1; */
  /*@
  @ private normal_behavior // Generated by Daikon
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures \result < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  private static int alloc( )
  {
    int p = cursorSpace[ 0 ].next;
    cursorSpace[ 0 ].next = cursorSpace[ p ].next;
    if( p == 0 )
      throw new OutOfMemoryError( );
    return p;
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires p < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")), daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"));
  @ ensures \old(p) < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  private static void free( int p )
  {
    cursorSpace[ p ].element = null;
    cursorSpace[ p ].next = cursorSpace[ 0 ].next;
    cursorSpace[ 0 ].next = p;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  /**
   * Construct the list.
   */
  public CursorList( )
  {
    header = alloc( );
    cursorSpace[ header ].next = 0;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures (\result == false)  ==>  (this.header == 1 || this.header == 4 || this.header == 20);
  @*/
  /**
   * Test if the list is logically empty.
   * @return true if empty, false otherwise.
   */
  public boolean isEmpty( )
  {
    return cursorSpace[ header ].next == 0;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header == 4 || this.header == 20;
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures this.header == 4 || this.header == 20;
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")), daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"));
  @*/
  /**
   * Make the list logically empty.
   */
  public void makeEmpty( )
  {
    while( !isEmpty( ) )
      remove( first( ).retrieve( ) );
  }


  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \result.current;
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures \result != null;
  @*/
  /**
   * Return an iterator representing the header node.
   */
  public CursorListItr zeroth( )
  {
    return new CursorListItr( header );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures \result != null;
  @ ensures this.header != \result.current;
  @ ensures \result.current < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  /**
   * Return an iterator representing the first node in the list.
   * This operation is valid for empty lists.
   */
  public CursorListItr first( )
  {
    return new CursorListItr( cursorSpace[ header ].next );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header == 1 || this.header == 4 || this.header == 20;
  @ requires x != null;
  @ requires p != null;
  @ requires DataStructures.CursorList.cursorSpace.getClass().getName() != x.getClass().getName();
  @ requires p.current < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures p.current == \old(p.current);
  @ ensures this.header == 1 || this.header == 4 || this.header == 20;
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() != \old(x.getClass().getName());
  @ ensures daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")), daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")), daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"));
  @ ensures p.current < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  /**
   * Insert after p.
   * @param x the item to insert.
   * @param p the position prior to the newly inserted item.
   */
  public void insert( Object x, CursorListItr p )
  {
    if( p != null && p.current != 0 )
      {
	int pos = p.current;
	int tmp = alloc( );

	cursorSpace[ tmp ].element = x;
	cursorSpace[ tmp ].next = cursorSpace[ pos ].next;
	cursorSpace[ pos ].next = tmp;
      }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header == 1 || this.header == 4 || this.header == 20;
  @ requires x != null;
  @ requires DataStructures.CursorList.cursorSpace.getClass().getName() != x.getClass().getName();
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures this.header == 1 || this.header == 4 || this.header == 20;
  @ ensures \result != null;
  @ ensures \result.current >= 0;
  @ ensures this.header != \result.current;
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() != \old(x.getClass().getName());
  @ ensures \result.current < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  /**
   * Return iterator corresponding to the first node containing an item.
   * @param x the item to search for.
   * @return an iterator; iterator isPastEnd if item is not found.
   */
  public CursorListItr find( Object x )
  {
    int itr = cursorSpace[ header ].next;

    while( itr != 0 && !cursorSpace[ itr ].element.equals( x ) )
      itr = cursorSpace[ itr ].next;

    return new CursorListItr( itr );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires x != null;
  @ requires DataStructures.CursorList.cursorSpace.getClass().getName() != x.getClass().getName();
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures \result != null;
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() != \old(x.getClass().getName());
  @ ensures \result.current < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  /**
   * Return iterator prior to the first node containing an item.
   * @param x the item to search for.
   * @return appropriate iterator if the item is found. Otherwise, the
   * iterator corresponding to the last element in the list is returned.
   */
  public CursorListItr findPrevious( Object x )
  {
    int itr = header;

    while( cursorSpace[ itr ].next != 0 &&
	   !cursorSpace[ cursorSpace[ itr ].next ].element.equals( x ) )
      itr = cursorSpace[ itr ].next;

    return new CursorListItr( itr );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header == 1 || this.header == 4 || this.header == 20;
  @ requires x != null;
  @ requires DataStructures.CursorList.cursorSpace.getClass().getName() != x.getClass().getName();
  @ ensures this.header == \old(this.header);
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures this.header == 1 || this.header == 4 || this.header == 20;
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() != \old(x.getClass().getName());
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")), daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"));
  @*/
  /**
   * Remove the first occurrence of an item.
   * @param x the item to remove.
   */
  public void remove( Object x )
  {
    CursorListItr p = findPrevious( x );
    int pos = p.current;

    if( cursorSpace[ pos ].next != 0 )
      {
	int tmp = cursorSpace[ pos ].next;
	cursorSpace[ pos ].next = cursorSpace[ tmp ].next;
	free( tmp );
      }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires theList != null;
  @ requires theList.header < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @ ensures DataStructures.CursorList.cursorSpace == \old(DataStructures.CursorList.cursorSpace);
  @ ensures DataStructures.CursorList.cursorSpace.getClass().getName() == \old(DataStructures.CursorList.cursorSpace.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(DataStructures.CursorList.cursorSpace, \old(DataStructures.CursorList.cursorSpace));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "element")));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next"), \old(daikon.Quant.collectObject(DataStructures.CursorList.cursorSpace, "next")));
  @ ensures theList.header == \old(theList.header);
  @ ensures theList.header < daikon.Quant.size(DataStructures.CursorList.cursorSpace)-1;
  @*/
  // Simple print method
  static public void printList( CursorList theList )
  {
    if( theList.isEmpty( ) )
      System.out.print( "Empty list" );
    else
      {
	CursorListItr itr = theList.first( );
	for( ; !itr.isPastEnd( ); itr.advance( ) )
      {Object junk = itr.retrieve( ); /*System.out.print( itr.retrieve( ) + " " );*/ }
      }

    System.out.println( );
  }

  /*@ spec_public */ private int header;
  /*@ spec_public */ static CursorNode[ ] cursorSpace;

  /*@ spec_public */ private static final int SPACE_SIZE = 100;

  static
  {
    cursorSpace = new CursorNode[ SPACE_SIZE ];
    for( int i = 0; i < SPACE_SIZE; i++ )
      cursorSpace[ i ] = new CursorNode( null, i + 1 );
    cursorSpace[ SPACE_SIZE - 1 ].next = 0;
  } 

}
package DataStructures;

// CursorListItr class; maintains "current position"
//
// CONSTRUCTION: Package friendly only, with a CursorNode
//
// ******************PUBLIC OPERATIONS*********************
// void advance( )        --> Advance
// boolean isPastEnd( )   --> True if at valid position in list
// Object retrieve        --> Return item in current position

/**
 * Linked list implementation of the list iterator
 *    using a header node; cursor version.
 * @author Mark Allen Weiss
 * @see CursorList
 */
public class CursorListItr
{
  /*@ invariant this.current >= 0; */
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires theNode >= 0;
  @ ensures this.current == \old(theNode);
  @*/
  /**
   * Construct the list iterator
   * @param theNode any node in the linked list.
   */
  CursorListItr( int theNode )
  {
    current = theNode;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.current == \old(this.current);
  @ ensures (this.current == 0)  <==>  (\result == true);
  @ ensures (this.current == 0)  ==>  (this.current is a pointer);
  @*/
  /**
   * Test if the current position is past the end of the list.
   * @return true if the current position is null-equivalent.
   */
  public boolean isPastEnd( )
  {
    return current == 0;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.current == \old(this.current);
  @*/
  /**
   * Return the item stored in the current position.
   * @return the stored item or null if the current position
   * is not in the list.
   */
  public Object retrieve( )
  {
    return isPastEnd( ) ? null : CursorList.cursorSpace[ current ].element;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.current != \old(this.current);
  @*/
  /**
   * Advance the current position to the next node in the list.
   * If the current position is null, then do nothing.
   */
  public void advance( )
  {
    if( !isPastEnd( ) )
      current = CursorList.cursorSpace[ current ].next;
  }

  /*@ spec_public */ /*@ spec_public */ int current;    // Current position
}
package DataStructures;

// Basic node stored in a linked list -- cursor version
// Note that this class is not accessible outside
// of package DataStructures

class CursorNode
{
  /*@ invariant this.element == null; */
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  // Constructors
  CursorNode( Object theElement )
  {
    this( theElement, 0 );
  }
  
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires theElement == null;
  @ ensures this.next == \old(n);
  @*/
  CursorNode( Object theElement, int n )
  {
    element = theElement;
    next    = n;
  }
  
  // // Friendly data; accessible by other package routines
  // Made public because merge-esc.pl isn't very smart
  public Object   element;
  public int      next;
}
