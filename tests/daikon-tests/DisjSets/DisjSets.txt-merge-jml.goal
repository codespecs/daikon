package DataStructures;

// DisjSets class
//
// CONSTRUCTION: with int representing initial number of sets
//
// ******************PUBLIC OPERATIONS*********************
// void union( root1, root2 ) --> Merge two sets
// int find( x )              --> Return set containing x
// ******************ERRORS********************************
// No error checking is performed

/**
 * Disjoint set class. (Package friendly so not used accidentally)
 * Does not use union heuristics or path compression.
 * Elements in the set are numbered starting at 0.
 * @author Mark Allen Weiss
 * @see DisjSetsFast
 */
class DisjSets
{
  
  /*@ invariant this.s != null; */
  /*@ invariant daikon.Quant.eltsGTE(this.s, -1); */
  /*@ invariant daikon.Quant.eltsNotEqualIndex(this.s); */
  /*@ invariant daikon.Quant.eltsLTE(this.s, daikon.Quant.size(this.s)-1); */
  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires numElements >= 1;
  @ ensures \old(numElements) == daikon.Quant.size(this.s);
  @ ensures daikon.Quant.eltsEqual(this.s, -1);
  @ ensures daikon.Quant.eltsLtIndex(this.s);
  @ ensures daikon.Quant.eltsEqual(this.s, daikon.Quant.getElement_int(this.s, \old(numElements)-1));
  @ ensures daikon.Quant.size(this.s)-1 > daikon.Quant.getElement_int(this.s, \old(numElements)-1);
  @*/
  /**
   * Construct the disjoint sets object.
   * @param numElements the initial number of disjoint sets.
   */
  public DisjSets( int numElements )
  {
    s = new int [ numElements ];
    for( int i = 0; i < s.length; i++ )
      s[ i ] = -1;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires daikon.Quant.getElement_int(this.s, root1) == daikon.Quant.getElement_int(this.s, root2);
  @ requires root1 >= 0;
  @ requires root2 >= 0;
  @ requires daikon.Quant.getElement_int(this.s, root1) == -1;
  @ requires daikon.Quant.eltsGTE(this.s, daikon.Quant.getElement_int(this.s, root1));
  @ requires root1 != root2;
  @ requires root1 <= daikon.Quant.size(this.s)-1;
  @ requires root1 > daikon.Quant.getElement_int(this.s, root1);
  @ requires root2 <= daikon.Quant.size(this.s)-1;
  @ requires root2 > daikon.Quant.getElement_int(this.s, root1);
  @ requires daikon.Quant.size(this.s)-1 > daikon.Quant.getElement_int(this.s, root1);
  @ ensures this.s == \old(this.s);
  @ ensures \old(root1) == daikon.Quant.getElement_int(this.s, \old(root2));
  @ ensures daikon.Quant.size(this.s) == \old(daikon.Quant.size(this.s));
  @ ensures daikon.Quant.getElement_int(this.s, \old(root1)) == \old(daikon.Quant.getElement_int(this.s, root1));
  @ ensures daikon.Quant.getElement_int(this.s, \old(root1)) == \old(daikon.Quant.getElement_int(this.s, root2));
  @ ensures daikon.Quant.getElement_int(this.s, \old(root1)) == -1;
  @ ensures daikon.Quant.lexGT(this.s, \old(this.s));
  @ ensures daikon.Quant.pairwiseGTE(this.s, \old(this.s));
  @ ensures daikon.Quant.pairwiseBitwiseSubset(\old(this.s), this.s);
  @ ensures daikon.Quant.subsetOf(\old(this.s), this.s);
  @ ensures daikon.Quant.eltsGTE(this.s, daikon.Quant.getElement_int(this.s, \old(root1)));
  @ ensures daikon.Quant.eltsLTE(\old(this.s), daikon.Quant.size(this.s)-1);
  @ ensures daikon.Quant.eltsGTE(\old(this.s), daikon.Quant.getElement_int(this.s, \old(root1)));
  @ ensures \old(root1) <= daikon.Quant.size(this.s)-1;
  @ ensures \old(root1) > daikon.Quant.getElement_int(this.s, \old(root1));
  @ ensures \old(root2) <= daikon.Quant.size(this.s)-1;
  @ ensures \old(root2) > daikon.Quant.getElement_int(this.s, \old(root1));
  @ ensures daikon.Quant.size(this.s)-1 > daikon.Quant.getElement_int(this.s, \old(root1));
  @*/
  /**
   * Union two disjoint sets.  For simplicity, we assume root1 and
   * root2 are distinct and represent set names.
   * 
   * @param root1 the root of set 1.
   * @param root2 the root of set 2.
   */
  public void unionDisjoint( int root1, int root2 )
  {
    s[ root2 ] = root1;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires set1 >= 0;
  @ requires set2 >= 0;
  @ requires (!(daikon.Quant.size(this.s)-1 == 0)) || (set1 == 0);
  @ requires set1 <= daikon.Quant.size(this.s)-1;
  @ requires set1 != daikon.Quant.getElement_int(this.s, set1);
  @ requires (!(daikon.Quant.size(this.s)-1 == 0)) || (set2 == 0);
  @ requires set2 <= daikon.Quant.size(this.s)-1;
  @ requires set2 != daikon.Quant.getElement_int(this.s, set2);
  @ requires daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, set1);
  @ requires daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, set2);
  @ ensures this.s == \old(this.s);
  @ ensures daikon.Quant.size(this.s) == \old(daikon.Quant.size(this.s));
  @ ensures daikon.Quant.getElement_int(this.s, \old(set1)) == \old(daikon.Quant.getElement_int(this.s, set1));
  @ ensures daikon.Quant.pairwiseGTE(this.s, \old(this.s));
  @ ensures daikon.Quant.pairwiseBitwiseSubset(\old(this.s), this.s);
  @ ensures daikon.Quant.subsetOf(\old(this.s), this.s);
  @ ensures daikon.Quant.eltsLTE(\old(this.s), daikon.Quant.size(this.s)-1);
  @ ensures (!(daikon.Quant.size(this.s)-1 == 0)) || (\old(set1) == 0);
  @ ensures \old(set1) <= daikon.Quant.size(this.s)-1;
  @ ensures \old(set1) != daikon.Quant.getElement_int(this.s, \old(set1));
  @ ensures (!(daikon.Quant.size(this.s)-1 == 0)) || (\old(set2) == 0);
  @ ensures \old(set2) <= daikon.Quant.size(this.s)-1;
  @ ensures \old(set2) != daikon.Quant.getElement_int(this.s, \old(set2));
  @ ensures daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, \old(set1));
  @ ensures daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, \old(set2));
  @ ensures daikon.Quant.size(this.s)-1 >= \old(daikon.Quant.getElement_int(this.s, set2));
  @ ensures (!(\old(daikon.Quant.getElement_int(this.s, set2)) == 0)) || (daikon.Quant.getElement_int(this.s, \old(set2)) == 0);
  @*/
  /**
   * Union any two sets.
   * @param set1 element in set 1.
   * @param set2 element in set 2.
   */
  public void unionCareful( int set1, int set2 )
  {
    int root1 = find(set1);
    int root2 = find(set2);
    if (root1 != root2)
      unionDisjoint(root1, root2);
  }
  
  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires x >= 0;
  @ requires (!(daikon.Quant.size(this.s)-1 == 0)) || (x == 0);
  @ requires x <= daikon.Quant.size(this.s)-1;
  @ requires x != daikon.Quant.getElement_int(this.s, x);
  @ requires daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, x);
  @ ensures this.s == \old(this.s);
  @ ensures daikon.Quant.pairwiseEqual(this.s, \old(this.s));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) == -1)  <==>  (\result == \old(x));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) == -1)  ==>  (\old(x) > daikon.Quant.getElement_int(this.s, \old(x)));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) == -1)  ==>  (\result > daikon.Quant.getElement_int(this.s, \old(x)));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) == -1)  ==>  (daikon.Quant.size(this.s)-1 > daikon.Quant.getElement_int(this.s, \old(x)));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) == -1)  ==>  (daikon.Quant.eltsGTE(this.s, daikon.Quant.getElement_int(this.s, \old(x))));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) >= 0)  <==>  (\result != \old(x));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) >= 0)  <==>  (daikon.Quant.getElement_int(this.s, \result) < daikon.Quant.getElement_int(this.s, \old(x)));
  @ ensures (daikon.Quant.getElement_int(this.s, \old(x)) >= 0)  ==>  (daikon.Quant.memberOf(\result , this.s ));
  @ ensures \result >= 0;
  @ ensures daikon.Quant.getElement_int(this.s, \result) == -1;
  @ ensures daikon.Quant.eltsGTE(this.s, daikon.Quant.getElement_int(this.s, \result));
  @ ensures (!(daikon.Quant.size(this.s)-1 == 0)) || (\result == 0);
  @ ensures \result <= daikon.Quant.size(this.s)-1;
  @ ensures \result > daikon.Quant.getElement_int(this.s, \result);
  @ ensures (!(daikon.Quant.size(this.s)-1 == 0)) || (\old(x) == 0);
  @ ensures \old(x) <= daikon.Quant.size(this.s)-1;
  @ ensures \old(x) > daikon.Quant.getElement_int(this.s, \result);
  @ ensures \old(x) != daikon.Quant.getElement_int(this.s, \old(x));
  @ ensures daikon.Quant.size(this.s)-1 > daikon.Quant.getElement_int(this.s, \result);
  @ ensures daikon.Quant.size(this.s)-1 >= daikon.Quant.getElement_int(this.s, \old(x));
  @ ensures daikon.Quant.getElement_int(this.s, \result) <= daikon.Quant.getElement_int(this.s, \old(x));
  @*/
  /**
   * Perform a find.
   * Error checks omitted again for simplicity.
   * @param x the element being searched for.
   * @return the set containing x.
   */
  public int find( int x )
  {
    if( s[ x ] < 0 )
      return x;
    else
      return find( s[ x ] );
  }

  /*@ spec_public */ private int [ ] s;

}
