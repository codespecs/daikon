    package DataStructures;

    // BinaryHeap class
    //
    // CONSTRUCTION: with optional capacity (that defaults to 100)
    //
    // ******************PUBLIC OPERATIONS*********************
    // void insert( x )       --> Insert x
    // Comparable deleteMin( )--> Return and remove smallest item
    // Comparable findMin( )  --> Return smallest item
    // boolean isEmpty( )     --> Return true if empty; else false
    // boolean isFull( )      --> Return true if full; else false
    // void makeEmpty( )      --> Remove all items
    // ******************ERRORS********************************
    // Throws Overflow if capacity exceeded

    /**
     * Implements a binary heap.
     * Note that all "matching" is based on the compareTo method.
     * @author Mark Allen Weiss
     */
    public class BinaryHeap
    {
        /*@ invariant this != null; */
        /*@ invariant this.currentSize >= 0; */
        /*@ invariant this.array != null; */
        /*@ invariant this.array != null; */
        /*@ invariant this.array.getClass().getName() == DataStructures.Comparable[].class.getName(); */
        /*@ invariant daikon.Quant.size(this.array) == 101; */
        /*@ invariant daikon.Quant.noDups(daikon.Quant.slice(this.array, 0, this.currentSize)); */
        /*@ invariant this.currentSize <= daikon.Quant.size(this.array)-1; */
        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires true;
        @*/
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires capacity == 100;
        @ ensures \old(capacity) == daikon.Quant.size(this.array)-1;
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) == daikon.Quant.getElement_Object(this.array, \old(capacity));
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) == daikon.Quant.getElement_Object(this.array, \old(capacity)-1);
        @ ensures this.currentSize == 0;
        @ ensures daikon.Quant.eltsEqual(this.array, null);
        @ ensures daikon.Quant.eltsEqual(this.array, daikon.Quant.getElement_Object(this.array, this.currentSize));
        @*/
        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = new Comparable[ capacity + 1 ];
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires x != null;
        @ requires x.getClass().getName() == DataStructures.MyInteger.class.getName();
        @ requires this.currentSize < daikon.Quant.size(this.array)-1;
        @ requires this.array.getClass().getName() != x.getClass().getName();
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.size(this.array) == \old(daikon.Quant.size(this.array));
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize-1) == daikon.Quant.getElement_Object(this.array, \old(this.currentSize));
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize-1) == \old(daikon.Quant.getElement_Object(this.array, this.currentSize));
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ ensures this.currentSize - \old(this.currentSize) - 1 == 0;
        @ ensures this.array.getClass().getName() != \old(x.getClass().getName());
        @ ensures daikon.Quant.memberOf(\old(x) , this.array );
        @ ensures \old(this.currentSize) < daikon.Quant.size(this.array)-1;
        @ ensures daikon.Quant.memberOf(\old(x) , daikon.Quant.slice(this.array, 0, this.currentSize) );
        @*/
        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         * @exception Overflow if container is full.
         */
        public void insert( Comparable x ) throws Overflow
        {
            if( isFull( ) )
                throw new Overflow( );

                // Percolate up
            int hole = ++currentSize;
            for( ; hole > 1 && x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ requires this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures this.currentSize == \old(this.currentSize);
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.pairwiseEqual(this.array, \old(this.array));
        @ ensures \result != null;
        @ ensures \result.getClass().getName() == DataStructures.MyInteger.class.getName();
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ ensures this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures this.array.getClass().getName() != \result.getClass().getName();
        @ ensures daikon.Quant.memberOf(\result , this.array );
        @ ensures daikon.Quant.memberOf(\result , daikon.Quant.slice(this.array, 0, this.currentSize) );
        @*/
        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or null, if empty.
         */
        public Comparable findMin( )
        {
            if( isEmpty( ) )
                return null;
            return array[ 1 ];
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ requires this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.size(this.array) == \old(daikon.Quant.size(this.array));
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) == daikon.Quant.getElement_Object(this.array, \old(this.currentSize)-1);
        @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.array, this.currentSize+1, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.getElement_Object(this.array, \old(this.currentSize)) == \old(daikon.Quant.getElement_Object(this.array, this.currentSize));
        @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.array, \old(this.currentSize)+1, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, this.currentSize+1, daikon.Quant.size(this.array))));
        @ ensures \result != null;
        @ ensures \result.getClass().getName() == DataStructures.MyInteger.class.getName();
        @ ensures daikon.Quant.getElement_Object(this.array, \old(this.currentSize)) != null;
        @ ensures this.currentSize - \old(this.currentSize) + 1 == 0;
        @ ensures this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures this.array.getClass().getName() != \result.getClass().getName();
        @ ensures daikon.Quant.subsetOf(this.array, \old(this.array));
        @ ensures daikon.Quant.memberOf(\result , \old(this.array) );
        @ ensures daikon.Quant.memberOf(\result , \old(daikon.Quant.slice(this.array, 0, this.currentSize)) );
        @ ensures \old(this.currentSize) < daikon.Quant.size(this.array)-1;
        @ ensures daikon.Quant.memberOf(daikon.Quant.getElement_Object(this.array, this.currentSize) , \old(daikon.Quant.slice(this.array, 0, this.currentSize)) );
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize), \old(daikon.Quant.slice(this.array, 0, this.currentSize)));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize-1), \old(daikon.Quant.slice(this.array, 0, this.currentSize)));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, \old(this.currentSize)), \old(daikon.Quant.slice(this.array, 0, this.currentSize)));
        @*/
        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or null, if empty.
         */
        public Comparable deleteMin( )
        {
            if( isEmpty( ) )
                return null;

            Comparable minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /*@
        @ private normal_behavior // Generated by Daikon
        @ requires true;
        @*/
        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ requires this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures this.currentSize == \old(this.currentSize);
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.pairwiseEqual(this.array, \old(this.array));
        @ ensures \result == false;
        @ ensures daikon.Quant.getElement_Object(this.array, this.currentSize) != null;
        @ ensures this.currentSize < daikon.Quant.size(this.array)-1;
        @*/
        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ ensures this.currentSize == \old(this.currentSize);
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.pairwiseEqual(this.array, \old(this.array));
        @ ensures (\result == false)  <==>  (this.currentSize < daikon.Quant.size(this.array)-1);
        @ ensures (\result == true)  <==>  (this.currentSize == daikon.Quant.size(this.array)-1);
        @ ensures (\result == true)  ==>  (\old(daikon.Quant.getElement_Object(this.array, this.currentSize-1)) != null);
        @ ensures (\result == true)  ==>  (daikon.Quant.getElement_Object(this.array, \old(this.currentSize)-1) != null);
        @ ensures (\result == true)  ==>  (daikon.Quant.getElement_Object(this.array, this.currentSize-1) != null);
        @ ensures (\result == true)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array)), daikon.Quant.getElement_Object(this.array, this.currentSize)));
        @ ensures (\result == true)  ==>  (daikon.Quant.eltsNotEqual(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array)), null));
        @*/
        /**
         * Test if the priority queue is logically full.
         * @return true if full, false otherwise.
         */
        public boolean isFull( )
        {
            return currentSize == array.length - 1;
        }

        /*@
        @ public normal_behavior // Generated by Daikon
        @ requires true;
        @*/
        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        /*@ spec_public */ private static final int DEFAULT_CAPACITY = 100;

        /*@ spec_public */ private int currentSize;      // Number of elements in heap
        /*@ spec_public */ private Comparable [ ] array; // The heap array

        /*@
        @ private normal_behavior // Generated by Daikon
        @ requires hole == 1;
        @ requires daikon.Quant.getElement_Object(this.array, hole) != null;
        @ requires daikon.Quant.noDups(daikon.Quant.slice(this.array, 0, hole));
        @ requires daikon.Quant.eltsEqual(daikon.Quant.slice(this.array, 0, hole-1), null);
        @ requires this.currentSize < daikon.Quant.size(this.array)-1;
        @ requires daikon.Quant.eltsEqual(daikon.Quant.slice(this.array, 0, hole-1), daikon.Quant.getElement_Object(this.array, hole-1));
        @ ensures this.currentSize == \old(this.currentSize);
        @ ensures this.array == \old(this.array);
        @ ensures this.array.getClass().getName() == \old(this.array.getClass().getName());
        @ ensures daikon.Quant.size(this.array) == \old(daikon.Quant.size(this.array));
        @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.array, this.currentSize+1, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, this.currentSize+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.getElement_Object(this.array, \old(hole)-1) == \old(daikon.Quant.getElement_Object(this.array, hole-1));
        @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.array, 0, \old(hole)-1), \old(daikon.Quant.slice(this.array, 0, hole-1)));
        @ ensures daikon.Quant.getElement_Object(this.array, \old(hole)) != null;
        @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.array, 0, \old(hole)-1), null);
        @ ensures this.currentSize < daikon.Quant.size(this.array)-1;
        @ ensures daikon.Quant.subsetOf(this.array, \old(this.array));
        @ ensures daikon.Quant.subsetOf(\old(this.array), this.array);
        @ ensures daikon.Quant.subsetOf(this.array, \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(this.array, \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(\old(this.array), daikon.Quant.slice(this.array, \old(hole), daikon.Quant.size(this.array)));
        @ ensures daikon.Quant.memberOf(daikon.Quant.getElement_Object(this.array, this.currentSize) , \old(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array))) );
        @ ensures daikon.Quant.memberOf(daikon.Quant.getElement_Object(this.array, this.currentSize) , \old(daikon.Quant.slice(this.array, 0, this.currentSize)) );
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, this.currentSize, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.memberOf(\old(daikon.Quant.getElement_Object(this.array, this.currentSize)) , daikon.Quant.slice(this.array, 0, this.currentSize) );
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize), \old(daikon.Quant.slice(this.array, 0, this.currentSize)));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize-1), \old(daikon.Quant.slice(this.array, 0, this.currentSize)));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize-1), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, this.currentSize-1), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.array, 0, \old(hole)-1), daikon.Quant.getElement_Object(this.array, \old(hole)-1));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, \old(hole), daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, \old(hole), daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.memberOf(\old(daikon.Quant.getElement_Object(this.array, this.currentSize)) , daikon.Quant.slice(this.array, \old(hole)+1, daikon.Quant.size(this.array)) );
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, \old(hole)+1, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, \old(hole)+1, daikon.Quant.size(this.array)), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, \old(hole)), \old(daikon.Quant.slice(this.array, hole, daikon.Quant.size(this.array))));
        @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.array, 0, \old(hole)), \old(daikon.Quant.slice(this.array, hole+1, daikon.Quant.size(this.array))));
        @*/
        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
/* 1*/      int child;
/* 2*/      Comparable tmp = array[ hole ];

/* 3*/      for( ; hole * 2 <= currentSize; hole = child )
            {
/* 4*/          child = hole * 2;
/* 5*/          if( child != currentSize &&
/* 6*/                  array[ child + 1 ].compareTo( array[ child ] ) < 0 )
/* 7*/              child++;
/* 8*/          if( array[ child ].compareTo( tmp ) < 0 )
/* 9*/              array[ hole ] = array[ child ];
                else
/*10*/              break;
            }
/*11*/      array[ hole ] = tmp;
        }

            /*@
            @ public normal_behavior // Generated by Daikon
            @ requires args != null;
            @ requires args.getClass().getName() == java.lang.String[].class.getName();
            @ requires daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  });
            @ ensures daikon.Quant.pairwiseEqual(args, \old(args));
            @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  });
            @*/
            // Test program
        public static void main( String [ ] args )
        {
            int numItems = 10000;
            numItems = 100;    // MDE: reduce run time
            BinaryHeap h = new BinaryHeap( numItems );
            int i = 37;

            try
            {
                for( i = 37; i != 0; i = ( i + 37 ) % numItems )
                    h.insert( new MyInteger( i ) );
                for( i = 1; i < numItems; i++ )
                    if( ((MyInteger)( h.deleteMin( ) )).intValue( ) != i )
                        System.out.println( "Oops! " + i );

                for( i = 37; i != 0; i = ( i + 37 ) % numItems )
                    h.insert( new MyInteger( i ) );
                h.insert( new MyInteger( 0 ) );
                i = 9999999;
                h.insert( new MyInteger( i ) );
                for( i = 1; i <= numItems; i++ )
                    if( ((MyInteger)( h.deleteMin( ) )).intValue( ) != i )
                        System.out.println( "Oops! " + i + " " );
            }
            catch( Overflow e )
              { System.out.println( "Overflow (expected)! " + i  ); }
        }
    }
