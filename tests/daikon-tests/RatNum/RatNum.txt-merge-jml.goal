package PolyCalc;

import java.lang.Double;

/** RatNum represents an immutable rational number.

    It includes all of the elements of the set of rationals, as well
    as the special "NaN" (not-a-number) element that results from
    division by zero.
    <p>
    The "NaN" element is special in many ways.  Any arithmetic
    operation (such as addition) involving "NaN" will return "NaN".
    With respect to comparison operations, such as less-than, "NaN" is
    considered equal to itself, and larger than all other rationals.
    <p>

    Examples of RatNums include "-1/13", "53/7", "4", "NaN", and "0".
*/
public class RatNum {

    /*@ invariant this.denom >= 0; */
    /*@ spec_public */ private int numer;
    /*@ spec_public */ private int denom;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(n);
    @ ensures this.denom == 1;
    @*/
    // Abstraction Function:
    //   a RatNum r is NaN if r.denom = 0, ( r.numer / r.denom ) otherwise.
    // (An abstraction function explains what the state of the fields in a
    // RatNum represents.  In this case, a rational number can be
    // understood as the result of dividing two integers, or not-a-number
    // if we would be dividing by zero.)

    // Representation invariant for every RatNum r:
    //   ( r.denom >= 0 ) &&
    //   ( r.denom > 0 ==> there does not exist integer i > 1 such that
    //                     r.numer mod i = 0 and r.denom mod i = 0 )
    // (A representation invariant tells us something that is true for all
    // instances of a RatNum; in this case, that the denominator is always
    // greater than zero and that if the denominator is non-zero, the
    // fraction represented is in reduced form.)


    /** @effects: Constructs a new RatNum = n. */
    public RatNum(int n) {
        numer = n;
        denom = 1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures (this.denom == 0)  <==>  (\old(d) == 0);
    @ ensures (this.denom == 0)  ==>  (\old(d) is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.denom == \old(d));
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.numer == \old(n));
    @ ensures (!(\old(n) == 0)) || (this.numer == 0);
    @ ensures (!(this.numer == 0)) || (\old(n) == 0);
    @ ensures (!(\old(d) == 0)) || (this.denom == 0);
    @ ensures (!(this.denom == 0)) || (\old(d) == 0);
    @*/
    /** @effects: If d = 0, constructs a new RatNum = NaN.  Else
                  constructs a new RatNum = (n / d).
    */
    public RatNum(int n, int d) {
        // special case for zero denominator; gcd(n,d) requires d != 0
        if (d == 0) {
            numer = n;
            denom = 0;
            return;
        }

        // reduce ratio to lowest terms
        int g = gcd(n,d);
        numer = n / g;
        denom = d / g;

        if (denom < 0) {
            numer = -numer;
            denom = -denom;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (this.denom == 0)  <==>  (\result == true);
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @*/
    /** @return true iff this is NaN (not-a-number) */
    public boolean isNaN() {
        return (denom == 0);
    }


    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (\result == true)  ==>  (this.denom >= 1);
    @ ensures (\result == true)  ==>  (this.numer < this.denom);
    @ ensures (\result == true)  ==>  (this.numer <= -1);
    @*/
    /** @return true iff this < 0. */
    public boolean isNegative() {
        return (this.denom != 0) && (this.numer < 0);
        // return (compareTo( new RatNum(0) ) < 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (\result == false)  ==>  (this.numer < this.denom);
    @ ensures (\result == true)  ==>  (this.numer != 0);
    @*/
    /** @return true iff this > 0. */
    public boolean isPositive() {
        return (this.denom == 0) || (this.numer > 0);
        // return (compareTo( new RatNum(0) ) > 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires rn != null;
    @ requires rn.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures rn.numer == \old(rn.numer);
    @ ensures rn.denom == \old(rn.denom);
    @ ensures rn.denom >= 0;
    @*/
    /** @requires: rn != null
        @return a negative number if this < rn,
                0 if this = rn,
                a positive number if this > rn.
    */
    public int compareTo(RatNum rn) {
        if (this.isNaN() && rn.isNaN()) {
            return 0;
        } else if (this.isNaN()) {
            return 1;
        } else if (rn.isNaN()) {
            return -1;
        } else {
            RatNum diff = this.sub(rn);
            return diff.numer;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (this.denom == 0)  ==>  (daikon.Quant.fuzzy.eq(\result, Double.NaN));
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.numer != this.denom);
    @*/
    /** Approximates the value of this rational.

        @return a double approximation for this.  Note that "NaN" is
        mapped to {@link Double#NaN}, and the {@link Double#NaN} value
        is treated in a
        special manner by several arithmetic operations, such as the
        comparison and equality operators.  See the
        <a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9208">
        Java Language Specification, section 4.2.3</a>, for more details.
    */
    public double approx() {
        if (isNaN()) {
            return Double.NaN;
        } else {
            // convert int values to doubles before dividing.
            return ((double)numer) / ((double)denom);
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    /** @return a String representing this, in reduced terms.
        The returned string will either be "NaN", or it will take on
        either of the forms "N" or "N/M", where N and M are both
        integers in decimal notation and M != 0.
     */
    public String unparse() {
        // using '+' as String concatenation operator in this method

        if (isNaN()) {
            return "NaN";
        } else if (denom != 1) {
            return numer + "/" + denom;
        } else {
            return Integer.toString( numer );
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \result.denom;
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @ ensures (!(\result.numer == 0)) || (this.numer == 0);
    @ ensures (!(this.numer == 0)) || (\result.numer == 0);
    @ ensures this.numer + \result.numer == 0;
    @*/
    // in the implementation comments for the following methods, <this>
    // is notated as "a/b" and <arg> likewise as "x/y"


    /** @return a new Rational equal to (0 - this). */
    public RatNum negate() {
        return new RatNum( - this.numer , this.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this + arg).
        If either argument is NaN, then returns NaN.
     */
    public RatNum add(RatNum arg) {
        // a/b + x/y = ay/by + bx/by = (ay + bx)/by
        return new RatNum( this.numer*arg.denom + arg.numer*this.denom,
                           this.denom*arg.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this - arg).
        If either argument is NaN, then returns NaN.
    */
    public RatNum sub(RatNum arg) {
        // a/b - x/y = a/b + -x/y
        return this.add( arg.negate() );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.numer == 0)) || (\result.numer == 0);
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.numer == 0)) || (\result.numer == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this * arg).
        If either argument is NaN, then returns NaN.
     */
    public RatNum mul(RatNum arg) {
        // (a/b) * (x/y) = ax/by
        return new RatNum( this.numer*arg.numer,
                           this.denom*arg.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures (arg.denom == 0)  ==>  ((!(arg.numer == 0)) || (this.numer == 0));
    @ ensures (arg.denom == 0)  ==>  (arg.denom == \result.denom);
    @ ensures (arg.denom == 0)  ==>  (arg.denom is a pointer);
    @ ensures (arg.denom == 0)  ==>  (arg.numer == \result.numer);
    @ ensures (arg.denom == 0)  ==>  (\result == \old(arg));
    @ ensures (arg.denom == 0)  ==>  (\result.denom == 0);
    @ ensures (arg.denom == 0)  ==>  (\result.denom is a pointer);
    @ ensures (arg.denom == 0)  ==>  (this.denom >= arg.denom);
    @ ensures (arg.denom == 0)  ==>  (this.denom >= \result.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(\result.numer == 0)) || (this.numer == 0);
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.numer == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this / arg).
        If arg is zero, or if either argument is NaN, then returns NaN.
    */
    public RatNum div(RatNum arg) {
        // (a/b) / (x/y) = ay/bx

        if (arg.isNaN()) {
            return arg;
        } else {
            return new RatNum( this.numer*arg.denom,
                               this.denom*arg.numer );
        }
    }


    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires _b != 0;
    @ ensures \result != 0;
    @ ensures \old(_a) % \result == 0;
    @ ensures \old(_b) % \result == 0;
    @*/
    /** Returns the greatest common divisor of 'a' and 'b'.
        @requires: b != 0
        @return d such that a % d = 0 and b % d = 0
     */
    private static int gcd(int _a, int _b) {
        int a = _a, b = _b; // ESC doesn't handle modified primitive args
        // Euclid's method
        if (b == 0)
            return 0;
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /** Standard hashCode function.
        @return an int that all objects equal to this will also
                return.
    */
    public int hashCode() {
        return this.numer*2 + this.denom*3;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ requires obj != null;
    @ requires obj.getClass().getName() == PolyCalc.RatNum.class.getName();
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @*/
    /** Standard equality operation.
        @return true if and only if 'obj' is an instance of a RatNum
        and 'this' = 'obj'.  Note that NaN = NaN for RatNums.
    */
    public boolean equals(Object obj) {
        if (obj instanceof RatNum) {
            RatNum rn = (RatNum) obj;

            // special case: check if both are NaN
            if (this.isNaN() && rn.isNaN()) {
                return true;
            } else {
                return this.numer == rn.numer && this.denom == rn.denom;
            }
        } else {
            return false;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    /** @return implementation specific debugging string. */
    public String debugPrint() {
        return "RatNum<numer:"+this.numer+" denom:"+this.denom+">";
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    // When debugging, or when interfacing with other programs that have
    // specific I/O requirements, you might change this.
    public String toString() { return debugPrint(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires ratStr != null;
    @ ensures ratStr.toString().equals(\old(ratStr.toString()));
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @*/
    /** Makes a RatNum from a string describing it.
        @requires: 'ratStr' is an instance of a string, with no spaces,
                   of the form: <UL>
           <LI> "NaN"
           <LI> "N/M", where N and M are both integers in
                decimal notation, and M != 0, or
           <LI> "N", where N is an integer in decimal
                notation.
        </UL>
        @returns NaN if ratStr = "NaN".  Else returns a
                  RatNum r = ( N / M ), letting M be 1 in the case
                  where only "N" is passed in.
    */
    public static RatNum parse(String ratStr) throws NumberFormatException {
        int slashLoc = ratStr.indexOf('/');
        if (ratStr.equals("NaN")) {
            return new RatNum(1,0);
        } else if (slashLoc == -1) {
            // not NaN, and no slash, must be an Integer
            return new RatNum( Integer.parseInt( ratStr ) );
        } else {
            // slash, need to parse the two parts seperately
            int n = Integer.parseInt( ratStr.substring(0, slashLoc) );
            int d = Integer.parseInt( ratStr.substring(slashLoc+1,
                                                       ratStr.length()));
            return new RatNum( n , d );
        }
    }
}
