package MapQuick;

import java.util.*;

/**
 * A WeightedNodePath characterizes a path of WeightedNodes.  The cost
 * for a path is the sum of the costs of the WeightedNodes it contains.
 */

public class WeightedNodePath implements Path {

  /*@ invariant this.node != null; */
  /*@ invariant this.path.node != null; */
  /*@ invariant this.path.path.node != null; */
  /*@ invariant this.path.path.cost >= 1; */
  /*@ invariant this.path.cost >= 1; */
  /*@ invariant this.cost >= 1; */
  /*@ invariant this.path.path.cost < this.path.cost; */
  /*@ invariant this.path.path.cost < this.cost; */
  /*@ invariant this.path.cost < this.cost; */
  //
  // RepInvariant:
  //   (node != null) &&
  //   (path == null) ==> (cost == node.cost) &&
  //   (path != null) ==> (cost == node.cost + path.cost)
  //

  /*@ spec_public */ private final WeightedNode node;
  /*@ spec_public */ private final WeightedNodePath path;
  /*@ spec_public */ private final int cost;


  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires node != null;
  @ ensures this.node == \old(node);
  @ ensures this.path == null;
  @*/
  /**
   * Constructs a WeightedNodePath containing one node.
   *
   * @requires node != null
   * @effects Creates a new WeightedNodePath which originates at
   * <code>node</code>.
   */
  public WeightedNodePath(WeightedNode node) {
    this(node, null);
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires node != null;
  @ requires path.node != null;
  @ requires path.path.node != null;
  @ requires path.path.cost >= 1;
  @ requires path.cost >= 1;
  @ requires path.path.cost < path.cost;
  @ ensures this.node == \old(node);
  @ ensures this.path == \old(path);
  @ ensures this.path.node == path.node;
  @ ensures this.path.path == path.path;
  @ ensures this.path.path.node == path.path.node;
  @ ensures this.path.path.path == path.path.path;
  @ ensures this.path.path.cost == path.path.cost;
  @ ensures this.path.cost == path.cost;
  @ ensures path.node == \old(path.node);
  @ ensures path.path == \old(path.path);
  @ ensures path.path.node == \old(path.path.node);
  @ ensures path.path.path == \old(path.path.path);
  @ ensures path.path.cost == \old(path.path.cost);
  @ ensures path.cost == \old(path.cost);
  @ ensures path.node != null;
  @ ensures path.path.node != null;
  @ ensures path.path.cost >= 1;
  @ ensures path.cost >= 1;
  @ ensures this.cost > path.path.cost;
  @ ensures this.cost > path.cost;
  @ ensures path.path.cost < path.cost;
  @*/
  /**
   * @requires node != null
   * @effects Creates a new WeightedNodePath 'res' such that
   * res.elements = path.elements + [ node ]
   */
  private WeightedNodePath(WeightedNode node, WeightedNodePath path) {
    if (node == null) {
      throw new IllegalArgumentException();
    }
    this.node = node;
    this.path = path;
    if (path != null) {
      this.cost = node.cost + path.cost;
    } else {
      this.cost = node.cost;
    }
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ requires o != null;
  @ requires o.getClass().getName() == MapQuick.WeightedNode.class.getName();
  @ ensures this.node == \old(this.node);
  @ ensures this.path == \old(this.path);
  @ ensures this.path.node == \old(this.path.node);
  @ ensures this.path.path == \old(this.path.path);
  @ ensures this.path.path.node == \old(this.path.path.node);
  @ ensures this.path.path.path == \old(this.path.path.path);
  @ ensures this.path.path.cost == \old(this.path.path.cost);
  @ ensures this.path.cost == \old(this.path.cost);
  @ ensures this.cost == \old(this.cost);
  @ ensures \result != null;
  @ ensures \result.getClass().getName() == MapQuick.WeightedNodePath.class.getName();
  @ ensures \result.getClass().getName().contains(\old(o.getClass().getName()));
  @ ensures \result.getClass().getName() != \old(o.getClass().getName());
  @*/
  // Specified by the Path interface
  public Path extend(Object o) {
    if (o instanceof WeightedNode) {
      return extend((WeightedNode)o);
    }
    throw new IllegalArgumentException();
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires node != null;
  @ ensures this.node == \old(this.node);
  @ ensures this.path == \old(this.path);
  @ ensures this.path.node == \old(this.path.node);
  @ ensures this.path.path == \old(this.path.path);
  @ ensures this.path.path.node == \old(this.path.path.node);
  @ ensures this.path.path.path == \old(this.path.path.path);
  @ ensures this.path.path.cost == \old(this.path.path.cost);
  @ ensures this.path.cost == \old(this.path.cost);
  @ ensures this.cost == \old(this.cost);
  @ ensures \result != null;
  @ ensures \result.getClass().getName() == MapQuick.WeightedNodePath.class.getName();
  @*/
  // Specified by the Path interface
  public Path extend(WeightedNode node) {
    return new WeightedNodePath(node, this);
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ ensures this.node == \old(this.node);
  @ ensures this.path == \old(this.path);
  @ ensures this.path.node == \old(this.path.node);
  @ ensures this.path.path == \old(this.path.path);
  @ ensures this.path.path.node == \old(this.path.path.node);
  @ ensures this.path.path.path == \old(this.path.path.path);
  @ ensures this.path.path.cost == \old(this.path.path.cost);
  @ ensures this.path.cost == \old(this.path.cost);
  @ ensures this.cost == \old(this.cost);
  @ ensures \result >= 1.0;
  @*/
  // Specified by the Path interface
  public double cost() {
    return cost;
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ ensures this.node == \old(this.node);
  @ ensures this.path == \old(this.path);
  @ ensures this.path.node == \old(this.path.node);
  @ ensures this.path.path == \old(this.path.path);
  @ ensures this.path.path.node == \old(this.path.path.node);
  @ ensures this.path.path.path == \old(this.path.path.path);
  @ ensures this.path.path.cost == \old(this.path.path.cost);
  @ ensures this.path.cost == \old(this.path.cost);
  @ ensures this.cost == \old(this.cost);
  @ ensures \result != null;
  @ ensures \result.getClass().getName() == java.util.Collections$UnmodifiableCollection$1.class.getName();
  @*/
  // Specified by the Path interface
  public Iterator elements() {
    LinkedList l = new LinkedList();
    WeightedNodePath wnp = this;
    while (wnp != null) {
      l.addFirst(wnp.node);
      wnp = wnp.path;
    }
    return Collections.unmodifiableList(l).iterator();
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  // Specified by the Object superclass
  public String toString() {
    StringBuffer buff = new StringBuffer();
    buff.append("[WeightedNodePath: ");
    Iterator i = elements();
    while (i.hasNext()) {
      buff.append(i.next());
      if (i.hasNext()) {
	buff.append(", ");
      }
    }
    buff.append("]");
    return buff.toString();
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  /**
   * @return true iff o is a WeightedNodePath and o.elements is the
   * same sequence as this.elements
   */
  public boolean equals(Object o) {
    if (o instanceof WeightedNodePath) {
      return this.equals((WeightedNodePath) o);
    } else {
      return false;
    }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  /**
   * @return true iff wnp.elements is the same sequence as this.elements
   */
  public boolean equals(WeightedNodePath wnp) {
    return (wnp != null) && this.node.equals(wnp.node) && (this.path == null ? wnp.path==null : this.path.equals(wnp.path));
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ requires this.path == null;
  @ ensures this.node == \old(this.node);
  @ ensures this.path == \old(this.path);
  @ ensures this.cost == \old(this.cost);
  @ ensures this.path == null;
  @*/
  // Specified by the Object superclass
  public int hashCode() {
    return node.hashCode() + (this.path==null ? 0 : 13 * path.hashCode());
  }
}

