package six170;

import java.util.*;

/**
 * A HuffmanCodec represents a particular Huffman encoding/decoding
 * scheme.  It is build from a list of symbols which are to be
 * encoding as well as their corresponding frequencies.
 */
public class HuffmanCodec {

  /*@ invariant this.encodingMap != null; */
  /*@ invariant this.encodingMap.getClass().getName() == java.util.LinkedHashMap.class.getName(); */
  /*@ invariant this.decodingTree != null; */
  /*@ invariant this.decodingTree.symbol == null; */
  /*@ invariant this.decodingTree.left != null; */
  /*@ invariant this.decodingTree.left.symbol == null; */
  /*@ invariant this.decodingTree.left.left != null; */
  /*@ invariant this.decodingTree.left.right != null; */
  /*@ invariant this.decodingTree.right != null; */
  /*@ invariant this.decodingTree.right.symbol == null; */
  /*@ invariant this.decodingTree.right.left != null; */
  /*@ invariant this.decodingTree.right.right != null; */
  /*@ spec_public */ private Map encodingMap;
  /*@ spec_public */ private HuffmanTree decodingTree;

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires huffmanSymbols.getClass().getName() == java.util.ArrayList.class.getName();
  @ ensures daikon.Quant.pairwiseEqual(huffmanSymbols, \old(huffmanSymbols));
  @*/
  /**
   * @requires: huffmanSymbols contains elements of type HuffmanSymbol
   *
   * @effects: constructs a new HuffmanCodec capable of encoding the
   * symbols contained in <code>huffmanSymbols</code>.
   */
  public HuffmanCodec(List huffmanSymbols) {
    decodingTree = buildDecodingTree(huffmanSymbols);
    encodingMap = buildEncodingMap(decodingTree);
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires huffmanSymbols.getClass().getName() == java.util.ArrayList.class.getName();
  @ ensures daikon.Quant.pairwiseEqual(huffmanSymbols, \old(huffmanSymbols));
  @ ensures \result.symbol == null;
  @ ensures \result.left.symbol == null;
  @ ensures \result.right.symbol == null;
  @*/
  /**
   * @requires: huffmanSymbols contains elements of type HuffmanSymbol
   *
   * @effects: builds an decoding tree of the symbols contained in
   * <code>huffmanSymbols</code> using a Huffman scheme based on the
   * frequencies reported by the symbols.
   */
  private static HuffmanTree buildDecodingTree(List huffmanSymbols) {
    // this method works by creating a list of subtrees and repeatedly
    // merging the two with the highest frequencies under one parent
    // until only one tree exists with all of the nodes as leaves.

    List nodeList = new ArrayList();

    Iterator symbolIterator = huffmanSymbols.iterator();

    while (symbolIterator.hasNext()) {
      HuffmanSymbol hs = (HuffmanSymbol) symbolIterator.next();
      nodeList.add(new HuffmanTree(hs));
    }

    while (nodeList.size() > 1) {
      HuffmanTree h1 = extractSmallest(nodeList);
      HuffmanTree h2 = extractSmallest(nodeList);

      nodeList.add(new HuffmanTree(h1, h2));
    }

    return (HuffmanTree) nodeList.get(0);
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires nodeList != null;
  @ requires daikon.Quant.noDups(nodeList);
  @ requires daikon.Quant.eltsNotEqual(nodeList, null);
  @ requires nodeList.getClass().getName() == java.util.ArrayList.class.getName();
  @ requires daikon.Quant.size(nodeList) >= 1;
  @ ensures daikon.Quant.noDups(nodeList);
  @ ensures daikon.Quant.eltsNotEqual(nodeList, null);
  @ ensures \result != null;
  @ ensures \result.symbol.symbol != null;
  @ ensures \result.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures \result.symbol.frequency >= 1;
  @ ensures daikon.Quant.subsetOf(nodeList, \old(nodeList));
  @ ensures \result.symbol.symbol.getClass().getName() != \old(nodeList.getClass().getName());
  @*/
  /**
   * @requires: nodeList contains elements of type HuffmanTree
   *
   * @modifies: nodeList
   *
   * @effects: removes and returns the element of
   * <code>nodeList</code> which has the smallest
   * <code>frequency</code> value.
   */
  private static HuffmanTree extractSmallest(List nodeList) {
    HuffmanTree smallest = null;
    Iterator iter = nodeList.iterator();
    while (iter.hasNext()) {
      HuffmanTree current = (HuffmanTree) iter.next();
      if (smallest == null ||
          current.frequency() < smallest.frequency()) {
        smallest = current;
      }
    }
    nodeList.remove(smallest);
    return smallest;
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires decodingTree.symbol == null;
  @ requires decodingTree.left.symbol == null;
  @ requires decodingTree.right.symbol == null;
  @ ensures decodingTree.symbol == \old(decodingTree.symbol);
  @ ensures decodingTree.left == \old(decodingTree.left);
  @ ensures decodingTree.left.symbol == \old(decodingTree.left.symbol);
  @ ensures decodingTree.left.left == \old(decodingTree.left.left);
  @ ensures decodingTree.left.right == \old(decodingTree.left.right);
  @ ensures decodingTree.right == \old(decodingTree.right);
  @ ensures decodingTree.right.symbol == \old(decodingTree.right.symbol);
  @ ensures decodingTree.right.left == \old(decodingTree.right.left);
  @ ensures decodingTree.right.right == \old(decodingTree.right.right);
  @ ensures decodingTree.symbol == null;
  @ ensures decodingTree.left.symbol == null;
  @ ensures decodingTree.right.symbol == null;
  @ ensures \result.getClass().getName() == java.util.LinkedHashMap.class.getName();
  @*/
  /**
   * @requires: decodingTree != null
   * @effects: builds a Map which maps Symbols from
   * <code>decodingTree</code> to the bit sequencies used to encode
   * them.  The values in the returned map will be
   * <code>java.util.List</code> objects containing
   * <code>Boolean</code> elements.  A true element maps to a right
   * hand subtree in <code>decodingTree</code> and a false element
   * maps to a left hand subtree.
   */
  private static Map buildEncodingMap(HuffmanTree decodingTree) {
    Map encodingMap = new LinkedHashMap();
    List stack = new ArrayList();
    addToMap(encodingMap, decodingTree, stack);
    return encodingMap;
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires encodingMap != null;
  @ requires encodingMap.getClass().getName() == java.util.LinkedHashMap.class.getName();
  @ requires subTree != null;
  @ requires subTree.symbol.symbol != null;
  @ requires subTree.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ requires subTree.symbol.frequency >= 1;
  @ requires bitStack != null;
  @ requires daikon.Quant.eltsNotEqual(bitStack, null);
  @ requires bitStack.getClass().getName() == java.util.ArrayList.class.getName();
  @ requires encodingMap.getClass().getName() != subTree.symbol.symbol.getClass().getName();
  @ requires encodingMap.getClass().getName() != bitStack.getClass().getName();
  @ requires subTree.symbol.symbol.getClass().getName() != bitStack.getClass().getName();
  @ ensures subTree.symbol == \old(subTree.symbol);
  @ ensures subTree.symbol.symbol == \old(subTree.symbol.symbol);
  @ ensures subTree.symbol.symbol.getClass().getName() == \old(subTree.symbol.symbol.getClass().getName());
  @ ensures subTree.symbol.frequency == \old(subTree.symbol.frequency);
  @ ensures subTree.left == \old(subTree.left);
  @ ensures subTree.left.symbol == \old(subTree.left.symbol);
  @ ensures subTree.left.left == \old(subTree.left.left);
  @ ensures subTree.left.right == \old(subTree.left.right);
  @ ensures subTree.right == \old(subTree.right);
  @ ensures subTree.right.symbol == \old(subTree.right.symbol);
  @ ensures subTree.right.left == \old(subTree.right.left);
  @ ensures subTree.right.right == \old(subTree.right.right);
  @ ensures daikon.Quant.pairwiseEqual(bitStack, \old(bitStack));
  @ ensures subTree.symbol.symbol != null;
  @ ensures subTree.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures subTree.symbol.frequency >= 1;
  @ ensures daikon.Quant.eltsNotEqual(bitStack, null);
  @ ensures subTree.symbol.symbol.getClass().getName() != \old(encodingMap.getClass().getName());
  @ ensures subTree.symbol.symbol.getClass().getName() != \old(bitStack.getClass().getName());
  @*/
  /**
   * implements the recursive portion of buildEncodingMap
   */
  private static void addToMap(Map encodingMap,
                               HuffmanTree subTree,
                               List bitStack) {
    if (subTree.symbol() != null) {
      encodingMap.put(subTree.symbol(),
                      new ArrayList(bitStack));
    }

    if (subTree.left() != null) {
      bitStack.add(Boolean.valueOf(false));
      addToMap(encodingMap,
               subTree.left(),
               bitStack);
      bitStack.remove(bitStack.size()-1);
    }

    if (subTree.right() != null) {
      bitStack.add(Boolean.valueOf(true));
      addToMap(encodingMap,
               subTree.right(),
               bitStack);
      bitStack.remove(bitStack.size()-1);
    }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires inputStream.getClass().getName() == java.util.ArrayList.class.getName();
  @ ensures this.encodingMap == \old(this.encodingMap);
  @ ensures this.encodingMap.getClass().getName() == \old(this.encodingMap.getClass().getName());
  @ ensures this.decodingTree == \old(this.decodingTree);
  @ ensures this.decodingTree.symbol == \old(this.decodingTree.symbol);
  @ ensures this.decodingTree.left == \old(this.decodingTree.left);
  @ ensures this.decodingTree.left.symbol == \old(this.decodingTree.left.symbol);
  @ ensures this.decodingTree.left.left == \old(this.decodingTree.left.left);
  @ ensures this.decodingTree.left.right == \old(this.decodingTree.left.right);
  @ ensures this.decodingTree.right == \old(this.decodingTree.right);
  @ ensures this.decodingTree.right.symbol == \old(this.decodingTree.right.symbol);
  @ ensures this.decodingTree.right.left == \old(this.decodingTree.right.left);
  @ ensures this.decodingTree.right.right == \old(this.decodingTree.right.right);
  @ ensures daikon.Quant.pairwiseEqual(inputStream, \old(inputStream));
  @ ensures \result.getClass().getName() == \old(inputStream.getClass().getName());
  @ ensures \result.getClass().getName() == java.util.ArrayList.class.getName();
  @ ensures daikon.Quant.size(\result) == (daikon.Quant.size(\result)-1 | daikon.Quant.size(\result));
  @*/
  /**
   * @requires: inputStream != null && the elements of
   * <code>inputStream</code> are valid symbols for this codec.
   *
   * @effects: encodes <code>inputStream</code> into a bit stream
   * using the huffman encoding specified by this codec.
   *
   * @return a List containing Boolean objects representing the bits
   * of the encoded data.
   */
  public List encode(List inputStream) {
    List outputStream = new ArrayList();
    Iterator iter = inputStream.iterator();
    while (iter.hasNext()) {
      Object v = iter.next();
      outputStream.addAll((List)encodingMap.get(v)); // appends to the list
    }
    return outputStream;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires inputBitStream.getClass().getName() == java.util.ArrayList.class.getName();
  @ requires daikon.Quant.size(inputBitStream) == (daikon.Quant.size(inputBitStream)-1 | daikon.Quant.size(inputBitStream));
  @ ensures this.encodingMap == \old(this.encodingMap);
  @ ensures this.encodingMap.getClass().getName() == \old(this.encodingMap.getClass().getName());
  @ ensures this.decodingTree == \old(this.decodingTree);
  @ ensures this.decodingTree.symbol == \old(this.decodingTree.symbol);
  @ ensures this.decodingTree.left == \old(this.decodingTree.left);
  @ ensures this.decodingTree.left.symbol == \old(this.decodingTree.left.symbol);
  @ ensures this.decodingTree.left.left == \old(this.decodingTree.left.left);
  @ ensures this.decodingTree.left.right == \old(this.decodingTree.left.right);
  @ ensures this.decodingTree.right == \old(this.decodingTree.right);
  @ ensures this.decodingTree.right.symbol == \old(this.decodingTree.right.symbol);
  @ ensures this.decodingTree.right.left == \old(this.decodingTree.right.left);
  @ ensures this.decodingTree.right.right == \old(this.decodingTree.right.right);
  @ ensures daikon.Quant.pairwiseEqual(inputBitStream, \old(inputBitStream));
  @ ensures \result.getClass().getName() == \old(inputBitStream.getClass().getName());
  @ ensures \result.getClass().getName() == java.util.ArrayList.class.getName();
  @ ensures \old(daikon.Quant.size(inputBitStream)) == (daikon.Quant.size(inputBitStream)-1 | \old(daikon.Quant.size(inputBitStream)));
  @*/
  /**
   * @requires: inputBitStream != null
   * @effects: decodes the bitStream using the huffman encoding
   * specified by this codec.
   * @return a List containing the symbols resulting from the decoding
   */
  public List decode(List inputBitStream) {
    int offset = 0;
    List outputList = new ArrayList();
    while (offset < inputBitStream.size()) {
      HuffmanTree subTree = decodingTree;

      while (offset < inputBitStream.size()) {
        if (((Boolean) inputBitStream.get(offset)).booleanValue()) {
          subTree = subTree.right();
        } else {
          subTree = subTree.left();
        }
        if (subTree == null) {
          throw new IllegalStateException("Unrecognized Symbol in stream");
        }
        if (subTree.symbol() != null) {
          outputList.add(subTree.symbol());
          break;
        }
        offset++;
      }
      offset++;
    }
    return outputList;
  }
}
package six170;

/**
 * A HuffmanSymbol represents a single symbol in the unencoded string.
 * For instance one is using Huffman encoding to encode a sequence of
 * characters, each HuffmanSymbol would match to each letter of the
 * alphabet.
 */

public class HuffmanSymbol {
  
  /*@ invariant this.symbol != null; */
  /*@ invariant this.symbol.getClass().getName() == java.lang.Character.class.getName(); */
  /*@ invariant this.frequency >= 1; */
  /*@ spec_public */ private Object symbol;
  /*@ spec_public */ private int frequency;

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires symbol != null;
  @ requires symbol.getClass().getName() == java.lang.Character.class.getName();
  @ requires frequency >= 1;
  @ ensures this.symbol == \old(symbol);
  @ ensures this.symbol.getClass().getName() == \old(symbol.getClass().getName());
  @ ensures this.frequency == \old(frequency);
  @*/
  // Representation Invariant
  //    symbol != null && frequency >= 0

  /**
   * @requires: symbol != null && frequency >= 0
   * @effects: constructs a new HuffmanSymbol for the given symbol and
   * frequency.
   */
  public HuffmanSymbol(Object symbol, int frequency) {
    this.symbol = symbol;
    this.frequency = frequency;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \result;
  @ ensures this.symbol.getClass().getName() == \result.getClass().getName();
  @ ensures this.frequency == \old(this.frequency);
  @ ensures \result == \old(this.symbol);
  @ ensures \result.getClass().getName() == \old(this.symbol.getClass().getName());
  @ ensures \result != null;
  @ ensures \result.getClass().getName() == java.lang.Character.class.getName();
  @*/
  /**
   * @return the symbol associated with this
   */
  public Object symbol() {
    return symbol;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \old(this.symbol);
  @ ensures this.symbol.getClass().getName() == \old(this.symbol.getClass().getName());
  @ ensures this.frequency == \result;
  @ ensures \result == \old(this.frequency);
  @ ensures \result >= 1;
  @*/
  /**
   * @return the frequency associated with this
   */
  public int frequency() {
    return frequency;
  }

  /*@
  @ also
  @ public normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  public String toString() {
    return "[HuffmanSymbol: symbol=" + symbol + " freq=" + frequency + "]";
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  private void checkRep() {
    if (symbol == null) {
      throw new IllegalStateException("HuffmanSymbol: null symbol");
    }
    if (frequency < 0) {
      throw new IllegalStateException("HuffmanSymbol: frequency less than zero");
    }
  }
}
package six170;

/**
 * A HuffmanTree is used to represent the decoding tree.  The leaves
 * of the tree should each contain a reference to a HuffmanSymbol,
 * while the intermediate nodes do not.  The tree is a binary tree and
 * each node either has two children or none at all.
 */

public class HuffmanTree {

  /*@ invariant this.left.symbol.symbol.getClass().getName() == this.right.symbol.symbol.getClass().getName(); */
  /*@ invariant this.symbol.symbol != null; */
  /*@ invariant this.symbol.symbol.getClass().getName() == java.lang.Character.class.getName(); */
  /*@ invariant this.symbol.frequency >= 1; */
  /*@ invariant this.left.symbol.symbol != null; */
  /*@ invariant this.left.symbol.symbol.getClass().getName() == java.lang.Character.class.getName(); */
  /*@ invariant this.left.symbol.frequency >= 1; */
  /*@ invariant this.right.symbol.symbol != null; */
  /*@ invariant this.right.symbol.symbol.getClass().getName() == java.lang.Character.class.getName(); */
  /*@ invariant this.right.symbol.frequency >= 1; */
  /*@ invariant this.left.symbol.frequency <= this.right.symbol.frequency; */
  /*@ spec_public */ private HuffmanSymbol symbol;
  /*@ spec_public */ private HuffmanTree left, right;

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires symbol != null;
  @ requires symbol.symbol != null;
  @ requires symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ requires symbol.frequency >= 1;
  @ ensures this.symbol == \old(symbol);
  @ ensures this.symbol.symbol == symbol.symbol;
  @ ensures this.symbol.symbol.getClass().getName() == symbol.symbol.getClass().getName();
  @ ensures this.symbol.frequency == symbol.frequency;
  @ ensures this.left == this.right;
  @ ensures symbol.symbol == \old(symbol.symbol);
  @ ensures symbol.symbol.getClass().getName() == \old(symbol.symbol.getClass().getName());
  @ ensures symbol.frequency == \old(symbol.frequency);
  @ ensures this.symbol != null;
  @ ensures this.left == null;
  @ ensures symbol.symbol != null;
  @ ensures symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures symbol.frequency >= 1;
  @*/
  // Representation invariant
  //    (symbol != null && left == null && right == null) ||
  //    (symbol == null && left != null && right != null)
  
  /**
   * @requires: symbol != null
   * @effects: creates a new HuffmanTree with only one leaf node
   * containing <code>symbol</code>.  
   */
  public HuffmanTree(HuffmanSymbol symbol) {
    if (symbol == null) {
      throw new IllegalArgumentException("null symbols are not allowed for leaf nodes");
    }
    this.symbol = symbol;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires left.symbol.symbol.getClass().getName() == right.symbol.symbol.getClass().getName();
  @ requires left != null;
  @ requires left.symbol.symbol != null;
  @ requires left.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ requires left.symbol.frequency >= 1;
  @ requires right != null;
  @ requires right.symbol.symbol != null;
  @ requires right.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ requires right.symbol.frequency >= 1;
  @ requires left.symbol.frequency <= right.symbol.frequency;
  @ ensures this.left == \old(left);
  @ ensures this.left.symbol == left.symbol;
  @ ensures this.left.symbol.symbol == left.symbol.symbol;
  @ ensures this.left.symbol.symbol.getClass().getName() == left.symbol.symbol.getClass().getName();
  @ ensures this.left.symbol.frequency == left.symbol.frequency;
  @ ensures this.left.left == left.left;
  @ ensures this.left.left.symbol == left.left.symbol;
  @ ensures this.left.left.left == left.left.left;
  @ ensures this.left.left.right == left.left.right;
  @ ensures this.left.right == left.right;
  @ ensures this.left.right.symbol == left.right.symbol;
  @ ensures this.left.right.left == left.right.left;
  @ ensures this.left.right.right == left.right.right;
  @ ensures this.right == \old(right);
  @ ensures this.right.symbol == right.symbol;
  @ ensures this.right.symbol.symbol == right.symbol.symbol;
  @ ensures this.right.symbol.symbol.getClass().getName() == right.symbol.symbol.getClass().getName();
  @ ensures this.right.symbol.frequency == right.symbol.frequency;
  @ ensures this.right.left == right.left;
  @ ensures this.right.left.symbol == right.left.symbol;
  @ ensures this.right.left.left == right.left.left;
  @ ensures this.right.left.right == right.left.right;
  @ ensures this.right.right == right.right;
  @ ensures this.right.right.symbol == right.right.symbol;
  @ ensures this.right.right.left == right.right.left;
  @ ensures this.right.right.right == right.right.right;
  @ ensures left.symbol == \old(left.symbol);
  @ ensures left.symbol.symbol == \old(left.symbol.symbol);
  @ ensures left.symbol.symbol.getClass().getName() == right.symbol.symbol.getClass().getName();
  @ ensures left.symbol.symbol.getClass().getName() == \old(left.symbol.symbol.getClass().getName());
  @ ensures left.symbol.frequency == \old(left.symbol.frequency);
  @ ensures left.left == \old(left.left);
  @ ensures left.left.symbol == \old(left.left.symbol);
  @ ensures left.left.left == \old(left.left.left);
  @ ensures left.left.right == \old(left.left.right);
  @ ensures left.right == \old(left.right);
  @ ensures left.right.symbol == \old(left.right.symbol);
  @ ensures left.right.left == \old(left.right.left);
  @ ensures left.right.right == \old(left.right.right);
  @ ensures right.symbol == \old(right.symbol);
  @ ensures right.symbol.symbol == \old(right.symbol.symbol);
  @ ensures right.symbol.symbol.getClass().getName() == \old(right.symbol.symbol.getClass().getName());
  @ ensures right.symbol.frequency == \old(right.symbol.frequency);
  @ ensures right.left == \old(right.left);
  @ ensures right.left.symbol == \old(right.left.symbol);
  @ ensures right.left.left == \old(right.left.left);
  @ ensures right.left.right == \old(right.left.right);
  @ ensures right.right == \old(right.right);
  @ ensures right.right.symbol == \old(right.right.symbol);
  @ ensures right.right.left == \old(right.right.left);
  @ ensures right.right.right == \old(right.right.right);
  @ ensures this.symbol == null;
  @ ensures this.left != null;
  @ ensures this.right != null;
  @ ensures left.symbol.symbol != null;
  @ ensures left.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures left.symbol.frequency >= 1;
  @ ensures right.symbol.symbol != null;
  @ ensures right.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures right.symbol.frequency >= 1;
  @ ensures left.symbol.frequency <= right.symbol.frequency;
  @*/
  /**
   * @requires: left != null && right != null
   * @effects: consntructs a new HuffmanTree which contains
   * <code>left</code> as the left subtree and <code>right</code> as
   * the right subtree.
   */
  public HuffmanTree(HuffmanTree left, HuffmanTree right) {
    if (left == null || right == null) {
      throw new IllegalArgumentException("null subtrees are not allowed");
    }
    this.left = left;
    this.right = right;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \old(this.symbol);
  @ ensures this.symbol.symbol == \old(this.symbol.symbol);
  @ ensures this.symbol.symbol.getClass().getName() == \old(this.symbol.symbol.getClass().getName());
  @ ensures this.symbol.frequency == \result;
  @ ensures this.symbol.frequency == \old(this.symbol.frequency);
  @ ensures this.left == \old(this.left);
  @ ensures this.left.symbol == \old(this.left.symbol);
  @ ensures this.left.symbol.symbol == \old(this.left.symbol.symbol);
  @ ensures this.left.symbol.symbol.getClass().getName() == \old(this.left.symbol.symbol.getClass().getName());
  @ ensures this.left.symbol.frequency == \old(this.left.symbol.frequency);
  @ ensures this.left.left == \old(this.left.left);
  @ ensures this.left.left.symbol == \old(this.left.left.symbol);
  @ ensures this.left.left.left == \old(this.left.left.left);
  @ ensures this.left.left.right == \old(this.left.left.right);
  @ ensures this.left.right == \old(this.left.right);
  @ ensures this.left.right.symbol == \old(this.left.right.symbol);
  @ ensures this.left.right.left == \old(this.left.right.left);
  @ ensures this.left.right.right == \old(this.left.right.right);
  @ ensures this.right == \old(this.right);
  @ ensures this.right.symbol == \old(this.right.symbol);
  @ ensures this.right.symbol.symbol == \old(this.right.symbol.symbol);
  @ ensures this.right.symbol.symbol.getClass().getName() == \old(this.right.symbol.symbol.getClass().getName());
  @ ensures this.right.symbol.frequency == \old(this.right.symbol.frequency);
  @ ensures this.right.left == \old(this.right.left);
  @ ensures this.right.left.symbol == \old(this.right.left.symbol);
  @ ensures this.right.left.left == \old(this.right.left.left);
  @ ensures this.right.left.right == \old(this.right.left.right);
  @ ensures this.right.right == \old(this.right.right);
  @ ensures this.right.right.symbol == \old(this.right.right.symbol);
  @ ensures this.right.right.left == \old(this.right.right.left);
  @ ensures this.right.right.right == \old(this.right.right.right);
  @ ensures (this.symbol != null)  <==>  (this.left == null);
  @ ensures (this.symbol != null)  <==>  (this.right == null);
  @ ensures (this.symbol != null)  ==>  (\result >= 1);
  @ ensures (this.symbol != null)  ==>  (this.left == this.right);
  @ ensures (this.symbol != null)  ==>  (this.symbol.frequency == \result);
  @ ensures (this.symbol != null)  ==>  (this.symbol.frequency >= 1);
  @ ensures (this.symbol != null)  ==>  (this.symbol.symbol != null);
  @ ensures (this.symbol != null)  ==>  (this.symbol.symbol.getClass().getName() == java.lang.Character.class.getName());
  @ ensures (this.symbol == null)  <==>  (this.left != null);
  @ ensures (this.symbol == null)  <==>  (this.right != null);
  @ ensures (this.symbol == null)  ==>  (\result >= 2);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency + this.right.symbol.frequency - \result == 0);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency < \result);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency <= this.right.symbol.frequency);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency >= 1);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol != null);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol.getClass().getName() == java.lang.Character.class.getName());
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol.getClass().getName() == this.right.symbol.symbol.getClass().getName());
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.frequency < \result);
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.frequency >= 1);
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.symbol != null);
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.symbol.getClass().getName() == java.lang.Character.class.getName());
  @ ensures \result >= 1;
  @ ensures this.left.symbol.frequency < \result;
  @ ensures this.right.symbol.frequency < \result;
  @ ensures this.left.symbol.frequency + this.right.symbol.frequency - \result == 0;
  @*/
  /**
   * @return the total frequency of all HuffmanSymbols in this tree
   * (including all children).  
   */
  public int frequency() {
    if (symbol != null) {
      return symbol.frequency();
    } else {
      return left.frequency() + right.frequency();
    }
  }	

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \old(this.symbol);
  @ ensures this.symbol.symbol == \result;
  @ ensures this.symbol.symbol == \old(this.symbol.symbol);
  @ ensures this.symbol.symbol.getClass().getName() == \result.getClass().getName();
  @ ensures this.symbol.frequency == \old(this.symbol.frequency);
  @ ensures this.left == \old(this.left);
  @ ensures this.left.symbol == \old(this.left.symbol);
  @ ensures this.left.symbol.symbol == \old(this.left.symbol.symbol);
  @ ensures this.left.symbol.symbol.getClass().getName() == \old(this.left.symbol.symbol.getClass().getName());
  @ ensures this.left.symbol.frequency == \old(this.left.symbol.frequency);
  @ ensures this.left.left == \old(this.left.left);
  @ ensures this.left.left.symbol == \old(this.left.left.symbol);
  @ ensures this.left.left.left == \old(this.left.left.left);
  @ ensures this.left.left.right == \old(this.left.left.right);
  @ ensures this.left.right == \old(this.left.right);
  @ ensures this.left.right.symbol == \old(this.left.right.symbol);
  @ ensures this.left.right.left == \old(this.left.right.left);
  @ ensures this.left.right.right == \old(this.left.right.right);
  @ ensures this.right == \old(this.right);
  @ ensures this.right.symbol == \old(this.right.symbol);
  @ ensures this.right.symbol.symbol == \old(this.right.symbol.symbol);
  @ ensures this.right.symbol.symbol.getClass().getName() == \old(this.right.symbol.symbol.getClass().getName());
  @ ensures this.right.symbol.frequency == \old(this.right.symbol.frequency);
  @ ensures this.right.left == \old(this.right.left);
  @ ensures this.right.left.symbol == \old(this.right.left.symbol);
  @ ensures this.right.left.left == \old(this.right.left.left);
  @ ensures this.right.left.right == \old(this.right.left.right);
  @ ensures this.right.right == \old(this.right.right);
  @ ensures this.right.right.symbol == \old(this.right.right.symbol);
  @ ensures this.right.right.left == \old(this.right.right.left);
  @ ensures this.right.right.right == \old(this.right.right.right);
  @ ensures \result.getClass().getName() == \old(this.symbol.symbol.getClass().getName());
  @ ensures (this.symbol != null)  <==>  (\result != null);
  @ ensures (this.symbol != null)  <==>  (this.left == null);
  @ ensures (this.symbol != null)  <==>  (this.right == null);
  @ ensures (this.symbol != null)  ==>  (\result.getClass().getName() == java.lang.Character.class.getName());
  @ ensures (this.symbol != null)  ==>  (this.left == this.right);
  @ ensures (this.symbol != null)  ==>  (this.symbol.frequency >= 1);
  @ ensures (this.symbol != null)  ==>  (this.symbol.symbol != null);
  @ ensures (this.symbol != null)  ==>  (this.symbol.symbol == \result);
  @ ensures (this.symbol == null)  <==>  (\result == null);
  @ ensures (this.symbol == null)  <==>  (this.left != null);
  @ ensures (this.symbol == null)  <==>  (this.right != null);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency <= this.right.symbol.frequency);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.frequency >= 1);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol != null);
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol.getClass().getName() == java.lang.Character.class.getName());
  @ ensures (this.symbol == null)  ==>  (this.left.symbol.symbol.getClass().getName() == this.right.symbol.symbol.getClass().getName());
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.frequency >= 1);
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.symbol != null);
  @ ensures (this.symbol == null)  ==>  (this.right.symbol.symbol.getClass().getName() == java.lang.Character.class.getName());
  @ ensures \result.getClass().getName() == java.lang.Character.class.getName();
  @*/
  /**
   * @return the symbol which is located at this node or null of this
   * node is not a leaf of the tree.  
   */
  public Object symbol() {
    if (symbol == null) {
      return null;
    } else {
      return symbol.symbol();
    }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \old(this.symbol);
  @ ensures this.symbol.symbol == \old(this.symbol.symbol);
  @ ensures this.symbol.symbol.getClass().getName() == \old(this.symbol.symbol.getClass().getName());
  @ ensures this.symbol.frequency == \old(this.symbol.frequency);
  @ ensures this.left == \result;
  @ ensures this.left.symbol == \result.symbol;
  @ ensures this.left.symbol.symbol == \result.symbol.symbol;
  @ ensures this.left.symbol.symbol.getClass().getName() == \result.symbol.symbol.getClass().getName();
  @ ensures this.left.symbol.frequency == \result.symbol.frequency;
  @ ensures this.left.left == \result.left;
  @ ensures this.left.left.symbol == \result.left.symbol;
  @ ensures this.left.left.left == \result.left.left;
  @ ensures this.left.left.right == \result.left.right;
  @ ensures this.left.right == \result.right;
  @ ensures this.left.right.symbol == \result.right.symbol;
  @ ensures this.left.right.left == \result.right.left;
  @ ensures this.left.right.right == \result.right.right;
  @ ensures this.right == \old(this.right);
  @ ensures this.right.symbol == \old(this.right.symbol);
  @ ensures this.right.symbol.symbol == \old(this.right.symbol.symbol);
  @ ensures this.right.symbol.symbol.getClass().getName() == \result.symbol.symbol.getClass().getName();
  @ ensures this.right.symbol.symbol.getClass().getName() == \old(this.right.symbol.symbol.getClass().getName());
  @ ensures this.right.symbol.frequency == \old(this.right.symbol.frequency);
  @ ensures this.right.left == \old(this.right.left);
  @ ensures this.right.left.symbol == \old(this.right.left.symbol);
  @ ensures this.right.left.left == \old(this.right.left.left);
  @ ensures this.right.left.right == \old(this.right.left.right);
  @ ensures this.right.right == \old(this.right.right);
  @ ensures this.right.right.symbol == \old(this.right.right.symbol);
  @ ensures this.right.right.left == \old(this.right.right.left);
  @ ensures this.right.right.right == \old(this.right.right.right);
  @ ensures \result == \old(this.left);
  @ ensures \result.symbol == \old(this.left.symbol);
  @ ensures \result.symbol.symbol == \old(this.left.symbol.symbol);
  @ ensures \result.symbol.symbol.getClass().getName() == \old(this.left.symbol.symbol.getClass().getName());
  @ ensures \result.symbol.frequency == \old(this.left.symbol.frequency);
  @ ensures \result.left == \old(this.left.left);
  @ ensures \result.left.symbol == \old(this.left.left.symbol);
  @ ensures \result.left.left == \old(this.left.left.left);
  @ ensures \result.left.right == \old(this.left.left.right);
  @ ensures \result.right == \old(this.left.right);
  @ ensures \result.right.symbol == \old(this.left.right.symbol);
  @ ensures \result.right.left == \old(this.left.right.left);
  @ ensures \result.right.right == \old(this.left.right.right);
  @ ensures \result.symbol.symbol != null;
  @ ensures \result.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures \result.symbol.frequency >= 1;
  @ ensures this.right.symbol.frequency >= \result.symbol.frequency;
  @*/
  /**
   * @return the left subtree of this tree.  If no such subtree exists
   * (it is already a leaf node) returns null.  
   */
  public HuffmanTree left() {
    return left;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.symbol == \old(this.symbol);
  @ ensures this.symbol.symbol == \old(this.symbol.symbol);
  @ ensures this.symbol.symbol.getClass().getName() == \old(this.symbol.symbol.getClass().getName());
  @ ensures this.symbol.frequency == \old(this.symbol.frequency);
  @ ensures this.left == \old(this.left);
  @ ensures this.left.symbol == \old(this.left.symbol);
  @ ensures this.left.symbol.symbol == \old(this.left.symbol.symbol);
  @ ensures this.left.symbol.symbol.getClass().getName() == \result.symbol.symbol.getClass().getName();
  @ ensures this.left.symbol.symbol.getClass().getName() == \old(this.left.symbol.symbol.getClass().getName());
  @ ensures this.left.symbol.frequency == \old(this.left.symbol.frequency);
  @ ensures this.left.left == \old(this.left.left);
  @ ensures this.left.left.symbol == \old(this.left.left.symbol);
  @ ensures this.left.left.left == \old(this.left.left.left);
  @ ensures this.left.left.right == \old(this.left.left.right);
  @ ensures this.left.right == \old(this.left.right);
  @ ensures this.left.right.symbol == \old(this.left.right.symbol);
  @ ensures this.left.right.left == \old(this.left.right.left);
  @ ensures this.left.right.right == \old(this.left.right.right);
  @ ensures this.right == \result;
  @ ensures this.right.symbol == \result.symbol;
  @ ensures this.right.symbol.symbol == \result.symbol.symbol;
  @ ensures this.right.symbol.symbol.getClass().getName() == \result.symbol.symbol.getClass().getName();
  @ ensures this.right.symbol.frequency == \result.symbol.frequency;
  @ ensures this.right.left == \result.left;
  @ ensures this.right.left.symbol == \result.left.symbol;
  @ ensures this.right.left.left == \result.left.left;
  @ ensures this.right.left.right == \result.left.right;
  @ ensures this.right.right == \result.right;
  @ ensures this.right.right.symbol == \result.right.symbol;
  @ ensures this.right.right.left == \result.right.left;
  @ ensures this.right.right.right == \result.right.right;
  @ ensures \result == \old(this.right);
  @ ensures \result.symbol == \old(this.right.symbol);
  @ ensures \result.symbol.symbol == \old(this.right.symbol.symbol);
  @ ensures \result.symbol.symbol.getClass().getName() == \old(this.right.symbol.symbol.getClass().getName());
  @ ensures \result.symbol.frequency == \old(this.right.symbol.frequency);
  @ ensures \result.left == \old(this.right.left);
  @ ensures \result.left.symbol == \old(this.right.left.symbol);
  @ ensures \result.left.left == \old(this.right.left.left);
  @ ensures \result.left.right == \old(this.right.left.right);
  @ ensures \result.right == \old(this.right.right);
  @ ensures \result.right.symbol == \old(this.right.right.symbol);
  @ ensures \result.right.left == \old(this.right.right.left);
  @ ensures \result.right.right == \old(this.right.right.right);
  @ ensures \result.symbol.symbol != null;
  @ ensures \result.symbol.symbol.getClass().getName() == java.lang.Character.class.getName();
  @ ensures \result.symbol.frequency >= 1;
  @ ensures this.left.symbol.frequency <= \result.symbol.frequency;
  @*/
  /**
   * @return the right subtree of this tree.  If no such subtree exists
   * (it is already a leaf node) returns null.  
   */
  public HuffmanTree right() {
    return right;
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires true;
  @*/
  private void checkRep() {
    if (symbol == null) {
      if (left == null ||
	  right == null) {
	throw new IllegalStateException("non-leaf node has null child");
      }
    } else {
      if (left != null ||
	  right != null) {
	throw new IllegalStateException("non-leaf node has symbol");
      }
    }
  }
}
