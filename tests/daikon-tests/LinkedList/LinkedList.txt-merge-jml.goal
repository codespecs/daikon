package DataStructures;

// LinkedList class
//
// CONSTRUCTION: with no initializer
// Access is via LinkedListItr class
//
// ******************PUBLIC OPERATIONS*********************
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// LinkedListItr zeroth( )--> Return position to prior to first
// LinkedListItr first( ) --> Return first position
// void insert( x, p )    --> Insert x after current iterator position p
// void remove( x )       --> Remove x
// LinkedListItr find( x )
//                        --> Return position that views x
// LinkedListItr findPrevious( x )
//                        --> Return position prior to x
// ******************ERRORS********************************
// No special errors

/**
 * Linked list implementation of the list
 *    using a header node.
 * Access to the list is via LinkedListItr.
 * @author Mark Allen Weiss
 * @see LinkedListItr
 */
public class LinkedList
{
  /*@ invariant this.header != null; */
  /*@ invariant this.header.element == null; */
  /*@ invariant this.header.next.element != null; */
  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header.next == null;
  @*/
  /**
   * Construct the list
   */
  public LinkedList( )
  {
    header = new ListNode( null );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == \old(this.header.next);
  @ ensures this.header.next.element == \old(this.header.next.element);
  @ ensures this.header.next.element.getClass().getName() == \old(this.header.next.element.getClass().getName());
  @ ensures this.header.next.next == \old(this.header.next.next);
  @ ensures (this.header.next != null)  <==>  (\result == false);
  @ ensures (this.header.next != null)  ==>  (this.header.next.element != null);
  @ ensures (this.header.next == null)  <==>  (\result == true);
  @*/
  /**
   * Test if the list is logically empty.
   * @return true if empty, false otherwise.
   */
  public boolean isEmpty( )
  {
    return header.next == null;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == null;
  @*/
  /**
   * Make the list logically empty.
   */
  public void makeEmpty( )
  {
    header.next = null;
  }


  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \result.current;
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == \result.current.next;
  @ ensures this.header.next == \old(this.header.next);
  @ ensures this.header.next.element == \old(this.header.next.element);
  @ ensures this.header.next.element.getClass().getName() == \old(this.header.next.element.getClass().getName());
  @ ensures this.header.next.next == \old(this.header.next.next);
  @ ensures \result != null;
  @ ensures \result.current.element == null;
  @*/
  /**
   * Return an iterator representing the header node.
   */
  public LinkedListItr zeroth( )
  {
    return new LinkedListItr( header );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == \result.current;
  @ ensures this.header.next.element == \result.current.element;
  @ ensures this.header.next.element.getClass().getName() == \result.current.element.getClass().getName();
  @ ensures this.header.next.next == \result.current.next;
  @ ensures \result.current == \old(this.header.next);
  @ ensures \result.current.element == \old(this.header.next.element);
  @ ensures \result.current.element.getClass().getName() == \old(this.header.next.element.getClass().getName());
  @ ensures \result.current.next == \old(this.header.next.next);
  @ ensures \result != null;
  @ ensures \result.current.element != null;
  @*/
  /**
   * Return an iterator representing the first node in the list.
   * This operation is valid for empty lists.
   */
  public LinkedListItr first( )
  {
    return new LinkedListItr( header.next );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires x != null;
  @ requires p != null;
  @ requires p.current != null;
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures p.current == \old(p.current);
  @ ensures p.current.element == \old(p.current.element);
  @ ensures p.current.element.getClass().getName() == \old(p.current.element.getClass().getName());
  @ ensures this.header.next != null;
  @ ensures p.current != null;
  @ ensures p.current.next != null;
  @*/
  /**
   * Insert after p.
   * @param x the item to insert.
   * @param p the position prior to the newly inserted item.
   */
  public void insert( Object x, LinkedListItr p )
  {
    if( p != null && p.current != null )
      p.current.next = new ListNode( x, p.current.next );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header.next != null;
  @ requires x != null;
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == \old(this.header.next);
  @ ensures this.header.next.element == \old(this.header.next.element);
  @ ensures this.header.next.element.getClass().getName() == \old(this.header.next.element.getClass().getName());
  @ ensures this.header.next.next == \old(this.header.next.next);
  @ ensures \result.current.element.getClass().getName() == \old(x.getClass().getName());
  @ ensures this.header.next != null;
  @ ensures \result != null;
  @ ensures \result.current.element != null;
  @*/
  /**
   * Return iterator corresponding to the first node containing an item.
   * @param x the item to search for.
   * @return an iterator; iterator isPastEnd if item is not found.
   */
  public LinkedListItr find( Object x )
  {
    ListNode itr = header.next;

    while( itr != null && !itr.element.equals( x ) )
      itr = itr.next;

    return new LinkedListItr( itr );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires x != null;
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next == \old(this.header.next);
  @ ensures this.header.next.element == \old(this.header.next.element);
  @ ensures this.header.next.element.getClass().getName() == \old(this.header.next.element.getClass().getName());
  @ ensures this.header.next.next == \old(this.header.next.next);
  @ ensures \result != null;
  @ ensures \result.current != null;
  @*/
  /**
   * Return iterator prior to the first node containing an item.
   * @param x the item to search for.
   * @return appropriate iterator if the item is found. Otherwise, the
   * iterator corresponding to the last element in the list is returned.
   */
  public LinkedListItr findPrevious( Object x )
  {
    ListNode itr = header;

    while( itr.next != null && !itr.next.element.equals( x ) )
      itr = itr.next;

    return new LinkedListItr( itr );
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.header.next.element.getClass().getName() == x.getClass().getName();
  @ requires this.header.next != null;
  @ requires this.header.next.next != null;
  @ requires x != null;
  @ ensures this.header == \old(this.header);
  @ ensures this.header.element == \old(this.header.element);
  @ ensures this.header.next != null;
  @*/
  /**
   * Remove the first occurrence of an item.
   * @param x the item to remove.
   */
  public void remove( Object x )
  {
    LinkedListItr p = findPrevious( x );

    if( p.current.next != null )
      p.current.next = p.current.next.next;  // Bypass deleted node
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires theList != null;
  @ requires theList.header != null;
  @ requires theList.header.element == null;
  @ ensures theList.header == \old(theList.header);
  @ ensures theList.header.element == \old(theList.header.element);
  @ ensures theList.header.next == \old(theList.header.next);
  @ ensures theList.header != null;
  @ ensures theList.header.element == null;
  @*/
  // Simple print method
  public static void printList( LinkedList theList )
  {
    if( theList.isEmpty( ) )
      System.out.print( "Empty list" );
    else
      {
      LinkedListItr itr = theList.first( );
      for( ; !itr.isPastEnd( ); itr.advance( ) )
      {Object junk = itr.retrieve( ); /*System.out.print( itr.retrieve( ) + " " );*/ }
      }

    System.out.println( );
  }

  /*@ spec_public */ private ListNode header;

}
package DataStructures;

// LinkedListItr class; maintains "current position"
//
// CONSTRUCTION: Package friendly only, with a ListNode
//
// ******************PUBLIC OPERATIONS*********************
// void advance( )        --> Advance
// boolean isPastEnd( )   --> True if at "null" position in list
// Object retrieve        --> Return item in current position

/**
 * Linked list implementation of the list iterator
 *    using a header node.
 * @author Mark Allen Weiss
 * @see LinkedList
 */
public class LinkedListItr
{
  /*@ invariant this.current.next.element != null; */
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires theNode.next.element != null;
  @ ensures this.current == \old(theNode);
  @ ensures this.current.element == theNode.element;
  @ ensures this.current.element.getClass().getName() == theNode.element.getClass().getName();
  @ ensures this.current.next == theNode.next;
  @ ensures this.current.next.element == theNode.next.element;
  @ ensures this.current.next.element.getClass().getName() == theNode.next.element.getClass().getName();
  @ ensures this.current.next.next == theNode.next.next;
  @ ensures theNode.element == \old(theNode.element);
  @ ensures theNode.element.getClass().getName() == \old(theNode.element.getClass().getName());
  @ ensures theNode.next == \old(theNode.next);
  @ ensures theNode.next.element == \old(theNode.next.element);
  @ ensures theNode.next.element.getClass().getName() == \old(theNode.next.element.getClass().getName());
  @ ensures theNode.next.next == \old(theNode.next.next);
  @ ensures theNode.next.element != null;
  @*/
  /**
   * Construct the list iterator
   * @param theNode any node in the linked list.
   */
  LinkedListItr( ListNode theNode )
  {
    current = theNode;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.current == \old(this.current);
  @ ensures this.current.element == \old(this.current.element);
  @ ensures this.current.element.getClass().getName() == \old(this.current.element.getClass().getName());
  @ ensures this.current.next == \old(this.current.next);
  @ ensures this.current.next.element == \old(this.current.next.element);
  @ ensures this.current.next.element.getClass().getName() == \old(this.current.next.element.getClass().getName());
  @ ensures this.current.next.next == \old(this.current.next.next);
  @ ensures (this.current != null)  <==>  (\result == false);
  @ ensures (this.current != null)  ==>  (this.current.next.element != null);
  @ ensures (this.current == null)  <==>  (\result == true);
  @*/
  /**
   * Test if the current position is past the end of the list.
   * @return true if the current position is null.
   */
  public boolean isPastEnd( )
  {
    return current == null;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.current == \old(this.current);
  @ ensures this.current.element == \result;
  @ ensures this.current.element == \old(this.current.element);
  @ ensures this.current.element.getClass().getName() == \result.getClass().getName();
  @ ensures this.current.next == \old(this.current.next);
  @ ensures this.current.next.element == \old(this.current.next.element);
  @ ensures this.current.next.element.getClass().getName() == \old(this.current.next.element.getClass().getName());
  @ ensures this.current.next.next == \old(this.current.next.next);
  @ ensures \result.getClass().getName() == \old(this.current.element.getClass().getName());
  @*/
  /**
   * Return the item stored in the current position.
   * @return the stored item or null if the current position
   * is not in the list.
   */
  public Object retrieve( )
  {
    return isPastEnd( ) ? null : current.element;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.current != null;
  @ ensures this.current.element == \old(this.current.next.element);
  @ ensures this.current.element.getClass().getName() == \old(this.current.next.element.getClass().getName());
  @ ensures this.current.element != null;
  @*/
  /**
   * Advance the current position to the next node in the list.
   * If the current position is null, then do nothing.
   */
  public void advance( )
  {
    if( !isPastEnd( ) )
      current = current.next;
  }

  // Made protected for merge-esc.pl
  // ListNode current;    // Current position
  /*@ spec_public */ protected ListNode current;    // Current position
}


package DataStructures;

// Basic node stored in a linked list
// Note that this class is not accessible outside
// of package DataStructures

class ListNode
{
  /*@ invariant this.next.element != null; */
  /*@ invariant this.next.next.element != null; */
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires theElement == null;
  @ ensures this.element == null;
  @ ensures this.next == null;
  @*/
  // Constructors
  ListNode( Object theElement )
  {
    this( theElement, null );
  }
  
  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires n.element != null;
  @ requires n.next.element != null;
  @ ensures this.element == \old(theElement);
  @ ensures this.element.getClass().getName() == \old(theElement.getClass().getName());
  @ ensures this.next == \old(n);
  @ ensures this.next.element == n.element;
  @ ensures this.next.element.getClass().getName() == n.element.getClass().getName();
  @ ensures this.next.next == n.next;
  @ ensures this.next.next.element == n.next.element;
  @ ensures this.next.next.element.getClass().getName() == n.next.element.getClass().getName();
  @ ensures this.next.next.next == n.next.next;
  @ ensures n.element == \old(n.element);
  @ ensures n.element.getClass().getName() == \old(n.element.getClass().getName());
  @ ensures n.next == \old(n.next);
  @ ensures n.next.element == \old(n.next.element);
  @ ensures n.next.element.getClass().getName() == \old(n.next.element.getClass().getName());
  @ ensures n.next.next == \old(n.next.next);
  @ ensures n.element != null;
  @ ensures n.next.element != null;
  @*/
  ListNode( Object theElement, ListNode n )
  {
    element = theElement;
    next    = n;
  }
  
  // Friendly data; accessible by other package routines
  /*@ spec_public */ Object   element;
  /*@ spec_public */ ListNode next;
}

