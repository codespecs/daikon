===========================================================================
..get_char():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(::default1, 0)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
stream_ptr != null
stream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(stream_ptr) == 1
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.eltsLTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1))
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(stream_ptr))
===========================================================================
..get_char():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(stream_ptr) orig(stream_ptr[]) orig(stream_ptr[].fp) orig(stream_ptr[].fp[0]) orig(stream_ptr[].stream_ind) orig(stream_ptr[].stream) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(stream_ptr[])) orig(size(stream_ptr[]))-1 orig(size(stream_ptr[].fp[0])) orig(size(stream_ptr[].fp[0]))-1 ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] stream_ptr[return] stream_ptr[return-1] stream_ptr[return..] stream_ptr[return+1..] stream_ptr[0..return] stream_ptr[0..return-1] stream_ptr[return].fp stream_ptr[return-1].fp stream_ptr[return..].fp stream_ptr[return+1..].fp stream_ptr[0..return].fp stream_ptr[0..return-1].fp stream_ptr[return].fp[0] stream_ptr[return-1].fp[0] stream_ptr[return..].fp[0] stream_ptr[return+1..].fp[0] stream_ptr[0..return].fp[0] stream_ptr[0..return-1].fp[0] stream_ptr[return].stream_ind stream_ptr[return-1].stream_ind stream_ptr[return..].stream_ind stream_ptr[return+1..].stream_ind stream_ptr[0..return].stream_ind stream_ptr[0..return-1].stream_ind orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(stream_ptr[post(return)]) orig(stream_ptr[post(return)-1]) orig(stream_ptr[post(return)..]) orig(stream_ptr[post(return)+1..]) orig(stream_ptr[0..post(return)]) orig(stream_ptr[0..post(return)-1]) orig(stream_ptr[post(return)].fp) orig(stream_ptr[post(return)-1].fp) orig(stream_ptr[post(return)..].fp) orig(stream_ptr[post(return)+1..].fp) orig(stream_ptr[0..post(return)].fp) orig(stream_ptr[0..post(return)-1].fp) orig(stream_ptr[post(return)].fp[0]) orig(stream_ptr[post(return)-1].fp[0]) orig(stream_ptr[post(return)..].fp[0]) orig(stream_ptr[post(return)+1..].fp[0]) orig(stream_ptr[0..post(return)].fp[0]) orig(stream_ptr[0..post(return)-1].fp[0]) orig(stream_ptr[post(return)].stream_ind) orig(stream_ptr[post(return)-1].stream_ind) orig(stream_ptr[post(return)..].stream_ind) orig(stream_ptr[post(return)+1..].stream_ind) orig(stream_ptr[0..post(return)].stream_ind) orig(stream_ptr[0..post(return)-1].stream_ind)
assignable stream_ptr[].fp[0], stream_ptr[].stream_ind, stream_ptr[].stream
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(stream_ptr, \old(stream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(stream_ptr, "fp"), \old(daikon.Quant.collectObject(stream_ptr, "fp")))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(::default1, 0)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
return != 0
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {0, 26, -1, 17, 27, 29} subset of ::next[return+1..]
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {-1, 51, 52, 26, 54, 28} subset of ::check[return+1..]
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::check )
daikon.Quant.eltsLTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1))
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.size(stream_ptr)))
return != daikon.Quant.size(::default1)
return < daikon.Quant.size(::next)-1
return != daikon.Quant.size(stream_ptr)-1
return != \old(daikon.Quant.size(stream_ptr))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.eltsLTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::default1))
daikon.Quant.eltsLT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.size(stream_ptr)-1 == (return / daikon.Quant.size(::next))
daikon.Quant.size(stream_ptr)-1 == (return / daikon.Quant.size(::next)-1)
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(return, daikon.Quant.size(::next)-1))
===========================================================================
..get_token():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(tstream_ptr) == daikon.Quant.size(tstream_ptr)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
tstream_ptr != null
tstream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(tstream_ptr) == 1
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::check )
daikon.Quant.eltsLTE(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(tstream_ptr))
===========================================================================
..get_token():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream return return[] return[].token_id return[].token_string orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(tstream_ptr) orig(tstream_ptr[]) orig(tstream_ptr[].ch_stream) orig(tstream_ptr[].ch_stream[0]) orig(tstream_ptr[].ch_stream->fp) orig(tstream_ptr[].ch_stream->fp[0]) orig(tstream_ptr[].ch_stream->stream_ind) orig(tstream_ptr[].ch_stream->stream) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1 size(return[]) size(return[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(tstream_ptr[])) orig(size(tstream_ptr[]))-1 orig(size(tstream_ptr[].ch_stream[0])) orig(size(tstream_ptr[].ch_stream[0]))-1 orig(size(tstream_ptr[].ch_stream->fp[0])) orig(size(tstream_ptr[].ch_stream->fp[0]))-1
assignable tstream_ptr[].ch_stream->fp[0], tstream_ptr[].ch_stream->stream_ind, tstream_ptr[].ch_stream->stream
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(tstream_ptr, \old(tstream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp")))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.size(return) == \old(daikon.Quant.size(tstream_ptr))
daikon.Quant.size(return) == \old(daikon.Quant.size(tstream_ptr))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
return != null
daikon.Quant.eltsNotEqual(return, null)
daikon.Quant.eltsGteIndex(daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(return) == 1
daikon.Quant.lexGT(::default1, daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.lexGTE(::default1, daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.lexLT(::base, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.lexLTE(::base, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.subsetOf(daikon.Quant.collectObject(return, "token_id"), ::next)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: return[].token_id is a subsequence of ::next[]
daikon.Quant.lexLT(::next, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.lexLTE(::next, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::next )
daikon.Quant.memberOf(daikon.Quant.size(return) , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"))
daikon.Quant.lexLT(::check, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.lexLTE(::check, \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::check )
daikon.Quant.memberOf(daikon.Quant.size(return) , ::check )
daikon.Quant.eltsLTE(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.size(return))
daikon.Quant.eltsGTE(daikon.Quant.collectObject(return, "token_id"), daikon.Quant.size(tstream_ptr)-1)
daikon.Quant.eltsLTE(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.size(return))
===========================================================================
..is_end_of_character_stream():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
stream_ptr != null
stream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(stream_ptr) == 1
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(stream_ptr))
===========================================================================
..is_end_of_character_stream():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(stream_ptr) orig(stream_ptr[]) orig(stream_ptr[].fp) orig(stream_ptr[].fp[0]) orig(stream_ptr[].stream_ind) orig(stream_ptr[].stream) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(stream_ptr[])) orig(size(stream_ptr[]))-1 orig(size(stream_ptr[].fp[0])) orig(size(stream_ptr[].fp[0]))-1 ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] stream_ptr[return] stream_ptr[return-1] stream_ptr[return..] stream_ptr[return+1..] stream_ptr[0..return] stream_ptr[0..return-1] stream_ptr[return].fp stream_ptr[return-1].fp stream_ptr[return..].fp stream_ptr[return+1..].fp stream_ptr[0..return].fp stream_ptr[0..return-1].fp stream_ptr[return].fp[0] stream_ptr[return-1].fp[0] stream_ptr[return..].fp[0] stream_ptr[return+1..].fp[0] stream_ptr[0..return].fp[0] stream_ptr[0..return-1].fp[0] stream_ptr[return].stream_ind stream_ptr[return-1].stream_ind stream_ptr[return..].stream_ind stream_ptr[return+1..].stream_ind stream_ptr[0..return].stream_ind stream_ptr[0..return-1].stream_ind orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(stream_ptr[post(return)]) orig(stream_ptr[post(return)-1]) orig(stream_ptr[post(return)..]) orig(stream_ptr[post(return)+1..]) orig(stream_ptr[0..post(return)]) orig(stream_ptr[0..post(return)-1]) orig(stream_ptr[post(return)].fp) orig(stream_ptr[post(return)-1].fp) orig(stream_ptr[post(return)..].fp) orig(stream_ptr[post(return)+1..].fp) orig(stream_ptr[0..post(return)].fp) orig(stream_ptr[0..post(return)-1].fp) orig(stream_ptr[post(return)].fp[0]) orig(stream_ptr[post(return)-1].fp[0]) orig(stream_ptr[post(return)..].fp[0]) orig(stream_ptr[post(return)+1..].fp[0]) orig(stream_ptr[0..post(return)].fp[0]) orig(stream_ptr[0..post(return)-1].fp[0]) orig(stream_ptr[post(return)].stream_ind) orig(stream_ptr[post(return)-1].stream_ind) orig(stream_ptr[post(return)..].stream_ind) orig(stream_ptr[post(return)+1..].stream_ind) orig(stream_ptr[0..post(return)].stream_ind) orig(stream_ptr[0..post(return)-1].stream_ind)
assignable stream_ptr[].fp[0], stream_ptr[].stream
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(stream_ptr, \old(stream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(stream_ptr, "fp"), \old(daikon.Quant.collectObject(stream_ptr, "fp")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
return == daikon.Quant.getElement_int(::check, return)
return == \old(daikon.Quant.getElement_int(::check, \new(return)))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), \old(daikon.Quant.slice(::check, 0, \new(return)-1)))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
return == 0 || return == 1
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseGT(daikon.Quant.slice(::default1, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), 54)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, return), new long[] { -96, -32 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseGT(daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), -32)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, return) % 2 == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), new long[] { 0, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseLT(daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, return), new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltwiseLT(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(stream_ptr, 0, return-1), 6)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return))
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.memberOf(return , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::next )
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , ::check )
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), return)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.size(stream_ptr)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::next, return))
return < daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
return >= daikon.Quant.size(stream_ptr)-1
return <= \old(daikon.Quant.size(stream_ptr))
return < daikon.Quant.getElement_int(::default1, return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
return > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), return)
return <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(stream_ptr)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.size(stream_ptr)-1 <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, return) )
\old(daikon.Quant.size(stream_ptr)) < daikon.Quant.getElement_int(::default1, return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), \old(daikon.Quant.size(stream_ptr)))
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), \old(daikon.Quant.size(stream_ptr)))
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::next, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, return)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return+1..]
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsLTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: stream_ptr[0..return-1].stream_ind is a subsequence of ::next[return..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: stream_ptr[0..return-1].stream_ind is a subsequence of ::next[return+1..]
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
===========================================================================
..is_eof_token():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] t t[] t[].token_id t[].token_string size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(t[]) size(t[])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
t != null
daikon.Quant.eltsNotEqual(t, null)
daikon.Quant.eltsGteIndex(daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(t) == 1
daikon.Quant.lexGT(::default1, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.lexGTE(::default1, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(t, "token_id"), ::next)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: t[].token_id is a subsequence of ::next[]
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::check )
daikon.Quant.eltsGTE(daikon.Quant.collectObject(t, "token_id"), daikon.Quant.size(t)-1)
===========================================================================
..is_eof_token():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] t t[] t[].token_id t[].token_string return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(t) orig(t[]) orig(t[].token_id) orig(t[].token_string) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(t[]) size(t[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(t[])) orig(size(t[]))-1 ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] t[return] t[return-1] t[return..] t[return+1..] t[0..return] t[0..return-1] t[return].token_id t[return-1].token_id t[return..].token_id t[return+1..].token_id t[0..return].token_id t[0..return-1].token_id orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(t[post(return)]) orig(t[post(return)-1]) orig(t[post(return)..]) orig(t[post(return)+1..]) orig(t[0..post(return)]) orig(t[0..post(return)-1]) orig(t[post(return)].token_id) orig(t[post(return)-1].token_id) orig(t[post(return)..].token_id) orig(t[post(return)+1..].token_id) orig(t[0..post(return)].token_id) orig(t[0..post(return)-1].token_id)
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(t, \old(t))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(t, "token_id"), \old(daikon.Quant.collectObject(t, "token_id")))
return == daikon.Quant.getElement_int(::check, return)
return == \old(daikon.Quant.getElement_int(::check, \new(return)))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(t, 0, return-1))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), \old(daikon.Quant.slice(::check, 0, \new(return)-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), \old(daikon.Quant.slice(t, 0, \new(return)-1)))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.eltsNotEqual(t, null)
daikon.Quant.eltsGteIndex(daikon.Quant.collectObject(t, "token_id"))
return == 0 || return == 1
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseGT(daikon.Quant.slice(::default1, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), 54)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, return), new long[] { -96, -32 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseGT(daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), -32)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, return) % 2 == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), new long[] { 0, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseLT(daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, return), new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltwiseLT(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsNotEqual(daikon.Quant.slice(t, 0, return-1), null)
daikon.Quant.eltsGtIndex(daikon.Quant.slice(t, return, daikon.Quant.size(t)))
daikon.Quant.lexGT(::default1, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.lexGTE(::default1, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return))
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(t, "token_id"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(t, "token_id"), ::next)
daikon.Quant.memberOf(return , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::next )
daikon.Quant.memberOf(\old(daikon.Quant.size(t)) , ::next )
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , ::check )
daikon.Quant.memberOf(\old(daikon.Quant.size(t)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , ::check )
daikon.Quant.eltsGTE(daikon.Quant.collectObject(t, "token_id"), daikon.Quant.size(t)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(t, "token_id"), daikon.Quant.getElement_int(::default1, return))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: t[].token_id is a subsequence of ::next[return..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(t, "token_id"), daikon.Quant.slice(::next, return, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: t[].token_id is a subsequence of ::next[return+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(t, "token_id"), daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)))
return < daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
return >= daikon.Quant.size(t)-1
return <= \old(daikon.Quant.size(t))
return < daikon.Quant.getElement_int(::default1, return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
return > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), return)
return <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.eltsGT(daikon.Quant.slice(t, return, daikon.Quant.size(t)), return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(t)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(t)-1)
daikon.Quant.size(t)-1 <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.size(t)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.size(t)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.size(t)-1)
daikon.Quant.memberOf(daikon.Quant.size(t)-1 , daikon.Quant.slice(::check, 0, return) )
\old(daikon.Quant.size(t)) < daikon.Quant.getElement_int(::default1, return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), \old(daikon.Quant.size(t)))
\old(daikon.Quant.size(t)) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(\old(daikon.Quant.size(t)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(t)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(t)) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), \old(daikon.Quant.size(t)))
daikon.Quant.eltsGT(daikon.Quant.slice(t, return, daikon.Quant.size(t)), \old(daikon.Quant.size(t)))
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::base, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::next, return)
daikon.Quant.eltsLT(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, return)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return+1..]
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsLTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsGT(daikon.Quant.slice(t, return, daikon.Quant.size(t)), daikon.Quant.getElement_int(::next, return))
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: t[return..].token_id is a subsequence of ::next[return..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: t[return..].token_id is a subsequence of ::next[return+1..]
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
===========================================================================
..open_character_stream():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] FILENAME size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
===========================================================================
..open_character_stream():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] FILENAME return return[] return[].fp return[].fp[0] return[].stream_ind return[].stream orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(FILENAME) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(return[]) size(return[])-1 size(return[].fp[0]) size(return[].fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
return != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(return, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(return, "fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(return, "stream_ind"), 5)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(return) == 1
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(return, "stream_ind"), ::next)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: return[].stream_ind is a subsequence of ::next[]
daikon.Quant.memberOf(daikon.Quant.size(return) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::next )
daikon.Quant.subsetOf(daikon.Quant.collectObject(return, "stream_ind"), ::check)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: return[].stream_ind is a subsequence of ::check[]
daikon.Quant.memberOf(daikon.Quant.size(return) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::check )
===========================================================================
..open_token_stream():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] FILENAME size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
===========================================================================
..open_token_stream():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] FILENAME return return[] return[].ch_stream return[].ch_stream[0] return[].ch_stream->fp return[].ch_stream->fp[0] return[].ch_stream->stream_ind return[].ch_stream->stream orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(FILENAME) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(return[]) size(return[])-1 size(return[].ch_stream[0]) size(return[].ch_stream[0])-1 size(return[].ch_stream->fp[0]) size(return[].ch_stream->fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.size(return) == daikon.Quant.size(return)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
return != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(return, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(return, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(return, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(return, "ch_stream.fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(return, "ch_stream.stream_ind"), 5)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(return) == 1
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(return, "ch_stream.stream_ind"), ::next)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: return[].ch_stream->stream_ind is a subsequence of ::next[]
daikon.Quant.memberOf(daikon.Quant.size(return) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::next )
daikon.Quant.subsetOf(daikon.Quant.collectObject(return, "ch_stream.stream_ind"), ::check)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: return[].ch_stream->stream_ind is a subsequence of ::check[]
daikon.Quant.memberOf(daikon.Quant.size(return) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(return)-1 , ::check )
===========================================================================
..print_token():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(token_ptr[]) size(token_ptr[])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
token_ptr != null
daikon.Quant.eltsNotEqual(token_ptr, null)
daikon.Quant.eltsGteIndex(daikon.Quant.collectObject(token_ptr, "token_id"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(token_ptr) == 1
daikon.Quant.lexGT(::default1, daikon.Quant.collectObject(token_ptr, "token_id"))
daikon.Quant.lexGTE(::default1, daikon.Quant.collectObject(token_ptr, "token_id"))
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(token_ptr, "token_id"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(token_ptr, "token_id"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), ::next)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[]
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(token_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(token_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , ::check )
daikon.Quant.eltsGTE(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.size(token_ptr)-1)
===========================================================================
..print_token():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(token_ptr) orig(token_ptr[]) orig(token_ptr[].token_id) orig(token_ptr[].token_string) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(token_ptr[]) size(token_ptr[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(token_ptr[])) orig(size(token_ptr[]))-1 ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] token_ptr[return] token_ptr[return-1] token_ptr[return..] token_ptr[return+1..] token_ptr[0..return] token_ptr[0..return-1] token_ptr[return].token_id token_ptr[return-1].token_id token_ptr[return..].token_id token_ptr[return+1..].token_id token_ptr[0..return].token_id token_ptr[0..return-1].token_id orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(token_ptr[post(return)]) orig(token_ptr[post(return)-1]) orig(token_ptr[post(return)..]) orig(token_ptr[post(return)+1..]) orig(token_ptr[0..post(return)]) orig(token_ptr[0..post(return)-1]) orig(token_ptr[post(return)].token_id) orig(token_ptr[post(return)-1].token_id) orig(token_ptr[post(return)..].token_id) orig(token_ptr[post(return)+1..].token_id) orig(token_ptr[0..post(return)].token_id) orig(token_ptr[0..post(return)-1].token_id)
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(token_ptr, \old(token_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.collectObject(token_ptr, "token_id")))
return == \old(daikon.Quant.size(token_ptr))
return == daikon.Quant.getElement_int(::check, return)
return == \old(daikon.Quant.getElement_int(::check, \new(return)))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.size(token_ptr)-1 == daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(token_ptr)-1 == daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(token_ptr)-1 == \old(daikon.Quant.getElement_int(::next, \new(return)-1))
daikon.Quant.size(token_ptr)-1 == \old(daikon.Quant.getElement_int(::check, \new(return)-1))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), \old(daikon.Quant.slice(::check, 0, \new(return)-1)))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.eltsNotEqual(token_ptr, null)
daikon.Quant.eltsGteIndex(daikon.Quant.collectObject(token_ptr, "token_id"))
return == 1
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
daikon.Quant.eltwiseGT(daikon.Quant.slice(::default1, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), 54)
daikon.Quant.getElement_int(::base, return) == -96
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, return), new long[] { -96, -32 })
daikon.Quant.eltwiseGT(daikon.Quant.slice(::base, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), -32)
daikon.Quant.getElement_int(::next, return) == 2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), new long[] { 0, 2 })
daikon.Quant.eltwiseLT(daikon.Quant.slice(::next, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, return), new long[] { 0, 1 })
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltwiseLT(daikon.Quant.slice(::check, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLTE(::default1, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , ::base )
daikon.Quant.memberOf(return , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsLTE(::check, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , ::check )
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , ::check )
daikon.Quant.eltsEqual(token_ptr, daikon.Quant.getElement_Object(token_ptr, return-1))
daikon.Quant.eltsGTE(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.size(token_ptr)-1)
daikon.Quant.pairwiseLT(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::default1, 0, return-1))
daikon.Quant.pairwiseGT(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::base, 0, return-1))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[return..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, return, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[return+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)))
daikon.Quant.pairwiseGTE(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, 0, return-1))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.getElement_int(token_ptr, return-1))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), return)
return != daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(token_ptr)-1 , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(token_ptr)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.size(token_ptr)-1)
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.size(token_ptr)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.size(token_ptr)-1)
daikon.Quant.size(token_ptr)-1 <= daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return))
(daikon.Quant.getElement_int(token_ptr, return-1) >> daikon.Quant.getElement_int(::default1, return) == 0)
daikon.Quant.eltsLT(daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::base, 0, return-1))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(token_ptr, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(token_ptr, return-1)
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return+1..]
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(token_ptr, return-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
daikon.Quant.eltsLTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(token_ptr, return-1)
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.size(token_ptr)-1 == (daikon.Quant.getElement_int(token_ptr, return-1) / daikon.Quant.getElement_int(::base, return))
===========================================================================
..unget_char():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] ch stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] stream_ptr[ch] stream_ptr[ch-1] stream_ptr[ch..] stream_ptr[ch+1..] stream_ptr[0..ch] stream_ptr[0..ch-1] stream_ptr[ch].fp stream_ptr[ch-1].fp stream_ptr[ch..].fp stream_ptr[ch+1..].fp stream_ptr[0..ch].fp stream_ptr[0..ch-1].fp stream_ptr[ch].fp[0] stream_ptr[ch-1].fp[0] stream_ptr[ch..].fp[0] stream_ptr[ch+1..].fp[0] stream_ptr[0..ch].fp[0] stream_ptr[0..ch-1].fp[0] stream_ptr[ch].stream_ind stream_ptr[ch-1].stream_ind stream_ptr[ch..].stream_ind stream_ptr[ch+1..].stream_ind stream_ptr[0..ch].stream_ind stream_ptr[0..ch-1].stream_ind
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, ch) == daikon.Quant.getElement_int(::default1, ch-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
ch == 10 || ch == 32
stream_ptr != null
stream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(stream_ptr) == 1
daikon.Quant.getElement_int(::default1, ch) == -1 || daikon.Quant.getElement_int(::default1, ch) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, ch) == -99 || daikon.Quant.getElement_int(::base, ch) == -1
daikon.Quant.getElement_int(::base, ch-1) == -1 || daikon.Quant.getElement_int(::base, ch-1) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, ch) == 6 || daikon.Quant.getElement_int(::next, ch) == 16
daikon.Quant.getElement_int(::next, ch-1) == 15 || daikon.Quant.getElement_int(::next, ch-1) == 20
daikon.Quant.getElement_int(::next, ch-1) % 5 == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, ch) == 5 || daikon.Quant.getElement_int(::check, ch) == 15
daikon.Quant.getElement_int(::check, ch-1) == 0 || daikon.Quant.getElement_int(::check, ch-1) == 14
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.memberOf(ch , ::next )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::check )
ch < daikon.Quant.size(::default1)-1
ch < daikon.Quant.size(::next)-1
ch > daikon.Quant.size(stream_ptr)
ch != daikon.Quant.getElement_int(::default1, ch)
ch > daikon.Quant.getElement_int(::base, ch)
ch > daikon.Quant.getElement_int(::base, ch-1)
ch > daikon.Quant.getElement_int(::next, ch)
ch != daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
ch > daikon.Quant.getElement_int(::check, ch)
ch > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch), ch)
daikon.Quant.eltsLTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1))
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(stream_ptr))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::default1, ch))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, ch, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, ch, daikon.Quant.size(::default1)))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, ch+1, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, ch+1, daikon.Quant.size(::default1)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, ch))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, ch-1))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.size(stream_ptr) != daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(stream_ptr) < daikon.Quant.getElement_int(::next, ch)
daikon.Quant.size(stream_ptr) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.size(stream_ptr) < daikon.Quant.getElement_int(::check, ch)
daikon.Quant.size(stream_ptr) != daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , daikon.Quant.slice(::check, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , daikon.Quant.slice(::check, 0, ch-1) )
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(stream_ptr)-1 > daikon.Quant.getElement_int(::base, ch)
daikon.Quant.size(stream_ptr)-1 >= daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.size(stream_ptr)-1 <= daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, ch-1) )
daikon.Quant.getElement_int(::default1, ch) >= daikon.Quant.getElement_int(::base, ch)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::default1, ch) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, ch, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, ch))
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::next, ch) != daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.getElement_int(::next, ch) > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::next, ch) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::next, ch))
daikon.Quant.getElement_int(::next, ch-1) >= daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::next, ch-1) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::next, ch-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch-1), daikon.Quant.getElement_int(::next, ch-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, ch), daikon.Quant.slice(::check, 0, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, ch-1), daikon.Quant.slice(::check, 0, ch-1))
daikon.Quant.getElement_int(::check, ch) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::check, ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch-1), daikon.Quant.getElement_int(::check, ch))
===========================================================================
..unget_char():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] ch stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(ch) orig(stream_ptr) orig(stream_ptr[]) orig(stream_ptr[].fp) orig(stream_ptr[].fp[0]) orig(stream_ptr[].stream_ind) orig(stream_ptr[].stream) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(stream_ptr[])) orig(size(stream_ptr[]))-1 orig(size(stream_ptr[].fp[0])) orig(size(stream_ptr[].fp[0]))-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(ch)] ::default1[orig(ch)-1] ::default1[orig(ch)..] ::default1[orig(ch)+1..] ::default1[0..orig(ch)] ::default1[0..orig(ch)-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(ch)] ::base[orig(ch)-1] ::base[orig(ch)..] ::base[orig(ch)+1..] ::base[0..orig(ch)] ::base[0..orig(ch)-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(ch)] ::next[orig(ch)-1] ::next[orig(ch)..] ::next[orig(ch)+1..] ::next[0..orig(ch)] ::next[0..orig(ch)-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(ch)] ::check[orig(ch)-1] ::check[orig(ch)..] ::check[orig(ch)+1..] ::check[0..orig(ch)] ::check[0..orig(ch)-1] stream_ptr[ch] stream_ptr[ch-1] stream_ptr[ch..] stream_ptr[ch+1..] stream_ptr[0..ch] stream_ptr[0..ch-1] stream_ptr[ch].fp stream_ptr[ch-1].fp stream_ptr[ch..].fp stream_ptr[ch+1..].fp stream_ptr[0..ch].fp stream_ptr[0..ch-1].fp stream_ptr[ch].fp[0] stream_ptr[ch-1].fp[0] stream_ptr[ch..].fp[0] stream_ptr[ch+1..].fp[0] stream_ptr[0..ch].fp[0] stream_ptr[0..ch-1].fp[0] stream_ptr[ch].stream_ind stream_ptr[ch-1].stream_ind stream_ptr[ch..].stream_ind stream_ptr[ch+1..].stream_ind stream_ptr[0..ch].stream_ind stream_ptr[0..ch-1].stream_ind orig(::default1[post(ch)]) orig(::default1[post(ch)-1]) orig(::default1[post(ch)..]) orig(::default1[post(ch)+1..]) orig(::default1[0..post(ch)]) orig(::default1[0..post(ch)-1]) orig(::base[post(ch)]) orig(::base[post(ch)-1]) orig(::base[post(ch)..]) orig(::base[post(ch)+1..]) orig(::base[0..post(ch)]) orig(::base[0..post(ch)-1]) orig(::next[post(ch)]) orig(::next[post(ch)-1]) orig(::next[post(ch)..]) orig(::next[post(ch)+1..]) orig(::next[0..post(ch)]) orig(::next[0..post(ch)-1]) orig(::check[post(ch)]) orig(::check[post(ch)-1]) orig(::check[post(ch)..]) orig(::check[post(ch)+1..]) orig(::check[0..post(ch)]) orig(::check[0..post(ch)-1]) orig(stream_ptr[post(ch)]) orig(stream_ptr[post(ch)-1]) orig(stream_ptr[post(ch)..]) orig(stream_ptr[post(ch)+1..]) orig(stream_ptr[0..post(ch)]) orig(stream_ptr[0..post(ch)-1]) orig(stream_ptr[post(ch)].fp) orig(stream_ptr[post(ch)-1].fp) orig(stream_ptr[post(ch)..].fp) orig(stream_ptr[post(ch)+1..].fp) orig(stream_ptr[0..post(ch)].fp) orig(stream_ptr[0..post(ch)-1].fp) orig(stream_ptr[post(ch)].fp[0]) orig(stream_ptr[post(ch)-1].fp[0]) orig(stream_ptr[post(ch)..].fp[0]) orig(stream_ptr[post(ch)+1..].fp[0]) orig(stream_ptr[0..post(ch)].fp[0]) orig(stream_ptr[0..post(ch)-1].fp[0]) orig(stream_ptr[post(ch)].stream_ind) orig(stream_ptr[post(ch)-1].stream_ind) orig(stream_ptr[post(ch)..].stream_ind) orig(stream_ptr[post(ch)+1..].stream_ind) orig(stream_ptr[0..post(ch)].stream_ind) orig(stream_ptr[0..post(ch)-1].stream_ind) stream_ptr[return] stream_ptr[return-1] stream_ptr[return..] stream_ptr[return+1..] stream_ptr[0..return] stream_ptr[0..return-1] stream_ptr[orig(ch)] stream_ptr[orig(ch)-1] stream_ptr[orig(ch)..] stream_ptr[orig(ch)+1..] stream_ptr[0..orig(ch)] stream_ptr[0..orig(ch)-1] stream_ptr[return].fp stream_ptr[return-1].fp stream_ptr[return..].fp stream_ptr[return+1..].fp stream_ptr[0..return].fp stream_ptr[0..return-1].fp stream_ptr[orig(ch)].fp stream_ptr[orig(ch)-1].fp stream_ptr[orig(ch)..].fp stream_ptr[orig(ch)+1..].fp stream_ptr[0..orig(ch)].fp stream_ptr[0..orig(ch)-1].fp stream_ptr[return].fp[0] stream_ptr[return-1].fp[0] stream_ptr[return..].fp[0] stream_ptr[return+1..].fp[0] stream_ptr[0..return].fp[0] stream_ptr[0..return-1].fp[0] stream_ptr[orig(ch)].fp[0] stream_ptr[orig(ch)-1].fp[0] stream_ptr[orig(ch)..].fp[0] stream_ptr[orig(ch)+1..].fp[0] stream_ptr[0..orig(ch)].fp[0] stream_ptr[0..orig(ch)-1].fp[0] stream_ptr[return].stream_ind stream_ptr[return-1].stream_ind stream_ptr[return..].stream_ind stream_ptr[return+1..].stream_ind stream_ptr[0..return].stream_ind stream_ptr[0..return-1].stream_ind stream_ptr[orig(ch)].stream_ind stream_ptr[orig(ch)-1].stream_ind stream_ptr[orig(ch)..].stream_ind stream_ptr[orig(ch)+1..].stream_ind stream_ptr[0..orig(ch)].stream_ind stream_ptr[0..orig(ch)-1].stream_ind orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(stream_ptr[post(return)]) orig(stream_ptr[post(return)-1]) orig(stream_ptr[post(return)..]) orig(stream_ptr[post(return)+1..]) orig(stream_ptr[0..post(return)]) orig(stream_ptr[0..post(return)-1]) orig(stream_ptr[post(return)].fp) orig(stream_ptr[post(return)-1].fp) orig(stream_ptr[post(return)..].fp) orig(stream_ptr[post(return)+1..].fp) orig(stream_ptr[0..post(return)].fp) orig(stream_ptr[0..post(return)-1].fp) orig(stream_ptr[post(return)].fp[0]) orig(stream_ptr[post(return)-1].fp[0]) orig(stream_ptr[post(return)..].fp[0]) orig(stream_ptr[post(return)+1..].fp[0]) orig(stream_ptr[0..post(return)].fp[0]) orig(stream_ptr[0..post(return)-1].fp[0]) orig(stream_ptr[post(return)].stream_ind) orig(stream_ptr[post(return)-1].stream_ind) orig(stream_ptr[post(return)..].stream_ind) orig(stream_ptr[post(return)+1..].stream_ind) orig(stream_ptr[0..post(return)].stream_ind) orig(stream_ptr[0..post(return)-1].stream_ind) orig(::default1[ch]) orig(::default1[ch-1]) orig(::default1[ch..]) orig(::default1[ch+1..]) orig(::default1[0..ch]) orig(::default1[0..ch-1]) orig(::base[ch]) orig(::base[ch-1]) orig(::base[ch..]) orig(::base[ch+1..]) orig(::base[0..ch]) orig(::base[0..ch-1]) orig(::next[ch]) orig(::next[ch-1]) orig(::next[ch..]) orig(::next[ch+1..]) orig(::next[0..ch]) orig(::next[0..ch-1]) orig(::check[ch]) orig(::check[ch-1]) orig(::check[ch..]) orig(::check[ch+1..]) orig(::check[0..ch]) orig(::check[0..ch-1]) orig(stream_ptr[ch]) orig(stream_ptr[ch-1]) orig(stream_ptr[ch..]) orig(stream_ptr[ch+1..]) orig(stream_ptr[0..ch]) orig(stream_ptr[0..ch-1]) orig(stream_ptr[ch].fp) orig(stream_ptr[ch-1].fp) orig(stream_ptr[ch..].fp) orig(stream_ptr[ch+1..].fp) orig(stream_ptr[0..ch].fp) orig(stream_ptr[0..ch-1].fp) orig(stream_ptr[ch].fp[0]) orig(stream_ptr[ch-1].fp[0]) orig(stream_ptr[ch..].fp[0]) orig(stream_ptr[ch+1..].fp[0]) orig(stream_ptr[0..ch].fp[0]) orig(stream_ptr[0..ch-1].fp[0]) orig(stream_ptr[ch].stream_ind) orig(stream_ptr[ch-1].stream_ind) orig(stream_ptr[ch..].stream_ind) orig(stream_ptr[ch+1..].stream_ind) orig(stream_ptr[0..ch].stream_ind) orig(stream_ptr[0..ch-1].stream_ind)
assignable stream_ptr[].fp[0], stream_ptr[].stream_ind, stream_ptr[].stream
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(stream_ptr, \old(stream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(stream_ptr, "fp"), \old(daikon.Quant.collectObject(stream_ptr, "fp")))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, \old(ch)) == daikon.Quant.getElement_int(::default1, \old(ch)-1)
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, \new(ch)-1))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, ch-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == -1 || daikon.Quant.getElement_int(::default1, return) == 17 || daikon.Quant.getElement_int(::default1, return) == 52
daikon.Quant.getElement_int(::default1, return-1) == -1 || daikon.Quant.getElement_int(::default1, return-1) == 17
daikon.Quant.getElement_int(::default1, \old(ch)) == -1 || daikon.Quant.getElement_int(::default1, \old(ch)) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, \old(ch)) == -99 || daikon.Quant.getElement_int(::base, \old(ch)) == -1
daikon.Quant.getElement_int(::base, \old(ch)-1) == -1 || daikon.Quant.getElement_int(::base, \old(ch)-1) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, \old(ch)) == 6 || daikon.Quant.getElement_int(::next, \old(ch)) == 16
daikon.Quant.getElement_int(::next, \old(ch)-1) == 15 || daikon.Quant.getElement_int(::next, \old(ch)-1) == 20
daikon.Quant.getElement_int(::next, \old(ch)-1) % 5 == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, return) == -1 || daikon.Quant.getElement_int(::check, return) == 0
daikon.Quant.getElement_int(::check, \old(ch)) == 5 || daikon.Quant.getElement_int(::check, \old(ch)) == 15
daikon.Quant.getElement_int(::check, \old(ch)-1) == 0 || daikon.Quant.getElement_int(::check, \old(ch)-1) == 14
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.memberOf(\old(ch) , ::next )
daikon.Quant.lexLT(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::check )
daikon.Quant.memberOf(return , daikon.Quant.collectObject(stream_ptr, "stream_ind") )
daikon.Quant.eltsEqual(daikon.Quant.collectObject(stream_ptr, "stream_ind"), return)
warning: method daikon.inv.binary.twoSequence.PairwiseLinearBinary.format(OutputFormat:JML) needs to be implemented: stream_ptr[].stream_ind - orig(stream_ptr[].stream_ind) + 1 == 0
daikon.Quant.pairwiseLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.size(stream_ptr)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::default1, \old(ch)))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, \old(ch), daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, \old(ch), daikon.Quant.size(::default1)))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, \old(ch)+1, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, \old(ch)+1, daikon.Quant.size(::default1)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::check, return-1))
(\old(ch) >> return == 0)
(return >> \old(ch) == 0)
return != \old(ch)
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), return)
(daikon.Quant.size(::default1) >> return == 0)
(daikon.Quant.size(::default1)-1 >> return == 0)
return <= daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
return > \old(daikon.Quant.size(stream_ptr))
return != daikon.Quant.getElement_int(::default1, return)
return != daikon.Quant.getElement_int(::default1, return-1)
return > daikon.Quant.getElement_int(::default1, \old(ch))
return != daikon.Quant.getElement_int(::base, return)
return != daikon.Quant.getElement_int(::base, return-1)
return > daikon.Quant.getElement_int(::base, \old(ch))
return > daikon.Quant.getElement_int(::base, \old(ch)-1)
return != daikon.Quant.getElement_int(::next, return)
return != daikon.Quant.getElement_int(::next, return-1)
(daikon.Quant.getElement_int(::next, \old(ch)) >> return == 0)
(return >> daikon.Quant.getElement_int(::next, \old(ch)) == 0)
(daikon.Quant.getElement_int(::next, \old(ch)-1) >> return == 0)
(return >> daikon.Quant.getElement_int(::next, \old(ch)-1) == 0)
return != daikon.Quant.getElement_int(::next, \old(ch)-1)
return > daikon.Quant.getElement_int(::check, return)
return > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
(daikon.Quant.getElement_int(::check, \old(ch)) >> return == 0)
return != daikon.Quant.getElement_int(::check, \old(ch))
(daikon.Quant.getElement_int(::check, \old(ch)-1) >> return == 0)
return != daikon.Quant.getElement_int(::check, \old(ch)-1)
\old(ch) < daikon.Quant.size(::default1)-1
\old(ch) < daikon.Quant.size(::next)-1
\old(ch) != daikon.Quant.getElement_int(::default1, return)
\old(ch) > daikon.Quant.getElement_int(::default1, return-1)
\old(ch) != daikon.Quant.getElement_int(::default1, \old(ch))
\old(ch) != daikon.Quant.getElement_int(::base, return)
\old(ch) != daikon.Quant.getElement_int(::base, return-1)
\old(ch) > daikon.Quant.getElement_int(::base, \old(ch))
\old(ch) > daikon.Quant.getElement_int(::base, \old(ch)-1)
\old(ch) != daikon.Quant.getElement_int(::next, return)
\old(ch) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
\old(ch) > daikon.Quant.getElement_int(::next, \old(ch))
\old(ch) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
\old(ch) > daikon.Quant.getElement_int(::check, return)
\old(ch) > daikon.Quant.getElement_int(::check, return-1)
\old(ch) > daikon.Quant.getElement_int(::check, \old(ch))
\old(ch) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), \old(ch))
daikon.Quant.eltsLTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::default1))
daikon.Quant.eltsLT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::default1, \old(ch)))
daikon.Quant.lexGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, \old(ch), daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, \old(ch), daikon.Quant.size(::default1)))
daikon.Quant.lexGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, \old(ch)+1, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, \old(ch)+1, daikon.Quant.size(::default1)))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::check, return-1))
daikon.Quant.size(::default1) != daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::default1) != daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.size(::default1)-1 != daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::default1)-1 != daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(stream_ptr)-1 > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.size(stream_ptr)-1 >= daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(stream_ptr)-1 != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.size(stream_ptr)-1 >= daikon.Quant.getElement_int(::check, return)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, return) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, return-1) )
daikon.Quant.size(stream_ptr)-1 <= daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::check, 0, \old(ch)-1) )
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::default1, return)
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::default1, return-1)
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::default1, \old(ch))
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::base, return)
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::base, return-1)
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::next, return)
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
\old(daikon.Quant.size(stream_ptr)) < daikon.Quant.getElement_int(::next, \old(ch))
\old(daikon.Quant.size(stream_ptr)) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, return) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, return-1) )
\old(daikon.Quant.size(stream_ptr)) < daikon.Quant.getElement_int(::check, \old(ch))
\old(daikon.Quant.size(stream_ptr)) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, \old(ch)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, \old(ch)-1) )
daikon.Quant.getElement_int(::default1, return) % daikon.Quant.getElement_int(::default1, return-1) == 0
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return-1) == (daikon.Quant.getElement_int(::default1, return) | daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::check, return) % daikon.Quant.getElement_int(::default1, return) == 0
daikon.Quant.getElement_int(::default1, return) == (daikon.Quant.getElement_int(::check, return) | daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return-1) >= daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, return-1) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return-1) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, \old(ch)) >= daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::check, return-1) % daikon.Quant.getElement_int(::base, return) == 0
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::check, return-1) | daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::check, return) % daikon.Quant.getElement_int(::base, return-1) == 0
daikon.Quant.getElement_int(::base, return-1) == (daikon.Quant.getElement_int(::check, return) | daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, \old(ch), daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.getElement_int(::base, \old(ch)) <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, \old(ch)) <= daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::base, \old(ch)) <= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, \old(ch)) <= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, 0, return-1) )
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::check, return) % daikon.Quant.getElement_int(::next, return) == 0
daikon.Quant.getElement_int(::next, return) == (daikon.Quant.getElement_int(::check, return) | daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return) >= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return-1) >= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::next, \old(ch)) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.getElement_int(::next, \old(ch)-1) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, \old(ch)-1) >= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.getElement_int(::next, \old(ch)-1) >= daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, \old(ch)-1) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)-1), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, \old(ch)), daikon.Quant.slice(::check, 0, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, \old(ch)-1), daikon.Quant.slice(::check, 0, \old(ch)-1))
(daikon.Quant.getElement_int(::check, return) & daikon.Quant.getElement_int(::check, return-1)) == 0
daikon.Quant.getElement_int(::check, return) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::check, return) <= daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.getElement_int(::check, return-1) <= daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::check, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::check, \old(ch)))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)-1), daikon.Quant.getElement_int(::check, \old(ch)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(return, daikon.Quant.size(::next)-1))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::default1, \old(ch)) / return)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::base, \old(ch)-1) / return)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return) / return)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return-1) / return)
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(return, daikon.Quant.getElement_int(::default1, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(return, daikon.Quant.getElement_int(::default1, return-1)))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> return)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return-1) / \old(ch))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> \old(ch))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return) / daikon.Quant.size(::default1))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> daikon.Quant.size(::default1))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return) / daikon.Quant.size(::default1)-1)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::default1)-1)
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::default1)-1, daikon.Quant.getElement_int(::base, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::default1)-1, daikon.Quant.getElement_int(::next, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::default1)-1, daikon.Quant.getElement_int(::next, return-1)))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> daikon.Quant.size(::default1)-1)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::base, return) / daikon.Quant.size(::next))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return) / daikon.Quant.size(::next))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::next))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::base, return) / daikon.Quant.size(::next)-1)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return) / daikon.Quant.size(::next)-1)
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::next)-1)
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::next)-1, daikon.Quant.getElement_int(::base, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::next)-1, daikon.Quant.getElement_int(::next, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.size(::next)-1, daikon.Quant.getElement_int(::next, return-1)))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return) / daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::check, return) == (java.lang.Math.min(daikon.Quant.size(stream_ptr)-1, daikon.Quant.getElement_int(::next, return)))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return-1) / daikon.Quant.getElement_int(::next, return))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return) / daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return-1) / daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.size(stream_ptr)-1 == (daikon.Quant.getElement_int(::check, return) * daikon.Quant.getElement_int(::check, return-1))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::default1, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::base, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::base, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::next, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::next, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return), daikon.Quant.getElement_int(::check, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return-1), daikon.Quant.getElement_int(::base, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return-1), daikon.Quant.getElement_int(::base, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return-1), daikon.Quant.getElement_int(::next, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, return-1), daikon.Quant.getElement_int(::next, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, \old(ch)), daikon.Quant.getElement_int(::base, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::default1, \old(ch)), daikon.Quant.getElement_int(::base, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return), daikon.Quant.getElement_int(::base, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return), daikon.Quant.getElement_int(::base, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return), daikon.Quant.getElement_int(::next, return)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return), daikon.Quant.getElement_int(::next, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return), daikon.Quant.getElement_int(::check, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return-1), daikon.Quant.getElement_int(::base, \old(ch))))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return-1), daikon.Quant.getElement_int(::next, return-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return-1), daikon.Quant.getElement_int(::next, \old(ch)-1)))
\old(daikon.Quant.size(stream_ptr)) == (org.plumelib.util.MathPlume.gcd(daikon.Quant.getElement_int(::base, return-1), daikon.Quant.getElement_int(::check, \old(ch))))
daikon.Quant.getElement_int(::check, return) == (\old(daikon.Quant.size(stream_ptr)) / daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::default1, return-1) == (daikon.Quant.getElement_int(::default1, return) | daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.getElement_int(::base, \old(ch)-1) == (daikon.Quant.getElement_int(::default1, return-1) % daikon.Quant.getElement_int(::default1, \old(ch)))
daikon.Quant.getElement_int(::base, \old(ch)-1) == (daikon.Quant.getElement_int(::default1, return-1) % daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return) >> daikon.Quant.getElement_int(::check, \old(ch)))
===========================================================================
print_tokens.c.check_delimiter():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] ch size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, ch) == daikon.Quant.getElement_int(::default1, ch-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
ch == 10 || ch == 32
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, ch) == -1 || daikon.Quant.getElement_int(::default1, ch) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, ch) == -99 || daikon.Quant.getElement_int(::base, ch) == -1
daikon.Quant.getElement_int(::base, ch-1) == -1 || daikon.Quant.getElement_int(::base, ch-1) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, ch) == 6 || daikon.Quant.getElement_int(::next, ch) == 16
daikon.Quant.getElement_int(::next, ch-1) == 15 || daikon.Quant.getElement_int(::next, ch-1) == 20
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, ch) == 5 || daikon.Quant.getElement_int(::check, ch) == 15
daikon.Quant.getElement_int(::check, ch-1) == 0 || daikon.Quant.getElement_int(::check, ch-1) == 14
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(ch , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::check )
ch < daikon.Quant.size(::default1)-1
ch < daikon.Quant.size(::next)-1
ch != daikon.Quant.getElement_int(::default1, ch)
ch > daikon.Quant.getElement_int(::base, ch)
ch > daikon.Quant.getElement_int(::base, ch-1)
ch > daikon.Quant.getElement_int(::next, ch)
ch != daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
ch > daikon.Quant.getElement_int(::check, ch)
ch > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch), ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.getElement_int(::default1, ch) >= daikon.Quant.getElement_int(::base, ch)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::default1, ch) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::default1, ch) != daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::base, ch-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, ch, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, ch))
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::base, ch) < daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::next, ch)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::base, ch-1) < daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::next, ch) != daikon.Quant.getElement_int(::next, ch-1)
daikon.Quant.getElement_int(::next, ch) > daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::next, ch) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::next, ch))
daikon.Quant.getElement_int(::next, ch-1) >= daikon.Quant.getElement_int(::check, ch)
daikon.Quant.getElement_int(::next, ch-1) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::next, ch-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch-1), daikon.Quant.getElement_int(::next, ch-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch-1) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, ch), daikon.Quant.slice(::check, 0, ch))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, ch-1), daikon.Quant.slice(::check, 0, ch-1))
daikon.Quant.getElement_int(::check, ch) > daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, ch), daikon.Quant.getElement_int(::check, ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch-1), daikon.Quant.getElement_int(::check, ch))
===========================================================================
print_tokens.c.check_delimiter():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] ch return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(ch) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(ch)] ::default1[orig(ch)-1] ::default1[orig(ch)..] ::default1[orig(ch)+1..] ::default1[0..orig(ch)] ::default1[0..orig(ch)-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(ch)] ::base[orig(ch)-1] ::base[orig(ch)..] ::base[orig(ch)+1..] ::base[0..orig(ch)] ::base[0..orig(ch)-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(ch)] ::next[orig(ch)-1] ::next[orig(ch)..] ::next[orig(ch)+1..] ::next[0..orig(ch)] ::next[0..orig(ch)-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(ch)] ::check[orig(ch)-1] ::check[orig(ch)..] ::check[orig(ch)+1..] ::check[0..orig(ch)] ::check[0..orig(ch)-1] orig(::default1[post(ch)]) orig(::default1[post(ch)-1]) orig(::default1[post(ch)..]) orig(::default1[post(ch)+1..]) orig(::default1[0..post(ch)]) orig(::default1[0..post(ch)-1]) orig(::base[post(ch)]) orig(::base[post(ch)-1]) orig(::base[post(ch)..]) orig(::base[post(ch)+1..]) orig(::base[0..post(ch)]) orig(::base[0..post(ch)-1]) orig(::next[post(ch)]) orig(::next[post(ch)-1]) orig(::next[post(ch)..]) orig(::next[post(ch)+1..]) orig(::next[0..post(ch)]) orig(::next[0..post(ch)-1]) orig(::check[post(ch)]) orig(::check[post(ch)-1]) orig(::check[post(ch)..]) orig(::check[post(ch)+1..]) orig(::check[0..post(ch)]) orig(::check[0..post(ch)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[ch]) orig(::default1[ch-1]) orig(::default1[ch..]) orig(::default1[ch+1..]) orig(::default1[0..ch]) orig(::default1[0..ch-1]) orig(::base[ch]) orig(::base[ch-1]) orig(::base[ch..]) orig(::base[ch+1..]) orig(::base[0..ch]) orig(::base[0..ch-1]) orig(::next[ch]) orig(::next[ch-1]) orig(::next[ch..]) orig(::next[ch+1..]) orig(::next[0..ch]) orig(::next[0..ch-1]) orig(::check[ch]) orig(::check[ch-1]) orig(::check[ch..]) orig(::check[ch+1..]) orig(::check[0..ch]) orig(::check[0..ch-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
return == daikon.Quant.getElement_int(::check, return)
return == \old(daikon.Quant.getElement_int(::check, \new(return)))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, \old(ch)) == daikon.Quant.getElement_int(::default1, \old(ch)-1)
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, \new(ch)-1))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, ch-1))
daikon.Quant.getElement_int(::next, return-1) == daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return-1) == \old(daikon.Quant.getElement_int(::check, \new(return)-1))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(::next, 0, return-1), \old(daikon.Quant.slice(::check, 0, \new(return)-1)))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
return == 1
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
daikon.Quant.eltwiseGT(daikon.Quant.slice(::default1, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), 54)
daikon.Quant.getElement_int(::default1, \old(ch)) == -1 || daikon.Quant.getElement_int(::default1, \old(ch)) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, return) == -96
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, return), new long[] { -96, -32 })
daikon.Quant.eltwiseGT(daikon.Quant.slice(::base, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), -32)
daikon.Quant.getElement_int(::base, \old(ch)) == -99 || daikon.Quant.getElement_int(::base, \old(ch)) == -1
daikon.Quant.getElement_int(::base, \old(ch)-1) == -1 || daikon.Quant.getElement_int(::base, \old(ch)-1) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, return) == 2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), new long[] { 0, 2 })
daikon.Quant.eltwiseLT(daikon.Quant.slice(::next, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), 0)
daikon.Quant.getElement_int(::next, \old(ch)) == 6 || daikon.Quant.getElement_int(::next, \old(ch)) == 16
daikon.Quant.getElement_int(::next, \old(ch)-1) == 15 || daikon.Quant.getElement_int(::next, \old(ch)-1) == 20
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, return), new long[] { 0, 1 })
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltwiseLT(daikon.Quant.slice(::check, 0, return))
daikon.Quant.getElement_int(::check, \old(ch)) == 5 || daikon.Quant.getElement_int(::check, \old(ch)) == 15
daikon.Quant.getElement_int(::check, \old(ch)-1) == 0 || daikon.Quant.getElement_int(::check, \old(ch)-1) == 14
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLTE(::default1, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return-1) , ::base )
daikon.Quant.memberOf(return , ::next )
daikon.Quant.memberOf(\old(ch) , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::next )
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsLTE(::check, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::check )
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , ::check )
return < \old(ch)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
return != daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), return)
return > daikon.Quant.getElement_int(::base, \old(ch))
return > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
return < daikon.Quant.getElement_int(::next, \old(ch))
return < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), return)
return < daikon.Quant.getElement_int(::check, \old(ch))
return != daikon.Quant.getElement_int(::check, \old(ch)-1)
\old(ch) < daikon.Quant.size(::default1)-1
\old(ch) < daikon.Quant.size(::next)-1
\old(ch) != daikon.Quant.getElement_int(::default1, return)
\old(ch) < daikon.Quant.getElement_int(::default1, return-1)
\old(ch) != daikon.Quant.getElement_int(::default1, \old(ch))
\old(ch) > daikon.Quant.getElement_int(::base, return)
\old(ch) > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), \old(ch))
\old(ch) > daikon.Quant.getElement_int(::base, \old(ch))
\old(ch) > daikon.Quant.getElement_int(::base, \old(ch)-1)
\old(ch) > daikon.Quant.getElement_int(::next, return)
\old(ch) > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
\old(ch) > daikon.Quant.getElement_int(::next, \old(ch))
\old(ch) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
\old(ch) > daikon.Quant.getElement_int(::check, \old(ch))
\old(ch) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::default1, \old(ch))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, return-1) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, \old(ch)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::check, \old(ch)))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::check, \old(ch)-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::base, 0, return-1))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[orig(ch)..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..return-1] is a subsequence of ::check[orig(ch)+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.getElement_int(::default1, \old(ch)) > daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::default1, \old(ch)) > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, \old(ch)))
daikon.Quant.getElement_int(::default1, \old(ch)) >= daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::default1, \old(ch)) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) != daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.eltsGT(daikon.Quant.slice(::base, \old(ch)+1, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::base, \old(ch))
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return-1) , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return..]
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return-1) , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return-1] is a subsequence of ::base[return+1..]
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::check, \old(ch)))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::check, \old(ch)-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::base, \old(ch)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, \old(ch), daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.eltsGT(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.eltsGT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::base, \old(ch)))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, \old(ch)-1) <= daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::base, \old(ch)-1))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::base, \old(ch)-1) < daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::next, return) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return) , daikon.Quant.slice(::check, 0, \old(ch)-1) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.getElement_int(::next, return-1) < daikon.Quant.getElement_int(::next, \old(ch))
daikon.Quant.getElement_int(::next, return-1) < daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.getElement_int(::next, return-1) < daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, return-1) <= daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[return+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[0..orig(ch)]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, \old(ch)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..return] is a subsequence of ::check[0..orig(ch)-1]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, \old(ch)-1))
daikon.Quant.getElement_int(::next, \old(ch)) != daikon.Quant.getElement_int(::next, \old(ch)-1)
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::next, \old(ch)))
daikon.Quant.getElement_int(::next, \old(ch)-1) >= daikon.Quant.getElement_int(::check, \old(ch))
daikon.Quant.getElement_int(::next, \old(ch)-1) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)-1), daikon.Quant.getElement_int(::next, \old(ch)-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, \old(ch)), daikon.Quant.slice(::check, 0, \old(ch)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, \old(ch)-1), daikon.Quant.slice(::check, 0, \old(ch)-1))
daikon.Quant.getElement_int(::check, \old(ch)) > daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, \old(ch)), daikon.Quant.getElement_int(::check, \old(ch)))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)-1), daikon.Quant.getElement_int(::check, \old(ch)))
===========================================================================
print_tokens.c.constant():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state token_str token_ind size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::default1, state-1)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::default1, token_ind)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::base, state)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::base, token_ind)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::next, token_ind) == daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.getElement_int(::check, state) == daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.getElement_int(::check, state) == daikon.Quant.getElement_int(::check, token_ind-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
state == 27
token_ind == 19
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, state) == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::default1, token_ind-1) == -2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, token_ind, daikon.Quant.size(::default1)), new long[] { -3, -1, 52 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, state-1) == 133
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, token_ind-1) == 43
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, state) == 30
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, token_ind) == 18
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, state) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , ::base )
daikon.Quant.memberOf(state , ::next )
daikon.Quant.memberOf(token_ind , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , ::check )
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, state) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, state-1) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, token_ind) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, token_ind-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::base, state, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::base, state+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::base, token_ind, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::base, token_ind+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, state) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, state-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, state, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, token_ind) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, token_ind-1) )
===========================================================================
print_tokens.c.constant():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state token_str token_ind return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(state) orig(token_str) orig(token_ind) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(state)] ::default1[orig(state)-1] ::default1[orig(state)..] ::default1[orig(state)+1..] ::default1[0..orig(state)] ::default1[0..orig(state)-1] ::default1[orig(token_ind)] ::default1[orig(token_ind)-1] ::default1[orig(token_ind)..] ::default1[orig(token_ind)+1..] ::default1[0..orig(token_ind)] ::default1[0..orig(token_ind)-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(state)] ::base[orig(state)-1] ::base[orig(state)..] ::base[orig(state)+1..] ::base[0..orig(state)] ::base[0..orig(state)-1] ::base[orig(token_ind)] ::base[orig(token_ind)-1] ::base[orig(token_ind)..] ::base[orig(token_ind)+1..] ::base[0..orig(token_ind)] ::base[0..orig(token_ind)-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(state)] ::next[orig(state)-1] ::next[orig(state)..] ::next[orig(state)+1..] ::next[0..orig(state)] ::next[0..orig(state)-1] ::next[orig(token_ind)] ::next[orig(token_ind)-1] ::next[orig(token_ind)..] ::next[orig(token_ind)+1..] ::next[0..orig(token_ind)] ::next[0..orig(token_ind)-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(state)] ::check[orig(state)-1] ::check[orig(state)..] ::check[orig(state)+1..] ::check[0..orig(state)] ::check[0..orig(state)-1] ::check[orig(token_ind)] ::check[orig(token_ind)-1] ::check[orig(token_ind)..] ::check[orig(token_ind)+1..] ::check[0..orig(token_ind)] ::check[0..orig(token_ind)-1] orig(::default1[post(state)]) orig(::default1[post(state)-1]) orig(::default1[post(state)..]) orig(::default1[post(state)+1..]) orig(::default1[0..post(state)]) orig(::default1[0..post(state)-1]) orig(::base[post(state)]) orig(::base[post(state)-1]) orig(::base[post(state)..]) orig(::base[post(state)+1..]) orig(::base[0..post(state)]) orig(::base[0..post(state)-1]) orig(::next[post(state)]) orig(::next[post(state)-1]) orig(::next[post(state)..]) orig(::next[post(state)+1..]) orig(::next[0..post(state)]) orig(::next[0..post(state)-1]) orig(::check[post(state)]) orig(::check[post(state)-1]) orig(::check[post(state)..]) orig(::check[post(state)+1..]) orig(::check[0..post(state)]) orig(::check[0..post(state)-1]) orig(::default1[post(token_ind)]) orig(::default1[post(token_ind)-1]) orig(::default1[post(token_ind)..]) orig(::default1[post(token_ind)+1..]) orig(::default1[0..post(token_ind)]) orig(::default1[0..post(token_ind)-1]) orig(::base[post(token_ind)]) orig(::base[post(token_ind)-1]) orig(::base[post(token_ind)..]) orig(::base[post(token_ind)+1..]) orig(::base[0..post(token_ind)]) orig(::base[0..post(token_ind)-1]) orig(::next[post(token_ind)]) orig(::next[post(token_ind)-1]) orig(::next[post(token_ind)..]) orig(::next[post(token_ind)+1..]) orig(::next[0..post(token_ind)]) orig(::next[0..post(token_ind)-1]) orig(::check[post(token_ind)]) orig(::check[post(token_ind)-1]) orig(::check[post(token_ind)..]) orig(::check[post(token_ind)+1..]) orig(::check[0..post(token_ind)]) orig(::check[0..post(token_ind)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[state]) orig(::default1[state-1]) orig(::default1[state..]) orig(::default1[state+1..]) orig(::default1[0..state]) orig(::default1[0..state-1]) orig(::default1[token_ind]) orig(::default1[token_ind-1]) orig(::default1[token_ind..]) orig(::default1[token_ind+1..]) orig(::default1[0..token_ind]) orig(::default1[0..token_ind-1]) orig(::base[state]) orig(::base[state-1]) orig(::base[state..]) orig(::base[state+1..]) orig(::base[0..state]) orig(::base[0..state-1]) orig(::base[token_ind]) orig(::base[token_ind-1]) orig(::base[token_ind..]) orig(::base[token_ind+1..]) orig(::base[0..token_ind]) orig(::base[0..token_ind-1]) orig(::next[state]) orig(::next[state-1]) orig(::next[state..]) orig(::next[state+1..]) orig(::next[0..state]) orig(::next[0..state-1]) orig(::next[token_ind]) orig(::next[token_ind-1]) orig(::next[token_ind..]) orig(::next[token_ind+1..]) orig(::next[0..token_ind]) orig(::next[0..token_ind-1]) orig(::check[state]) orig(::check[state-1]) orig(::check[state..]) orig(::check[state+1..]) orig(::check[0..state]) orig(::check[0..state-1]) orig(::check[token_ind]) orig(::check[token_ind-1]) orig(::check[token_ind..]) orig(::check[token_ind+1..]) orig(::check[0..token_ind]) orig(::check[0..token_ind-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
return == \old(state)
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, \old(state)-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, \old(token_ind))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::base, \old(state))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::base, \old(token_ind))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::next, \old(state)-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::check, \old(state)-1)
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(state)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, \new(state)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::next, \new(state)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::check, \new(state)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(token_ind)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, \new(token_ind)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, \new(return)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::next, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::check, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, state-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, token_ind))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, state))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, token_ind))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::check, state-1))
daikon.Quant.getElement_int(::next, \old(token_ind)) == daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.getElement_int(::next, \old(token_ind)) == \old(daikon.Quant.getElement_int(::next, \new(token_ind)-1))
daikon.Quant.getElement_int(::next, \old(token_ind)) == \old(daikon.Quant.getElement_int(::next, token_ind-1))
daikon.Quant.getElement_int(::check, return) == daikon.Quant.getElement_int(::check, \old(token_ind))
daikon.Quant.getElement_int(::check, return) == daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::check, return) == \old(daikon.Quant.getElement_int(::check, \new(token_ind)))
daikon.Quant.getElement_int(::check, return) == \old(daikon.Quant.getElement_int(::check, \new(token_ind)-1))
daikon.Quant.getElement_int(::check, return) == \old(daikon.Quant.getElement_int(::check, token_ind))
daikon.Quant.getElement_int(::check, return) == \old(daikon.Quant.getElement_int(::check, token_ind-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
return == 27
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) == -2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, \old(token_ind), daikon.Quant.size(::default1)), new long[] { -3, -1, 52 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, return-1) == 133
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, \old(token_ind)-1) == 43
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, return) == 30
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, \old(token_ind)) == 18
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, return) == 0
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::base )
daikon.Quant.memberOf(return , ::next )
daikon.Quant.memberOf(\old(token_ind) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , ::check )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, \old(token_ind)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, \old(token_ind)-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::base, \old(token_ind), daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::base, \old(token_ind)+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, \old(token_ind)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, \old(token_ind)-1) )
===========================================================================
print_tokens.c.error_or_eof_case():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string cu_state token_str token_ind ch size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1 size(token_ptr[]) size(token_ptr[])-1 ::default1[cu_state] ::default1[cu_state-1] ::default1[cu_state..] ::default1[cu_state+1..] ::default1[0..cu_state] ::default1[0..cu_state-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::base[cu_state] ::base[cu_state-1] ::base[cu_state..] ::base[cu_state+1..] ::base[0..cu_state] ::base[0..cu_state-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::next[cu_state] ::next[cu_state-1] ::next[cu_state..] ::next[cu_state+1..] ::next[0..cu_state] ::next[0..cu_state-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::check[cu_state] ::check[cu_state-1] ::check[cu_state..] ::check[cu_state+1..] ::check[0..cu_state] ::check[0..cu_state-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] tstream_ptr[cu_state] tstream_ptr[cu_state-1] tstream_ptr[cu_state..] tstream_ptr[cu_state+1..] tstream_ptr[0..cu_state] tstream_ptr[0..cu_state-1] tstream_ptr[token_ind] tstream_ptr[token_ind-1] tstream_ptr[token_ind..] tstream_ptr[token_ind+1..] tstream_ptr[0..token_ind] tstream_ptr[0..token_ind-1] tstream_ptr[ch] tstream_ptr[ch-1] tstream_ptr[ch..] tstream_ptr[ch+1..] tstream_ptr[0..ch] tstream_ptr[0..ch-1] tstream_ptr[cu_state].ch_stream tstream_ptr[cu_state-1].ch_stream tstream_ptr[cu_state..].ch_stream tstream_ptr[cu_state+1..].ch_stream tstream_ptr[0..cu_state].ch_stream tstream_ptr[0..cu_state-1].ch_stream tstream_ptr[token_ind].ch_stream tstream_ptr[token_ind-1].ch_stream tstream_ptr[token_ind..].ch_stream tstream_ptr[token_ind+1..].ch_stream tstream_ptr[0..token_ind].ch_stream tstream_ptr[0..token_ind-1].ch_stream tstream_ptr[ch].ch_stream tstream_ptr[ch-1].ch_stream tstream_ptr[ch..].ch_stream tstream_ptr[ch+1..].ch_stream tstream_ptr[0..ch].ch_stream tstream_ptr[0..ch-1].ch_stream tstream_ptr[cu_state].ch_stream[0] tstream_ptr[cu_state-1].ch_stream[0] tstream_ptr[cu_state..].ch_stream[0] tstream_ptr[cu_state+1..].ch_stream[0] tstream_ptr[0..cu_state].ch_stream[0] tstream_ptr[0..cu_state-1].ch_stream[0] tstream_ptr[token_ind].ch_stream[0] tstream_ptr[token_ind-1].ch_stream[0] tstream_ptr[token_ind..].ch_stream[0] tstream_ptr[token_ind+1..].ch_stream[0] tstream_ptr[0..token_ind].ch_stream[0] tstream_ptr[0..token_ind-1].ch_stream[0] tstream_ptr[ch].ch_stream[0] tstream_ptr[ch-1].ch_stream[0] tstream_ptr[ch..].ch_stream[0] tstream_ptr[ch+1..].ch_stream[0] tstream_ptr[0..ch].ch_stream[0] tstream_ptr[0..ch-1].ch_stream[0] tstream_ptr[cu_state].ch_stream->fp tstream_ptr[cu_state-1].ch_stream->fp tstream_ptr[cu_state..].ch_stream->fp tstream_ptr[cu_state+1..].ch_stream->fp tstream_ptr[0..cu_state].ch_stream->fp tstream_ptr[0..cu_state-1].ch_stream->fp tstream_ptr[token_ind].ch_stream->fp tstream_ptr[token_ind-1].ch_stream->fp tstream_ptr[token_ind..].ch_stream->fp tstream_ptr[token_ind+1..].ch_stream->fp tstream_ptr[0..token_ind].ch_stream->fp tstream_ptr[0..token_ind-1].ch_stream->fp tstream_ptr[ch].ch_stream->fp tstream_ptr[ch-1].ch_stream->fp tstream_ptr[ch..].ch_stream->fp tstream_ptr[ch+1..].ch_stream->fp tstream_ptr[0..ch].ch_stream->fp tstream_ptr[0..ch-1].ch_stream->fp tstream_ptr[cu_state].ch_stream->fp[0] tstream_ptr[cu_state-1].ch_stream->fp[0] tstream_ptr[cu_state..].ch_stream->fp[0] tstream_ptr[cu_state+1..].ch_stream->fp[0] tstream_ptr[0..cu_state].ch_stream->fp[0] tstream_ptr[0..cu_state-1].ch_stream->fp[0] tstream_ptr[token_ind].ch_stream->fp[0] tstream_ptr[token_ind-1].ch_stream->fp[0] tstream_ptr[token_ind..].ch_stream->fp[0] tstream_ptr[token_ind+1..].ch_stream->fp[0] tstream_ptr[0..token_ind].ch_stream->fp[0] tstream_ptr[0..token_ind-1].ch_stream->fp[0] tstream_ptr[ch].ch_stream->fp[0] tstream_ptr[ch-1].ch_stream->fp[0] tstream_ptr[ch..].ch_stream->fp[0] tstream_ptr[ch+1..].ch_stream->fp[0] tstream_ptr[0..ch].ch_stream->fp[0] tstream_ptr[0..ch-1].ch_stream->fp[0] tstream_ptr[cu_state].ch_stream->stream_ind tstream_ptr[cu_state-1].ch_stream->stream_ind tstream_ptr[cu_state..].ch_stream->stream_ind tstream_ptr[cu_state+1..].ch_stream->stream_ind tstream_ptr[0..cu_state].ch_stream->stream_ind tstream_ptr[0..cu_state-1].ch_stream->stream_ind tstream_ptr[token_ind].ch_stream->stream_ind tstream_ptr[token_ind-1].ch_stream->stream_ind tstream_ptr[token_ind..].ch_stream->stream_ind tstream_ptr[token_ind+1..].ch_stream->stream_ind tstream_ptr[0..token_ind].ch_stream->stream_ind tstream_ptr[0..token_ind-1].ch_stream->stream_ind tstream_ptr[ch].ch_stream->stream_ind tstream_ptr[ch-1].ch_stream->stream_ind tstream_ptr[ch..].ch_stream->stream_ind tstream_ptr[ch+1..].ch_stream->stream_ind tstream_ptr[0..ch].ch_stream->stream_ind tstream_ptr[0..ch-1].ch_stream->stream_ind token_ptr[cu_state] token_ptr[cu_state-1] token_ptr[cu_state..] token_ptr[cu_state+1..] token_ptr[0..cu_state] token_ptr[0..cu_state-1] token_ptr[token_ind] token_ptr[token_ind-1] token_ptr[token_ind..] token_ptr[token_ind+1..] token_ptr[0..token_ind] token_ptr[0..token_ind-1] token_ptr[ch] token_ptr[ch-1] token_ptr[ch..] token_ptr[ch+1..] token_ptr[0..ch] token_ptr[0..ch-1] token_ptr[cu_state].token_id token_ptr[cu_state-1].token_id token_ptr[cu_state..].token_id token_ptr[cu_state+1..].token_id token_ptr[0..cu_state].token_id token_ptr[0..cu_state-1].token_id token_ptr[token_ind].token_id token_ptr[token_ind-1].token_id token_ptr[token_ind..].token_id token_ptr[token_ind+1..].token_id token_ptr[0..token_ind].token_id token_ptr[0..token_ind-1].token_id token_ptr[ch].token_id token_ptr[ch-1].token_id token_ptr[ch..].token_id token_ptr[ch+1..].token_id token_ptr[0..ch].token_id token_ptr[0..ch-1].token_id
cu_state == daikon.Quant.size(tstream_ptr)-1
cu_state == daikon.Quant.size(tstream_ptr)-1
cu_state == daikon.Quant.getElement_int(::next, cu_state)
cu_state == daikon.Quant.getElement_int(::next, token_ind-1)
cu_state == daikon.Quant.getElement_int(::check, cu_state)
cu_state == daikon.Quant.getElement_int(::check, token_ind-1)
token_ind == daikon.Quant.size(tstream_ptr)
token_ind == daikon.Quant.size(tstream_ptr)
token_ind == daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, cu_state) == daikon.Quant.getElement_int(::default1, token_ind-1)
daikon.Quant.getElement_int(::base, cu_state) == daikon.Quant.getElement_int(::base, token_ind-1)
daikon.Quant.getElement_Object(tstream_ptr, cu_state) == daikon.Quant.getElement_Object(tstream_ptr, token_ind-1)
daikon.Quant.getElement_Object(tstream_ptr, cu_state) == daikon.Quant.getElement_Object(tstream_ptr, token_ind-1)
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state) == daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state) == daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state) == daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
tstream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), 6)
token_ptr != null
token_ind == 1
ch == -1
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, cu_state), 54)
daikon.Quant.getElement_int(::default1, token_ind) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, cu_state), -32)
daikon.Quant.getElement_int(::base, token_ind) == -96
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, token_ind), new long[] { -96, -32 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, cu_state), 0)
daikon.Quant.getElement_int(::next, token_ind) == 2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind), new long[] { 0, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, token_ind), new long[] { 0, 1 })
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, token_ind))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(ch , ::default1 )
daikon.Quant.memberOf(cu_state , ::base )
daikon.Quant.memberOf(ch , ::base )
daikon.Quant.memberOf(token_ind , ::next )
daikon.Quant.memberOf(ch , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , ::next )
daikon.Quant.memberOf(ch , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, cu_state) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , ::check )
daikon.Quant.eltsEqual(tstream_ptr, daikon.Quant.getElement_Object(tstream_ptr, cu_state))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), daikon.Quant.getElement_Object(tstream_ptr, cu_state))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[token_ind..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[token_ind+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), cu_state))
daikon.Quant.memberOf(cu_state , daikon.Quant.slice(::base, token_ind, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(cu_state , daikon.Quant.slice(::base, token_ind+1, daikon.Quant.size(::base)) )
daikon.Quant.eltsEqual(daikon.Quant.slice(::next, 0, cu_state), cu_state)
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::default1, token_ind, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::default1, token_ind+1, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::base, token_ind, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::base, token_ind+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, cu_state), daikon.Quant.getElement_int(::default1, cu_state))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, cu_state) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, cu_state) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..cu_state] is a subsequence of ::check[token_ind..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, cu_state), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..cu_state] is a subsequence of ::check[token_ind+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, cu_state), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, cu_state), daikon.Quant.getElement_int(::base, cu_state))
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..cu_state] is a subsequence of ::base[token_ind..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..cu_state] is a subsequence of ::base[token_ind+1..]
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..token_ind] is a subsequence of ::check[token_ind..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..token_ind] is a subsequence of ::check[token_ind+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
===========================================================================
print_tokens.c.error_or_eof_case():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string cu_state token_str token_ind ch return return[] return[].token_id return[].token_string orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(tstream_ptr) orig(tstream_ptr[]) orig(tstream_ptr[].ch_stream) orig(tstream_ptr[].ch_stream[0]) orig(tstream_ptr[].ch_stream->fp) orig(tstream_ptr[].ch_stream->fp[0]) orig(tstream_ptr[].ch_stream->stream_ind) orig(tstream_ptr[].ch_stream->stream) orig(token_ptr) orig(token_ptr[]) orig(token_ptr[].token_id) orig(token_ptr[].token_string) orig(cu_state) orig(token_str) orig(token_ind) orig(ch) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1 size(token_ptr[]) size(token_ptr[])-1 size(return[]) size(return[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(tstream_ptr[])) orig(size(tstream_ptr[]))-1 orig(size(tstream_ptr[].ch_stream[0])) orig(size(tstream_ptr[].ch_stream[0]))-1 orig(size(tstream_ptr[].ch_stream->fp[0])) orig(size(tstream_ptr[].ch_stream->fp[0]))-1 orig(size(token_ptr[])) orig(size(token_ptr[]))-1 ::default1[cu_state] ::default1[cu_state-1] ::default1[cu_state..] ::default1[cu_state+1..] ::default1[0..cu_state] ::default1[0..cu_state-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[orig(cu_state)] ::default1[orig(cu_state)-1] ::default1[orig(cu_state)..] ::default1[orig(cu_state)+1..] ::default1[0..orig(cu_state)] ::default1[0..orig(cu_state)-1] ::default1[orig(token_ind)] ::default1[orig(token_ind)-1] ::default1[orig(token_ind)..] ::default1[orig(token_ind)+1..] ::default1[0..orig(token_ind)] ::default1[0..orig(token_ind)-1] ::default1[orig(ch)] ::default1[orig(ch)-1] ::default1[orig(ch)..] ::default1[orig(ch)+1..] ::default1[0..orig(ch)] ::default1[0..orig(ch)-1] ::base[cu_state] ::base[cu_state-1] ::base[cu_state..] ::base[cu_state+1..] ::base[0..cu_state] ::base[0..cu_state-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[orig(cu_state)] ::base[orig(cu_state)-1] ::base[orig(cu_state)..] ::base[orig(cu_state)+1..] ::base[0..orig(cu_state)] ::base[0..orig(cu_state)-1] ::base[orig(token_ind)] ::base[orig(token_ind)-1] ::base[orig(token_ind)..] ::base[orig(token_ind)+1..] ::base[0..orig(token_ind)] ::base[0..orig(token_ind)-1] ::base[orig(ch)] ::base[orig(ch)-1] ::base[orig(ch)..] ::base[orig(ch)+1..] ::base[0..orig(ch)] ::base[0..orig(ch)-1] ::next[cu_state] ::next[cu_state-1] ::next[cu_state..] ::next[cu_state+1..] ::next[0..cu_state] ::next[0..cu_state-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[orig(cu_state)] ::next[orig(cu_state)-1] ::next[orig(cu_state)..] ::next[orig(cu_state)+1..] ::next[0..orig(cu_state)] ::next[0..orig(cu_state)-1] ::next[orig(token_ind)] ::next[orig(token_ind)-1] ::next[orig(token_ind)..] ::next[orig(token_ind)+1..] ::next[0..orig(token_ind)] ::next[0..orig(token_ind)-1] ::next[orig(ch)] ::next[orig(ch)-1] ::next[orig(ch)..] ::next[orig(ch)+1..] ::next[0..orig(ch)] ::next[0..orig(ch)-1] ::check[cu_state] ::check[cu_state-1] ::check[cu_state..] ::check[cu_state+1..] ::check[0..cu_state] ::check[0..cu_state-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[orig(cu_state)] ::check[orig(cu_state)-1] ::check[orig(cu_state)..] ::check[orig(cu_state)+1..] ::check[0..orig(cu_state)] ::check[0..orig(cu_state)-1] ::check[orig(token_ind)] ::check[orig(token_ind)-1] ::check[orig(token_ind)..] ::check[orig(token_ind)+1..] ::check[0..orig(token_ind)] ::check[0..orig(token_ind)-1] ::check[orig(ch)] ::check[orig(ch)-1] ::check[orig(ch)..] ::check[orig(ch)+1..] ::check[0..orig(ch)] ::check[0..orig(ch)-1] tstream_ptr[cu_state] tstream_ptr[cu_state-1] tstream_ptr[cu_state..] tstream_ptr[cu_state+1..] tstream_ptr[0..cu_state] tstream_ptr[0..cu_state-1] tstream_ptr[token_ind] tstream_ptr[token_ind-1] tstream_ptr[token_ind..] tstream_ptr[token_ind+1..] tstream_ptr[0..token_ind] tstream_ptr[0..token_ind-1] tstream_ptr[ch] tstream_ptr[ch-1] tstream_ptr[ch..] tstream_ptr[ch+1..] tstream_ptr[0..ch] tstream_ptr[0..ch-1] tstream_ptr[orig(cu_state)] tstream_ptr[orig(cu_state)-1] tstream_ptr[orig(cu_state)..] tstream_ptr[orig(cu_state)+1..] tstream_ptr[0..orig(cu_state)] tstream_ptr[0..orig(cu_state)-1] tstream_ptr[orig(token_ind)] tstream_ptr[orig(token_ind)-1] tstream_ptr[orig(token_ind)..] tstream_ptr[orig(token_ind)+1..] tstream_ptr[0..orig(token_ind)] tstream_ptr[0..orig(token_ind)-1] tstream_ptr[orig(ch)] tstream_ptr[orig(ch)-1] tstream_ptr[orig(ch)..] tstream_ptr[orig(ch)+1..] tstream_ptr[0..orig(ch)] tstream_ptr[0..orig(ch)-1] tstream_ptr[cu_state].ch_stream tstream_ptr[cu_state-1].ch_stream tstream_ptr[cu_state..].ch_stream tstream_ptr[cu_state+1..].ch_stream tstream_ptr[0..cu_state].ch_stream tstream_ptr[0..cu_state-1].ch_stream tstream_ptr[token_ind].ch_stream tstream_ptr[token_ind-1].ch_stream tstream_ptr[token_ind..].ch_stream tstream_ptr[token_ind+1..].ch_stream tstream_ptr[0..token_ind].ch_stream tstream_ptr[0..token_ind-1].ch_stream tstream_ptr[ch].ch_stream tstream_ptr[ch-1].ch_stream tstream_ptr[ch..].ch_stream tstream_ptr[ch+1..].ch_stream tstream_ptr[0..ch].ch_stream tstream_ptr[0..ch-1].ch_stream tstream_ptr[orig(cu_state)].ch_stream tstream_ptr[orig(cu_state)-1].ch_stream tstream_ptr[orig(cu_state)..].ch_stream tstream_ptr[orig(cu_state)+1..].ch_stream tstream_ptr[0..orig(cu_state)].ch_stream tstream_ptr[0..orig(cu_state)-1].ch_stream tstream_ptr[orig(token_ind)].ch_stream tstream_ptr[orig(token_ind)-1].ch_stream tstream_ptr[orig(token_ind)..].ch_stream tstream_ptr[orig(token_ind)+1..].ch_stream tstream_ptr[0..orig(token_ind)].ch_stream tstream_ptr[0..orig(token_ind)-1].ch_stream tstream_ptr[orig(ch)].ch_stream tstream_ptr[orig(ch)-1].ch_stream tstream_ptr[orig(ch)..].ch_stream tstream_ptr[orig(ch)+1..].ch_stream tstream_ptr[0..orig(ch)].ch_stream tstream_ptr[0..orig(ch)-1].ch_stream tstream_ptr[cu_state].ch_stream[0] tstream_ptr[cu_state-1].ch_stream[0] tstream_ptr[cu_state..].ch_stream[0] tstream_ptr[cu_state+1..].ch_stream[0] tstream_ptr[0..cu_state].ch_stream[0] tstream_ptr[0..cu_state-1].ch_stream[0] tstream_ptr[token_ind].ch_stream[0] tstream_ptr[token_ind-1].ch_stream[0] tstream_ptr[token_ind..].ch_stream[0] tstream_ptr[token_ind+1..].ch_stream[0] tstream_ptr[0..token_ind].ch_stream[0] tstream_ptr[0..token_ind-1].ch_stream[0] tstream_ptr[ch].ch_stream[0] tstream_ptr[ch-1].ch_stream[0] tstream_ptr[ch..].ch_stream[0] tstream_ptr[ch+1..].ch_stream[0] tstream_ptr[0..ch].ch_stream[0] tstream_ptr[0..ch-1].ch_stream[0] tstream_ptr[orig(cu_state)].ch_stream[0] tstream_ptr[orig(cu_state)-1].ch_stream[0] tstream_ptr[orig(cu_state)..].ch_stream[0] tstream_ptr[orig(cu_state)+1..].ch_stream[0] tstream_ptr[0..orig(cu_state)].ch_stream[0] tstream_ptr[0..orig(cu_state)-1].ch_stream[0] tstream_ptr[orig(token_ind)].ch_stream[0] tstream_ptr[orig(token_ind)-1].ch_stream[0] tstream_ptr[orig(token_ind)..].ch_stream[0] tstream_ptr[orig(token_ind)+1..].ch_stream[0] tstream_ptr[0..orig(token_ind)].ch_stream[0] tstream_ptr[0..orig(token_ind)-1].ch_stream[0] tstream_ptr[orig(ch)].ch_stream[0] tstream_ptr[orig(ch)-1].ch_stream[0] tstream_ptr[orig(ch)..].ch_stream[0] tstream_ptr[orig(ch)+1..].ch_stream[0] tstream_ptr[0..orig(ch)].ch_stream[0] tstream_ptr[0..orig(ch)-1].ch_stream[0] tstream_ptr[cu_state].ch_stream->fp tstream_ptr[cu_state-1].ch_stream->fp tstream_ptr[cu_state..].ch_stream->fp tstream_ptr[cu_state+1..].ch_stream->fp tstream_ptr[0..cu_state].ch_stream->fp tstream_ptr[0..cu_state-1].ch_stream->fp tstream_ptr[token_ind].ch_stream->fp tstream_ptr[token_ind-1].ch_stream->fp tstream_ptr[token_ind..].ch_stream->fp tstream_ptr[token_ind+1..].ch_stream->fp tstream_ptr[0..token_ind].ch_stream->fp tstream_ptr[0..token_ind-1].ch_stream->fp tstream_ptr[ch].ch_stream->fp tstream_ptr[ch-1].ch_stream->fp tstream_ptr[ch..].ch_stream->fp tstream_ptr[ch+1..].ch_stream->fp tstream_ptr[0..ch].ch_stream->fp tstream_ptr[0..ch-1].ch_stream->fp tstream_ptr[orig(cu_state)].ch_stream->fp tstream_ptr[orig(cu_state)-1].ch_stream->fp tstream_ptr[orig(cu_state)..].ch_stream->fp tstream_ptr[orig(cu_state)+1..].ch_stream->fp tstream_ptr[0..orig(cu_state)].ch_stream->fp tstream_ptr[0..orig(cu_state)-1].ch_stream->fp tstream_ptr[orig(token_ind)].ch_stream->fp tstream_ptr[orig(token_ind)-1].ch_stream->fp tstream_ptr[orig(token_ind)..].ch_stream->fp tstream_ptr[orig(token_ind)+1..].ch_stream->fp tstream_ptr[0..orig(token_ind)].ch_stream->fp tstream_ptr[0..orig(token_ind)-1].ch_stream->fp tstream_ptr[orig(ch)].ch_stream->fp tstream_ptr[orig(ch)-1].ch_stream->fp tstream_ptr[orig(ch)..].ch_stream->fp tstream_ptr[orig(ch)+1..].ch_stream->fp tstream_ptr[0..orig(ch)].ch_stream->fp tstream_ptr[0..orig(ch)-1].ch_stream->fp tstream_ptr[cu_state].ch_stream->fp[0] tstream_ptr[cu_state-1].ch_stream->fp[0] tstream_ptr[cu_state..].ch_stream->fp[0] tstream_ptr[cu_state+1..].ch_stream->fp[0] tstream_ptr[0..cu_state].ch_stream->fp[0] tstream_ptr[0..cu_state-1].ch_stream->fp[0] tstream_ptr[token_ind].ch_stream->fp[0] tstream_ptr[token_ind-1].ch_stream->fp[0] tstream_ptr[token_ind..].ch_stream->fp[0] tstream_ptr[token_ind+1..].ch_stream->fp[0] tstream_ptr[0..token_ind].ch_stream->fp[0] tstream_ptr[0..token_ind-1].ch_stream->fp[0] tstream_ptr[ch].ch_stream->fp[0] tstream_ptr[ch-1].ch_stream->fp[0] tstream_ptr[ch..].ch_stream->fp[0] tstream_ptr[ch+1..].ch_stream->fp[0] tstream_ptr[0..ch].ch_stream->fp[0] tstream_ptr[0..ch-1].ch_stream->fp[0] tstream_ptr[orig(cu_state)].ch_stream->fp[0] tstream_ptr[orig(cu_state)-1].ch_stream->fp[0] tstream_ptr[orig(cu_state)..].ch_stream->fp[0] tstream_ptr[orig(cu_state)+1..].ch_stream->fp[0] tstream_ptr[0..orig(cu_state)].ch_stream->fp[0] tstream_ptr[0..orig(cu_state)-1].ch_stream->fp[0] tstream_ptr[orig(token_ind)].ch_stream->fp[0] tstream_ptr[orig(token_ind)-1].ch_stream->fp[0] tstream_ptr[orig(token_ind)..].ch_stream->fp[0] tstream_ptr[orig(token_ind)+1..].ch_stream->fp[0] tstream_ptr[0..orig(token_ind)].ch_stream->fp[0] tstream_ptr[0..orig(token_ind)-1].ch_stream->fp[0] tstream_ptr[orig(ch)].ch_stream->fp[0] tstream_ptr[orig(ch)-1].ch_stream->fp[0] tstream_ptr[orig(ch)..].ch_stream->fp[0] tstream_ptr[orig(ch)+1..].ch_stream->fp[0] tstream_ptr[0..orig(ch)].ch_stream->fp[0] tstream_ptr[0..orig(ch)-1].ch_stream->fp[0] tstream_ptr[cu_state].ch_stream->stream_ind tstream_ptr[cu_state-1].ch_stream->stream_ind tstream_ptr[cu_state..].ch_stream->stream_ind tstream_ptr[cu_state+1..].ch_stream->stream_ind tstream_ptr[0..cu_state].ch_stream->stream_ind tstream_ptr[0..cu_state-1].ch_stream->stream_ind tstream_ptr[token_ind].ch_stream->stream_ind tstream_ptr[token_ind-1].ch_stream->stream_ind tstream_ptr[token_ind..].ch_stream->stream_ind tstream_ptr[token_ind+1..].ch_stream->stream_ind tstream_ptr[0..token_ind].ch_stream->stream_ind tstream_ptr[0..token_ind-1].ch_stream->stream_ind tstream_ptr[ch].ch_stream->stream_ind tstream_ptr[ch-1].ch_stream->stream_ind tstream_ptr[ch..].ch_stream->stream_ind tstream_ptr[ch+1..].ch_stream->stream_ind tstream_ptr[0..ch].ch_stream->stream_ind tstream_ptr[0..ch-1].ch_stream->stream_ind tstream_ptr[orig(cu_state)].ch_stream->stream_ind tstream_ptr[orig(cu_state)-1].ch_stream->stream_ind tstream_ptr[orig(cu_state)..].ch_stream->stream_ind tstream_ptr[orig(cu_state)+1..].ch_stream->stream_ind tstream_ptr[0..orig(cu_state)].ch_stream->stream_ind tstream_ptr[0..orig(cu_state)-1].ch_stream->stream_ind tstream_ptr[orig(token_ind)].ch_stream->stream_ind tstream_ptr[orig(token_ind)-1].ch_stream->stream_ind tstream_ptr[orig(token_ind)..].ch_stream->stream_ind tstream_ptr[orig(token_ind)+1..].ch_stream->stream_ind tstream_ptr[0..orig(token_ind)].ch_stream->stream_ind tstream_ptr[0..orig(token_ind)-1].ch_stream->stream_ind tstream_ptr[orig(ch)].ch_stream->stream_ind tstream_ptr[orig(ch)-1].ch_stream->stream_ind tstream_ptr[orig(ch)..].ch_stream->stream_ind tstream_ptr[orig(ch)+1..].ch_stream->stream_ind tstream_ptr[0..orig(ch)].ch_stream->stream_ind tstream_ptr[0..orig(ch)-1].ch_stream->stream_ind token_ptr[cu_state] token_ptr[cu_state-1] token_ptr[cu_state..] token_ptr[cu_state+1..] token_ptr[0..cu_state] token_ptr[0..cu_state-1] token_ptr[token_ind] token_ptr[token_ind-1] token_ptr[token_ind..] token_ptr[token_ind+1..] token_ptr[0..token_ind] token_ptr[0..token_ind-1] token_ptr[ch] token_ptr[ch-1] token_ptr[ch..] token_ptr[ch+1..] token_ptr[0..ch] token_ptr[0..ch-1] token_ptr[orig(cu_state)] token_ptr[orig(cu_state)-1] token_ptr[orig(cu_state)..] token_ptr[orig(cu_state)+1..] token_ptr[0..orig(cu_state)] token_ptr[0..orig(cu_state)-1] token_ptr[orig(token_ind)] token_ptr[orig(token_ind)-1] token_ptr[orig(token_ind)..] token_ptr[orig(token_ind)+1..] token_ptr[0..orig(token_ind)] token_ptr[0..orig(token_ind)-1] token_ptr[orig(ch)] token_ptr[orig(ch)-1] token_ptr[orig(ch)..] token_ptr[orig(ch)+1..] token_ptr[0..orig(ch)] token_ptr[0..orig(ch)-1] token_ptr[cu_state].token_id token_ptr[cu_state-1].token_id token_ptr[cu_state..].token_id token_ptr[cu_state+1..].token_id token_ptr[0..cu_state].token_id token_ptr[0..cu_state-1].token_id token_ptr[token_ind].token_id token_ptr[token_ind-1].token_id token_ptr[token_ind..].token_id token_ptr[token_ind+1..].token_id token_ptr[0..token_ind].token_id token_ptr[0..token_ind-1].token_id token_ptr[ch].token_id token_ptr[ch-1].token_id token_ptr[ch..].token_id token_ptr[ch+1..].token_id token_ptr[0..ch].token_id token_ptr[0..ch-1].token_id token_ptr[orig(cu_state)].token_id token_ptr[orig(cu_state)-1].token_id token_ptr[orig(cu_state)..].token_id token_ptr[orig(cu_state)+1..].token_id token_ptr[0..orig(cu_state)].token_id token_ptr[0..orig(cu_state)-1].token_id token_ptr[orig(token_ind)].token_id token_ptr[orig(token_ind)-1].token_id token_ptr[orig(token_ind)..].token_id token_ptr[orig(token_ind)+1..].token_id token_ptr[0..orig(token_ind)].token_id token_ptr[0..orig(token_ind)-1].token_id token_ptr[orig(ch)].token_id token_ptr[orig(ch)-1].token_id token_ptr[orig(ch)..].token_id token_ptr[orig(ch)+1..].token_id token_ptr[0..orig(ch)].token_id token_ptr[0..orig(ch)-1].token_id return[cu_state] return[cu_state-1] return[cu_state..] return[cu_state+1..] return[0..cu_state] return[0..cu_state-1] return[cu_state].token_id return[cu_state-1].token_id return[cu_state..].token_id return[cu_state+1..].token_id return[0..cu_state].token_id return[0..cu_state-1].token_id orig(::default1[post(cu_state)]) orig(::default1[post(cu_state)-1]) orig(::default1[post(cu_state)..]) orig(::default1[post(cu_state)+1..]) orig(::default1[0..post(cu_state)]) orig(::default1[0..post(cu_state)-1]) orig(::base[post(cu_state)]) orig(::base[post(cu_state)-1]) orig(::base[post(cu_state)..]) orig(::base[post(cu_state)+1..]) orig(::base[0..post(cu_state)]) orig(::base[0..post(cu_state)-1]) orig(::next[post(cu_state)]) orig(::next[post(cu_state)-1]) orig(::next[post(cu_state)..]) orig(::next[post(cu_state)+1..]) orig(::next[0..post(cu_state)]) orig(::next[0..post(cu_state)-1]) orig(::check[post(cu_state)]) orig(::check[post(cu_state)-1]) orig(::check[post(cu_state)..]) orig(::check[post(cu_state)+1..]) orig(::check[0..post(cu_state)]) orig(::check[0..post(cu_state)-1]) orig(tstream_ptr[post(cu_state)]) orig(tstream_ptr[post(cu_state)-1]) orig(tstream_ptr[post(cu_state)..]) orig(tstream_ptr[post(cu_state)+1..]) orig(tstream_ptr[0..post(cu_state)]) orig(tstream_ptr[0..post(cu_state)-1]) orig(tstream_ptr[post(cu_state)].ch_stream) orig(tstream_ptr[post(cu_state)-1].ch_stream) orig(tstream_ptr[post(cu_state)..].ch_stream) orig(tstream_ptr[post(cu_state)+1..].ch_stream) orig(tstream_ptr[0..post(cu_state)].ch_stream) orig(tstream_ptr[0..post(cu_state)-1].ch_stream) orig(tstream_ptr[post(cu_state)].ch_stream[0]) orig(tstream_ptr[post(cu_state)-1].ch_stream[0]) orig(tstream_ptr[post(cu_state)..].ch_stream[0]) orig(tstream_ptr[post(cu_state)+1..].ch_stream[0]) orig(tstream_ptr[0..post(cu_state)].ch_stream[0]) orig(tstream_ptr[0..post(cu_state)-1].ch_stream[0]) orig(tstream_ptr[post(cu_state)].ch_stream->fp) orig(tstream_ptr[post(cu_state)-1].ch_stream->fp) orig(tstream_ptr[post(cu_state)..].ch_stream->fp) orig(tstream_ptr[post(cu_state)+1..].ch_stream->fp) orig(tstream_ptr[0..post(cu_state)].ch_stream->fp) orig(tstream_ptr[0..post(cu_state)-1].ch_stream->fp) orig(tstream_ptr[post(cu_state)].ch_stream->fp[0]) orig(tstream_ptr[post(cu_state)-1].ch_stream->fp[0]) orig(tstream_ptr[post(cu_state)..].ch_stream->fp[0]) orig(tstream_ptr[post(cu_state)+1..].ch_stream->fp[0]) orig(tstream_ptr[0..post(cu_state)].ch_stream->fp[0]) orig(tstream_ptr[0..post(cu_state)-1].ch_stream->fp[0]) orig(tstream_ptr[post(cu_state)].ch_stream->stream_ind) orig(tstream_ptr[post(cu_state)-1].ch_stream->stream_ind) orig(tstream_ptr[post(cu_state)..].ch_stream->stream_ind) orig(tstream_ptr[post(cu_state)+1..].ch_stream->stream_ind) orig(tstream_ptr[0..post(cu_state)].ch_stream->stream_ind) orig(tstream_ptr[0..post(cu_state)-1].ch_stream->stream_ind) orig(token_ptr[post(cu_state)]) orig(token_ptr[post(cu_state)-1]) orig(token_ptr[post(cu_state)..]) orig(token_ptr[post(cu_state)+1..]) orig(token_ptr[0..post(cu_state)]) orig(token_ptr[0..post(cu_state)-1]) orig(token_ptr[post(cu_state)].token_id) orig(token_ptr[post(cu_state)-1].token_id) orig(token_ptr[post(cu_state)..].token_id) orig(token_ptr[post(cu_state)+1..].token_id) orig(token_ptr[0..post(cu_state)].token_id) orig(token_ptr[0..post(cu_state)-1].token_id) return[token_ind] return[token_ind-1] return[token_ind..] return[token_ind+1..] return[0..token_ind] return[0..token_ind-1] return[token_ind].token_id return[token_ind-1].token_id return[token_ind..].token_id return[token_ind+1..].token_id return[0..token_ind].token_id return[0..token_ind-1].token_id orig(::default1[post(token_ind)]) orig(::default1[post(token_ind)-1]) orig(::default1[post(token_ind)..]) orig(::default1[post(token_ind)+1..]) orig(::default1[0..post(token_ind)]) orig(::default1[0..post(token_ind)-1]) orig(::base[post(token_ind)]) orig(::base[post(token_ind)-1]) orig(::base[post(token_ind)..]) orig(::base[post(token_ind)+1..]) orig(::base[0..post(token_ind)]) orig(::base[0..post(token_ind)-1]) orig(::next[post(token_ind)]) orig(::next[post(token_ind)-1]) orig(::next[post(token_ind)..]) orig(::next[post(token_ind)+1..]) orig(::next[0..post(token_ind)]) orig(::next[0..post(token_ind)-1]) orig(::check[post(token_ind)]) orig(::check[post(token_ind)-1]) orig(::check[post(token_ind)..]) orig(::check[post(token_ind)+1..]) orig(::check[0..post(token_ind)]) orig(::check[0..post(token_ind)-1]) orig(tstream_ptr[post(token_ind)]) orig(tstream_ptr[post(token_ind)-1]) orig(tstream_ptr[post(token_ind)..]) orig(tstream_ptr[post(token_ind)+1..]) orig(tstream_ptr[0..post(token_ind)]) orig(tstream_ptr[0..post(token_ind)-1]) orig(tstream_ptr[post(token_ind)].ch_stream) orig(tstream_ptr[post(token_ind)-1].ch_stream) orig(tstream_ptr[post(token_ind)..].ch_stream) orig(tstream_ptr[post(token_ind)+1..].ch_stream) orig(tstream_ptr[0..post(token_ind)].ch_stream) orig(tstream_ptr[0..post(token_ind)-1].ch_stream) orig(tstream_ptr[post(token_ind)].ch_stream[0]) orig(tstream_ptr[post(token_ind)-1].ch_stream[0]) orig(tstream_ptr[post(token_ind)..].ch_stream[0]) orig(tstream_ptr[post(token_ind)+1..].ch_stream[0]) orig(tstream_ptr[0..post(token_ind)].ch_stream[0]) orig(tstream_ptr[0..post(token_ind)-1].ch_stream[0]) orig(tstream_ptr[post(token_ind)].ch_stream->fp) orig(tstream_ptr[post(token_ind)-1].ch_stream->fp) orig(tstream_ptr[post(token_ind)..].ch_stream->fp) orig(tstream_ptr[post(token_ind)+1..].ch_stream->fp) orig(tstream_ptr[0..post(token_ind)].ch_stream->fp) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->fp) orig(tstream_ptr[post(token_ind)].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)-1].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)..].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)+1..].ch_stream->fp[0]) orig(tstream_ptr[0..post(token_ind)].ch_stream->fp[0]) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)-1].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)..].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)+1..].ch_stream->stream_ind) orig(tstream_ptr[0..post(token_ind)].ch_stream->stream_ind) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->stream_ind) orig(token_ptr[post(token_ind)]) orig(token_ptr[post(token_ind)-1]) orig(token_ptr[post(token_ind)..]) orig(token_ptr[post(token_ind)+1..]) orig(token_ptr[0..post(token_ind)]) orig(token_ptr[0..post(token_ind)-1]) orig(token_ptr[post(token_ind)].token_id) orig(token_ptr[post(token_ind)-1].token_id) orig(token_ptr[post(token_ind)..].token_id) orig(token_ptr[post(token_ind)+1..].token_id) orig(token_ptr[0..post(token_ind)].token_id) orig(token_ptr[0..post(token_ind)-1].token_id) return[ch] return[ch-1] return[ch..] return[ch+1..] return[0..ch] return[0..ch-1] return[ch].token_id return[ch-1].token_id return[ch..].token_id return[ch+1..].token_id return[0..ch].token_id return[0..ch-1].token_id orig(::default1[post(ch)]) orig(::default1[post(ch)-1]) orig(::default1[post(ch)..]) orig(::default1[post(ch)+1..]) orig(::default1[0..post(ch)]) orig(::default1[0..post(ch)-1]) orig(::base[post(ch)]) orig(::base[post(ch)-1]) orig(::base[post(ch)..]) orig(::base[post(ch)+1..]) orig(::base[0..post(ch)]) orig(::base[0..post(ch)-1]) orig(::next[post(ch)]) orig(::next[post(ch)-1]) orig(::next[post(ch)..]) orig(::next[post(ch)+1..]) orig(::next[0..post(ch)]) orig(::next[0..post(ch)-1]) orig(::check[post(ch)]) orig(::check[post(ch)-1]) orig(::check[post(ch)..]) orig(::check[post(ch)+1..]) orig(::check[0..post(ch)]) orig(::check[0..post(ch)-1]) orig(tstream_ptr[post(ch)]) orig(tstream_ptr[post(ch)-1]) orig(tstream_ptr[post(ch)..]) orig(tstream_ptr[post(ch)+1..]) orig(tstream_ptr[0..post(ch)]) orig(tstream_ptr[0..post(ch)-1]) orig(tstream_ptr[post(ch)].ch_stream) orig(tstream_ptr[post(ch)-1].ch_stream) orig(tstream_ptr[post(ch)..].ch_stream) orig(tstream_ptr[post(ch)+1..].ch_stream) orig(tstream_ptr[0..post(ch)].ch_stream) orig(tstream_ptr[0..post(ch)-1].ch_stream) orig(tstream_ptr[post(ch)].ch_stream[0]) orig(tstream_ptr[post(ch)-1].ch_stream[0]) orig(tstream_ptr[post(ch)..].ch_stream[0]) orig(tstream_ptr[post(ch)+1..].ch_stream[0]) orig(tstream_ptr[0..post(ch)].ch_stream[0]) orig(tstream_ptr[0..post(ch)-1].ch_stream[0]) orig(tstream_ptr[post(ch)].ch_stream->fp) orig(tstream_ptr[post(ch)-1].ch_stream->fp) orig(tstream_ptr[post(ch)..].ch_stream->fp) orig(tstream_ptr[post(ch)+1..].ch_stream->fp) orig(tstream_ptr[0..post(ch)].ch_stream->fp) orig(tstream_ptr[0..post(ch)-1].ch_stream->fp) orig(tstream_ptr[post(ch)].ch_stream->fp[0]) orig(tstream_ptr[post(ch)-1].ch_stream->fp[0]) orig(tstream_ptr[post(ch)..].ch_stream->fp[0]) orig(tstream_ptr[post(ch)+1..].ch_stream->fp[0]) orig(tstream_ptr[0..post(ch)].ch_stream->fp[0]) orig(tstream_ptr[0..post(ch)-1].ch_stream->fp[0]) orig(tstream_ptr[post(ch)].ch_stream->stream_ind) orig(tstream_ptr[post(ch)-1].ch_stream->stream_ind) orig(tstream_ptr[post(ch)..].ch_stream->stream_ind) orig(tstream_ptr[post(ch)+1..].ch_stream->stream_ind) orig(tstream_ptr[0..post(ch)].ch_stream->stream_ind) orig(tstream_ptr[0..post(ch)-1].ch_stream->stream_ind) orig(token_ptr[post(ch)]) orig(token_ptr[post(ch)-1]) orig(token_ptr[post(ch)..]) orig(token_ptr[post(ch)+1..]) orig(token_ptr[0..post(ch)]) orig(token_ptr[0..post(ch)-1]) orig(token_ptr[post(ch)].token_id) orig(token_ptr[post(ch)-1].token_id) orig(token_ptr[post(ch)..].token_id) orig(token_ptr[post(ch)+1..].token_id) orig(token_ptr[0..post(ch)].token_id) orig(token_ptr[0..post(ch)-1].token_id) return[orig(cu_state)] return[orig(cu_state)-1] return[orig(cu_state)..] return[orig(cu_state)+1..] return[0..orig(cu_state)] return[0..orig(cu_state)-1] return[orig(token_ind)] return[orig(token_ind)-1] return[orig(token_ind)..] return[orig(token_ind)+1..] return[0..orig(token_ind)] return[0..orig(token_ind)-1] return[orig(ch)] return[orig(ch)-1] return[orig(ch)..] return[orig(ch)+1..] return[0..orig(ch)] return[0..orig(ch)-1] return[orig(cu_state)].token_id return[orig(cu_state)-1].token_id return[orig(cu_state)..].token_id return[orig(cu_state)+1..].token_id return[0..orig(cu_state)].token_id return[0..orig(cu_state)-1].token_id return[orig(token_ind)].token_id return[orig(token_ind)-1].token_id return[orig(token_ind)..].token_id return[orig(token_ind)+1..].token_id return[0..orig(token_ind)].token_id return[0..orig(token_ind)-1].token_id return[orig(ch)].token_id return[orig(ch)-1].token_id return[orig(ch)..].token_id return[orig(ch)+1..].token_id return[0..orig(ch)].token_id return[0..orig(ch)-1].token_id orig(::default1[cu_state]) orig(::default1[cu_state-1]) orig(::default1[cu_state..]) orig(::default1[cu_state+1..]) orig(::default1[0..cu_state]) orig(::default1[0..cu_state-1]) orig(::default1[token_ind]) orig(::default1[token_ind-1]) orig(::default1[token_ind..]) orig(::default1[token_ind+1..]) orig(::default1[0..token_ind]) orig(::default1[0..token_ind-1]) orig(::default1[ch]) orig(::default1[ch-1]) orig(::default1[ch..]) orig(::default1[ch+1..]) orig(::default1[0..ch]) orig(::default1[0..ch-1]) orig(::base[cu_state]) orig(::base[cu_state-1]) orig(::base[cu_state..]) orig(::base[cu_state+1..]) orig(::base[0..cu_state]) orig(::base[0..cu_state-1]) orig(::base[token_ind]) orig(::base[token_ind-1]) orig(::base[token_ind..]) orig(::base[token_ind+1..]) orig(::base[0..token_ind]) orig(::base[0..token_ind-1]) orig(::base[ch]) orig(::base[ch-1]) orig(::base[ch..]) orig(::base[ch+1..]) orig(::base[0..ch]) orig(::base[0..ch-1]) orig(::next[cu_state]) orig(::next[cu_state-1]) orig(::next[cu_state..]) orig(::next[cu_state+1..]) orig(::next[0..cu_state]) orig(::next[0..cu_state-1]) orig(::next[token_ind]) orig(::next[token_ind-1]) orig(::next[token_ind..]) orig(::next[token_ind+1..]) orig(::next[0..token_ind]) orig(::next[0..token_ind-1]) orig(::next[ch]) orig(::next[ch-1]) orig(::next[ch..]) orig(::next[ch+1..]) orig(::next[0..ch]) orig(::next[0..ch-1]) orig(::check[cu_state]) orig(::check[cu_state-1]) orig(::check[cu_state..]) orig(::check[cu_state+1..]) orig(::check[0..cu_state]) orig(::check[0..cu_state-1]) orig(::check[token_ind]) orig(::check[token_ind-1]) orig(::check[token_ind..]) orig(::check[token_ind+1..]) orig(::check[0..token_ind]) orig(::check[0..token_ind-1]) orig(::check[ch]) orig(::check[ch-1]) orig(::check[ch..]) orig(::check[ch+1..]) orig(::check[0..ch]) orig(::check[0..ch-1]) orig(tstream_ptr[cu_state]) orig(tstream_ptr[cu_state-1]) orig(tstream_ptr[cu_state..]) orig(tstream_ptr[cu_state+1..]) orig(tstream_ptr[0..cu_state]) orig(tstream_ptr[0..cu_state-1]) orig(tstream_ptr[token_ind]) orig(tstream_ptr[token_ind-1]) orig(tstream_ptr[token_ind..]) orig(tstream_ptr[token_ind+1..]) orig(tstream_ptr[0..token_ind]) orig(tstream_ptr[0..token_ind-1]) orig(tstream_ptr[ch]) orig(tstream_ptr[ch-1]) orig(tstream_ptr[ch..]) orig(tstream_ptr[ch+1..]) orig(tstream_ptr[0..ch]) orig(tstream_ptr[0..ch-1]) orig(tstream_ptr[cu_state].ch_stream) orig(tstream_ptr[cu_state-1].ch_stream) orig(tstream_ptr[cu_state..].ch_stream) orig(tstream_ptr[cu_state+1..].ch_stream) orig(tstream_ptr[0..cu_state].ch_stream) orig(tstream_ptr[0..cu_state-1].ch_stream) orig(tstream_ptr[token_ind].ch_stream) orig(tstream_ptr[token_ind-1].ch_stream) orig(tstream_ptr[token_ind..].ch_stream) orig(tstream_ptr[token_ind+1..].ch_stream) orig(tstream_ptr[0..token_ind].ch_stream) orig(tstream_ptr[0..token_ind-1].ch_stream) orig(tstream_ptr[ch].ch_stream) orig(tstream_ptr[ch-1].ch_stream) orig(tstream_ptr[ch..].ch_stream) orig(tstream_ptr[ch+1..].ch_stream) orig(tstream_ptr[0..ch].ch_stream) orig(tstream_ptr[0..ch-1].ch_stream) orig(tstream_ptr[cu_state].ch_stream[0]) orig(tstream_ptr[cu_state-1].ch_stream[0]) orig(tstream_ptr[cu_state..].ch_stream[0]) orig(tstream_ptr[cu_state+1..].ch_stream[0]) orig(tstream_ptr[0..cu_state].ch_stream[0]) orig(tstream_ptr[0..cu_state-1].ch_stream[0]) orig(tstream_ptr[token_ind].ch_stream[0]) orig(tstream_ptr[token_ind-1].ch_stream[0]) orig(tstream_ptr[token_ind..].ch_stream[0]) orig(tstream_ptr[token_ind+1..].ch_stream[0]) orig(tstream_ptr[0..token_ind].ch_stream[0]) orig(tstream_ptr[0..token_ind-1].ch_stream[0]) orig(tstream_ptr[ch].ch_stream[0]) orig(tstream_ptr[ch-1].ch_stream[0]) orig(tstream_ptr[ch..].ch_stream[0]) orig(tstream_ptr[ch+1..].ch_stream[0]) orig(tstream_ptr[0..ch].ch_stream[0]) orig(tstream_ptr[0..ch-1].ch_stream[0]) orig(tstream_ptr[cu_state].ch_stream->fp) orig(tstream_ptr[cu_state-1].ch_stream->fp) orig(tstream_ptr[cu_state..].ch_stream->fp) orig(tstream_ptr[cu_state+1..].ch_stream->fp) orig(tstream_ptr[0..cu_state].ch_stream->fp) orig(tstream_ptr[0..cu_state-1].ch_stream->fp) orig(tstream_ptr[token_ind].ch_stream->fp) orig(tstream_ptr[token_ind-1].ch_stream->fp) orig(tstream_ptr[token_ind..].ch_stream->fp) orig(tstream_ptr[token_ind+1..].ch_stream->fp) orig(tstream_ptr[0..token_ind].ch_stream->fp) orig(tstream_ptr[0..token_ind-1].ch_stream->fp) orig(tstream_ptr[ch].ch_stream->fp) orig(tstream_ptr[ch-1].ch_stream->fp) orig(tstream_ptr[ch..].ch_stream->fp) orig(tstream_ptr[ch+1..].ch_stream->fp) orig(tstream_ptr[0..ch].ch_stream->fp) orig(tstream_ptr[0..ch-1].ch_stream->fp) orig(tstream_ptr[cu_state].ch_stream->fp[0]) orig(tstream_ptr[cu_state-1].ch_stream->fp[0]) orig(tstream_ptr[cu_state..].ch_stream->fp[0]) orig(tstream_ptr[cu_state+1..].ch_stream->fp[0]) orig(tstream_ptr[0..cu_state].ch_stream->fp[0]) orig(tstream_ptr[0..cu_state-1].ch_stream->fp[0]) orig(tstream_ptr[token_ind].ch_stream->fp[0]) orig(tstream_ptr[token_ind-1].ch_stream->fp[0]) orig(tstream_ptr[token_ind..].ch_stream->fp[0]) orig(tstream_ptr[token_ind+1..].ch_stream->fp[0]) orig(tstream_ptr[0..token_ind].ch_stream->fp[0]) orig(tstream_ptr[0..token_ind-1].ch_stream->fp[0]) orig(tstream_ptr[ch].ch_stream->fp[0]) orig(tstream_ptr[ch-1].ch_stream->fp[0]) orig(tstream_ptr[ch..].ch_stream->fp[0]) orig(tstream_ptr[ch+1..].ch_stream->fp[0]) orig(tstream_ptr[0..ch].ch_stream->fp[0]) orig(tstream_ptr[0..ch-1].ch_stream->fp[0]) orig(tstream_ptr[cu_state].ch_stream->stream_ind) orig(tstream_ptr[cu_state-1].ch_stream->stream_ind) orig(tstream_ptr[cu_state..].ch_stream->stream_ind) orig(tstream_ptr[cu_state+1..].ch_stream->stream_ind) orig(tstream_ptr[0..cu_state].ch_stream->stream_ind) orig(tstream_ptr[0..cu_state-1].ch_stream->stream_ind) orig(tstream_ptr[token_ind].ch_stream->stream_ind) orig(tstream_ptr[token_ind-1].ch_stream->stream_ind) orig(tstream_ptr[token_ind..].ch_stream->stream_ind) orig(tstream_ptr[token_ind+1..].ch_stream->stream_ind) orig(tstream_ptr[0..token_ind].ch_stream->stream_ind) orig(tstream_ptr[0..token_ind-1].ch_stream->stream_ind) orig(tstream_ptr[ch].ch_stream->stream_ind) orig(tstream_ptr[ch-1].ch_stream->stream_ind) orig(tstream_ptr[ch..].ch_stream->stream_ind) orig(tstream_ptr[ch+1..].ch_stream->stream_ind) orig(tstream_ptr[0..ch].ch_stream->stream_ind) orig(tstream_ptr[0..ch-1].ch_stream->stream_ind) orig(token_ptr[cu_state]) orig(token_ptr[cu_state-1]) orig(token_ptr[cu_state..]) orig(token_ptr[cu_state+1..]) orig(token_ptr[0..cu_state]) orig(token_ptr[0..cu_state-1]) orig(token_ptr[token_ind]) orig(token_ptr[token_ind-1]) orig(token_ptr[token_ind..]) orig(token_ptr[token_ind+1..]) orig(token_ptr[0..token_ind]) orig(token_ptr[0..token_ind-1]) orig(token_ptr[ch]) orig(token_ptr[ch-1]) orig(token_ptr[ch..]) orig(token_ptr[ch+1..]) orig(token_ptr[0..ch]) orig(token_ptr[0..ch-1]) orig(token_ptr[cu_state].token_id) orig(token_ptr[cu_state-1].token_id) orig(token_ptr[cu_state..].token_id) orig(token_ptr[cu_state+1..].token_id) orig(token_ptr[0..cu_state].token_id) orig(token_ptr[0..cu_state-1].token_id) orig(token_ptr[token_ind].token_id) orig(token_ptr[token_ind-1].token_id) orig(token_ptr[token_ind..].token_id) orig(token_ptr[token_ind+1..].token_id) orig(token_ptr[0..token_ind].token_id) orig(token_ptr[0..token_ind-1].token_id) orig(token_ptr[ch].token_id) orig(token_ptr[ch-1].token_id) orig(token_ptr[ch..].token_id) orig(token_ptr[ch+1..].token_id) orig(token_ptr[0..ch].token_id) orig(token_ptr[0..ch-1].token_id)
assignable tstream_ptr[].ch_stream->fp[0], tstream_ptr[].ch_stream->stream, token_ptr[*], token_ptr[].token_id, token_ptr[].token_string
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(tstream_ptr, \old(tstream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")))
daikon.Quant.pairwiseEqual(token_ptr, return)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.collectObject(return, "token_id"))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::next, 0, \new(cu_state))))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::check, 0, \new(cu_state))))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::next, 0, \new(token_ind)-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::check, 0, \new(token_ind)-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::next, 0, cu_state)))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::next, 0, token_ind-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::check, 0, cu_state)))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(daikon.Quant.slice(::check, 0, token_ind-1)))
return == \old(token_ptr)
\old(cu_state) == daikon.Quant.size(tstream_ptr)-1
\old(cu_state) == daikon.Quant.size(tstream_ptr)-1
\old(cu_state) == daikon.Quant.size(token_ptr)-1
\old(cu_state) == daikon.Quant.size(return)-1
\old(cu_state) == daikon.Quant.getElement_int(::next, \old(cu_state))
\old(cu_state) == daikon.Quant.getElement_int(::next, \old(token_ind)-1)
\old(cu_state) == daikon.Quant.getElement_int(::check, \old(cu_state))
\old(cu_state) == daikon.Quant.getElement_int(::check, \old(token_ind)-1)
\old(cu_state) == daikon.Quant.getElement_int(token_ptr, \old(cu_state))
\old(cu_state) == daikon.Quant.getElement_int(token_ptr, \old(token_ind)-1)
\old(cu_state) == \old(daikon.Quant.getElement_int(::next, \new(cu_state)))
\old(cu_state) == \old(daikon.Quant.getElement_int(::check, \new(cu_state)))
\old(cu_state) == \old(daikon.Quant.getElement_int(::next, \new(token_ind)-1))
\old(cu_state) == \old(daikon.Quant.getElement_int(::check, \new(token_ind)-1))
\old(cu_state) == daikon.Quant.getElement_int(return, \old(cu_state))
\old(cu_state) == daikon.Quant.getElement_int(return, \old(token_ind)-1)
\old(token_ind) == daikon.Quant.size(return)
\old(token_ind) == daikon.Quant.getElement_int(::check, \old(token_ind))
\old(token_ind) == \old(daikon.Quant.getElement_int(::check, \new(token_ind)))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, \old(cu_state)) == daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
daikon.Quant.getElement_int(::default1, \old(cu_state)) == \old(daikon.Quant.getElement_int(::default1, \new(token_ind)-1))
daikon.Quant.getElement_int(::default1, \old(cu_state)) == \old(daikon.Quant.getElement_int(::default1, token_ind-1))
daikon.Quant.getElement_int(::base, \old(cu_state)) == daikon.Quant.getElement_int(::base, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, \old(cu_state)) == \old(daikon.Quant.getElement_int(::base, \new(token_ind)-1))
daikon.Quant.getElement_int(::base, \old(cu_state)) == \old(daikon.Quant.getElement_int(::base, token_ind-1))
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == daikon.Quant.getElement_Object(tstream_ptr, \old(token_ind)-1)
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == \old(daikon.Quant.getElement_Object(tstream_ptr, \new(token_ind)-1))
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == \old(daikon.Quant.getElement_Object(tstream_ptr, token_ind-1))
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == daikon.Quant.getElement_Object(tstream_ptr, \old(token_ind)-1)
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == \old(daikon.Quant.getElement_Object(tstream_ptr, \new(token_ind)-1))
daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)) == \old(daikon.Quant.getElement_Object(tstream_ptr, token_ind-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(token_ind)-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \new(token_ind)-1)))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1)))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(token_ind)-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \new(token_ind)-1)))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1)))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(token_ind)-1))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \new(token_ind)-1)))
(warning: it is meaningless to compare hashcodes for values obtained through daikon.Quant.collect... methods:daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)) == \old(daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), token_ind-1)))
daikon.Quant.getElement_Object(token_ptr, \old(cu_state)) == daikon.Quant.getElement_Object(token_ptr, \old(token_ind)-1)
daikon.Quant.getElement_Object(token_ptr, \old(cu_state)) == daikon.Quant.getElement_Object(return, \old(token_ind)-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), 6)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(token_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_id"), 0)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_string"), new String[] { "" })
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_string"), "")
return != null
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, \old(cu_state)), 54)
daikon.Quant.getElement_int(::default1, \old(token_ind)) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, \old(cu_state)), -32)
daikon.Quant.getElement_int(::base, \old(token_ind)) == -96
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, \old(token_ind)), new long[] { -96, -32 })
daikon.Quant.getElement_int(::next, \old(token_ind)) == 2
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)), new long[] { 0, 2 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, \old(token_ind)), new long[] { 0, 1 })
daikon.Quant.eltsEqualIndex(daikon.Quant.slice(::check, 0, \old(token_ind)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(\old(ch) , ::default1 )
daikon.Quant.memberOf(\old(ch) , ::base )
daikon.Quant.memberOf(\old(token_ind) , ::next )
daikon.Quant.memberOf(\old(ch) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , ::next )
daikon.Quant.memberOf(\old(ch) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(cu_state)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , ::check )
daikon.Quant.eltsEqual(tstream_ptr, daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), daikon.Quant.getElement_Object(tstream_ptr, \old(cu_state)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), daikon.Quant.getElement_Object(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.getElement_int(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(cu_state)))
daikon.Quant.eltsEqual(token_ptr, daikon.Quant.getElement_Object(token_ptr, \old(cu_state)))
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_id"), \old(cu_state))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::base[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::base, \old(token_ind), daikon.Quant.size(::base)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::base[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::base, \old(token_ind)+1, daikon.Quant.size(::base)))
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::default1, \old(token_ind), daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::default1, \old(token_ind)+1, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::base, \old(token_ind), daikon.Quant.size(::base)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::base, \old(token_ind)+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsEqual(daikon.Quant.slice(::default1, 0, \old(cu_state)), daikon.Quant.getElement_int(::default1, \old(cu_state)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(cu_state)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(cu_state)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..orig(cu_state)] is a subsequence of ::check[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(cu_state)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::default1[0..orig(cu_state)] is a subsequence of ::check[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(cu_state)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.eltsEqual(daikon.Quant.slice(::base, 0, \old(cu_state)), daikon.Quant.getElement_int(::base, \old(cu_state)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..orig(token_ind)] is a subsequence of ::check[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: ::next[0..orig(token_ind)] is a subsequence of ::check[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
===========================================================================
print_tokens.c.get_actual_token():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] token_str token_ind size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, token_ind) == -1 || daikon.Quant.getElement_int(::default1, token_ind) == 17
daikon.Quant.getElement_int(::default1, token_ind-1) == -2 || daikon.Quant.getElement_int(::default1, token_ind-1) == -1 || daikon.Quant.getElement_int(::default1, token_ind-1) == 17
daikon.Quant.getElement_int(::check, token_ind) == -1 || daikon.Quant.getElement_int(::check, token_ind) == 0 || daikon.Quant.getElement_int(::check, token_ind) == 4
daikon.Quant.getElement_int(::check, token_ind-1) == 0 || daikon.Quant.getElement_int(::check, token_ind-1) == 1 || daikon.Quant.getElement_int(::check, token_ind-1) == 3
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, token_ind) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, token_ind-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , ::check )
token_ind < daikon.Quant.size(::default1)-1
token_ind < daikon.Quant.size(::next)-1
token_ind != daikon.Quant.getElement_int(::default1, token_ind)
token_ind != daikon.Quant.getElement_int(::default1, token_ind-1)
token_ind != daikon.Quant.getElement_int(::base, token_ind)
token_ind != daikon.Quant.getElement_int(::base, token_ind-1)
token_ind != daikon.Quant.getElement_int(::next, token_ind)
(daikon.Quant.getElement_int(::next, token_ind-1) >> token_ind == 0)
(token_ind >> daikon.Quant.getElement_int(::next, token_ind-1) == 0)
token_ind > daikon.Quant.getElement_int(::check, token_ind)
token_ind > daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, token_ind), token_ind)
daikon.Quant.size(::default1) != daikon.Quant.getElement_int(::base, token_ind)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, token_ind)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, token_ind-1)
daikon.Quant.size(::default1)-1 != daikon.Quant.getElement_int(::base, token_ind)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, token_ind-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, token_ind)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, token_ind)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, token_ind-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, token_ind)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, token_ind-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, token_ind)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::default1, token_ind-1) % daikon.Quant.getElement_int(::default1, token_ind) == 0
daikon.Quant.getElement_int(::default1, token_ind) == (daikon.Quant.getElement_int(::default1, token_ind-1) | daikon.Quant.getElement_int(::default1, token_ind))
daikon.Quant.getElement_int(::default1, token_ind) >= daikon.Quant.getElement_int(::default1, token_ind-1)
daikon.Quant.getElement_int(::default1, token_ind) != daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, token_ind) != daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, token_ind) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, token_ind-1) != daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.getElement_int(::default1, token_ind-1) != daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::base, token_ind) != daikon.Quant.getElement_int(::next, token_ind)
daikon.Quant.getElement_int(::base, token_ind) != daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.getElement_int(::base, token_ind) != daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.getElement_int(::base, token_ind) != daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::base, token_ind) == (daikon.Quant.getElement_int(::check, token_ind-1) | daikon.Quant.getElement_int(::base, token_ind))
daikon.Quant.getElement_int(::base, token_ind-1) != daikon.Quant.getElement_int(::next, token_ind-1)
daikon.Quant.getElement_int(::base, token_ind-1) != daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::next, token_ind) == (daikon.Quant.getElement_int(::check, token_ind) | daikon.Quant.getElement_int(::next, token_ind))
daikon.Quant.getElement_int(::next, token_ind) >= daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.getElement_int(::next, token_ind) != daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::next, token_ind-1) >= daikon.Quant.getElement_int(::check, token_ind)
(daikon.Quant.getElement_int(::next, token_ind-1) & daikon.Quant.getElement_int(::check, token_ind-1)) == 0
daikon.Quant.getElement_int(::next, token_ind-1) > daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, token_ind), daikon.Quant.getElement_int(::next, token_ind-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, token_ind-1), daikon.Quant.getElement_int(::next, token_ind-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, token_ind) , daikon.Quant.slice(::next, 0, token_ind) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, token_ind), daikon.Quant.slice(::check, 0, token_ind))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, token_ind) , daikon.Quant.slice(::next, 0, token_ind-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, token_ind-1), daikon.Quant.slice(::check, 0, token_ind-1))
(daikon.Quant.getElement_int(::check, token_ind) & daikon.Quant.getElement_int(::check, token_ind-1)) == 0
===========================================================================
print_tokens.c.get_actual_token():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] token_str token_ind return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(token_str) orig(token_ind) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(token_ind)] ::default1[orig(token_ind)-1] ::default1[orig(token_ind)..] ::default1[orig(token_ind)+1..] ::default1[0..orig(token_ind)] ::default1[0..orig(token_ind)-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(token_ind)] ::base[orig(token_ind)-1] ::base[orig(token_ind)..] ::base[orig(token_ind)+1..] ::base[0..orig(token_ind)] ::base[0..orig(token_ind)-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(token_ind)] ::next[orig(token_ind)-1] ::next[orig(token_ind)..] ::next[orig(token_ind)+1..] ::next[0..orig(token_ind)] ::next[0..orig(token_ind)-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(token_ind)] ::check[orig(token_ind)-1] ::check[orig(token_ind)..] ::check[orig(token_ind)+1..] ::check[0..orig(token_ind)] ::check[0..orig(token_ind)-1] orig(::default1[post(token_ind)]) orig(::default1[post(token_ind)-1]) orig(::default1[post(token_ind)..]) orig(::default1[post(token_ind)+1..]) orig(::default1[0..post(token_ind)]) orig(::default1[0..post(token_ind)-1]) orig(::base[post(token_ind)]) orig(::base[post(token_ind)-1]) orig(::base[post(token_ind)..]) orig(::base[post(token_ind)+1..]) orig(::base[0..post(token_ind)]) orig(::base[0..post(token_ind)-1]) orig(::next[post(token_ind)]) orig(::next[post(token_ind)-1]) orig(::next[post(token_ind)..]) orig(::next[post(token_ind)+1..]) orig(::next[0..post(token_ind)]) orig(::next[0..post(token_ind)-1]) orig(::check[post(token_ind)]) orig(::check[post(token_ind)-1]) orig(::check[post(token_ind)..]) orig(::check[post(token_ind)+1..]) orig(::check[0..post(token_ind)]) orig(::check[0..post(token_ind)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[token_ind]) orig(::default1[token_ind-1]) orig(::default1[token_ind..]) orig(::default1[token_ind+1..]) orig(::default1[0..token_ind]) orig(::default1[0..token_ind-1]) orig(::base[token_ind]) orig(::base[token_ind-1]) orig(::base[token_ind..]) orig(::base[token_ind+1..]) orig(::base[0..token_ind]) orig(::base[0..token_ind-1]) orig(::next[token_ind]) orig(::next[token_ind-1]) orig(::next[token_ind..]) orig(::next[token_ind+1..]) orig(::next[0..token_ind]) orig(::next[0..token_ind-1]) orig(::check[token_ind]) orig(::check[token_ind-1]) orig(::check[token_ind..]) orig(::check[token_ind+1..]) orig(::check[0..token_ind]) orig(::check[0..token_ind-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, \old(token_ind))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(token_ind)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, token_ind))
daikon.Quant.getElement_int(::base, return-1) == daikon.Quant.getElement_int(::base, \old(token_ind))
daikon.Quant.getElement_int(::base, return-1) == \old(daikon.Quant.getElement_int(::base, \new(token_ind)))
daikon.Quant.getElement_int(::base, return-1) == \old(daikon.Quant.getElement_int(::base, token_ind))
daikon.Quant.getElement_int(::next, return-1) == daikon.Quant.getElement_int(::next, \old(token_ind))
daikon.Quant.getElement_int(::next, return-1) == \old(daikon.Quant.getElement_int(::next, \new(token_ind)))
daikon.Quant.getElement_int(::next, return-1) == \old(daikon.Quant.getElement_int(::next, token_ind))
daikon.Quant.getElement_int(::check, return-1) == daikon.Quant.getElement_int(::check, \old(token_ind))
daikon.Quant.getElement_int(::check, return-1) == \old(daikon.Quant.getElement_int(::check, \new(token_ind)))
daikon.Quant.getElement_int(::check, return-1) == \old(daikon.Quant.getElement_int(::check, token_ind))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == -1 || daikon.Quant.getElement_int(::default1, return) == 17
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) == -2 || daikon.Quant.getElement_int(::default1, \old(token_ind)-1) == -1 || daikon.Quant.getElement_int(::default1, \old(token_ind)-1) == 17
daikon.Quant.getElement_int(::base, return) == -97 || daikon.Quant.getElement_int(::base, return) == -93 || daikon.Quant.getElement_int(::base, return) == -1
daikon.Quant.getElement_int(::check, return) == 0
daikon.Quant.getElement_int(::check, return-1) == -1 || daikon.Quant.getElement_int(::check, return-1) == 0 || daikon.Quant.getElement_int(::check, return-1) == 4
daikon.Quant.getElement_int(::check, \old(token_ind)-1) == 0 || daikon.Quant.getElement_int(::check, \old(token_ind)-1) == 1 || daikon.Quant.getElement_int(::check, \old(token_ind)-1) == 3
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::base )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(token_ind)-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, return))
(return >> \old(token_ind) == 0)
return - \old(token_ind) - 1 == 0
return < daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
return != daikon.Quant.getElement_int(::default1, return)
return != daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
return > daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::base, return) == (return | daikon.Quant.getElement_int(::base, return))
return != daikon.Quant.getElement_int(::base, return-1)
return != daikon.Quant.getElement_int(::base, \old(token_ind)-1)
(return >> daikon.Quant.getElement_int(::next, return) == 0)
return != daikon.Quant.getElement_int(::next, return)
return != daikon.Quant.getElement_int(::next, return-1)
(daikon.Quant.getElement_int(::next, \old(token_ind)-1) >> return == 0)
(return >> daikon.Quant.getElement_int(::next, \old(token_ind)-1) == 0)
return != daikon.Quant.getElement_int(::next, \old(token_ind)-1)
return > daikon.Quant.getElement_int(::check, return)
return > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
return == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) | return)
return > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
\old(token_ind) < daikon.Quant.size(::default1)-1
\old(token_ind) < daikon.Quant.size(::next)-1
\old(token_ind) != daikon.Quant.getElement_int(::default1, return)
\old(token_ind) != daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
\old(token_ind) > daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::base, return) == (\old(token_ind) | daikon.Quant.getElement_int(::base, return))
\old(token_ind) != daikon.Quant.getElement_int(::base, return-1)
\old(token_ind) != daikon.Quant.getElement_int(::base, \old(token_ind)-1)
(\old(token_ind) >> daikon.Quant.getElement_int(::next, return) == 0)
\old(token_ind) != daikon.Quant.getElement_int(::next, return)
\old(token_ind) != daikon.Quant.getElement_int(::next, return-1)
(daikon.Quant.getElement_int(::next, \old(token_ind)-1) >> \old(token_ind) == 0)
(\old(token_ind) >> daikon.Quant.getElement_int(::next, \old(token_ind)-1) == 0)
\old(token_ind) > daikon.Quant.getElement_int(::check, return)
\old(token_ind) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), \old(token_ind))
\old(token_ind) > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.size(::default1) != daikon.Quant.getElement_int(::base, return-1)
(daikon.Quant.size(::default1) >> daikon.Quant.getElement_int(::next, return) == 0)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::default1)-1 != daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, \old(token_ind)-1)
(daikon.Quant.size(::default1)-1 >> daikon.Quant.getElement_int(::next, return) == 0)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
(daikon.Quant.size(::next) >> daikon.Quant.getElement_int(::next, return) == 0)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, \old(token_ind)-1)
(daikon.Quant.size(::next)-1 >> daikon.Quant.getElement_int(::next, return) == 0)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) % daikon.Quant.getElement_int(::default1, return) == 0
daikon.Quant.getElement_int(::default1, return) == (daikon.Quant.getElement_int(::default1, \old(token_ind)-1) | daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::default1, return) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) != daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::default1, \old(token_ind)-1) != daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return) <= daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::next, \old(token_ind)-1) | daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, return) <= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::check, return-1) | daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) | daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, return-1) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) | daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.getElement_int(::base, \old(token_ind)-1) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, \old(token_ind)-1) != daikon.Quant.getElement_int(::next, \old(token_ind)-1)
daikon.Quant.getElement_int(::base, \old(token_ind)-1) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, \old(token_ind)-1) != daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::next, return) >= daikon.Quant.getElement_int(::next, return-1)
(daikon.Quant.getElement_int(::next, \old(token_ind)-1) >> daikon.Quant.getElement_int(::next, return) == 0)
daikon.Quant.getElement_int(::next, return) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return) > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return-1) == (daikon.Quant.getElement_int(::check, return-1) | daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.getElement_int(::next, return-1) >= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return-1) != daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::next, \old(token_ind)-1) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, \old(token_ind)-1) >= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, \old(token_ind)-1))
(daikon.Quant.getElement_int(::next, \old(token_ind)-1) & daikon.Quant.getElement_int(::check, \old(token_ind)-1)) == 0
daikon.Quant.getElement_int(::next, \old(token_ind)-1) > daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(token_ind)-1), daikon.Quant.getElement_int(::next, \old(token_ind)-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, \old(token_ind)-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , daikon.Quant.slice(::next, 0, \old(token_ind)-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, \old(token_ind)-1), daikon.Quant.slice(::check, 0, \old(token_ind)-1))
daikon.Quant.getElement_int(::check, return) <= daikon.Quant.getElement_int(::check, \old(token_ind)-1)
(daikon.Quant.getElement_int(::check, return-1) & daikon.Quant.getElement_int(::check, \old(token_ind)-1)) == 0
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, return-1) / return)
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, return-1) / \old(token_ind))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::default1)-1)
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::base, \old(token_ind)-1) / daikon.Quant.size(::next))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::next))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::base, \old(token_ind)-1) / daikon.Quant.size(::next)-1)
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return-1) / daikon.Quant.size(::next)-1)
daikon.Quant.getElement_int(::default1, return) == (java.lang.Math.max(daikon.Quant.getElement_int(::default1, \old(token_ind)-1), daikon.Quant.getElement_int(::base, return)))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::default1, return) / daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) / daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::default1, \old(token_ind)-1) / daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) / daikon.Quant.getElement_int(::default1, \old(token_ind)-1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) / daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) / daikon.Quant.getElement_int(::base, \old(token_ind)-1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, return-1) / daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::check, \old(token_ind)-1) / daikon.Quant.getElement_int(::next, return-1))
===========================================================================
print_tokens.c.keyword():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::default1, state-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, state) == 17
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, state), new long[] { 17, 54 })
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, state))
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, state-1))
daikon.Quant.getElement_int(::base, state) == -1
daikon.Quant.getElement_int(::check, state-1) >= 0
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , ::default1 )
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, state-1))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(state , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, state))
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, state-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, state))
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, state-1))
(daikon.Quant.size(::default1) >> state == 0)
(daikon.Quant.size(::default1)-1 >> state == 0)
state < daikon.Quant.size(::default1)-1
state < daikon.Quant.size(::next)-1
(daikon.Quant.getElement_int(::default1, state) >> state == 0)
state < daikon.Quant.getElement_int(::default1, state)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, state), state)
state > daikon.Quant.getElement_int(::base, state)
state > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, state), state)
state != daikon.Quant.getElement_int(::next, state)
(daikon.Quant.getElement_int(::next, state-1) >> state == 0)
(state >> daikon.Quant.getElement_int(::next, state-1) == 0)
state != daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(state , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
state > daikon.Quant.getElement_int(::check, state)
state > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state), state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, state), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.size(::next) % daikon.Quant.getElement_int(::next, state) == 0
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, state)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, state)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, state), daikon.Quant.getElement_int(::default1, state))
daikon.Quant.getElement_int(::default1, state) > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::default1, state))
daikon.Quant.getElement_int(::default1, state) != daikon.Quant.getElement_int(::next, state)
(daikon.Quant.getElement_int(::next, state-1) >> daikon.Quant.getElement_int(::default1, state) == 0)
daikon.Quant.getElement_int(::default1, state) != daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, state) > daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::default1, state) > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, state, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state), daikon.Quant.getElement_int(::default1, state))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::default1, state, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::default1, state+1, daikon.Quant.size(::default1)) )
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, state), daikon.Quant.getElement_int(::base, state))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, state), daikon.Quant.slice(::base, 0, state))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, state), daikon.Quant.getElement_int(::check, state))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, state), daikon.Quant.getElement_int(::check, state-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, state), daikon.Quant.slice(::check, state, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, state), daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, state), daikon.Quant.slice(::check, 0, state))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, state-1), daikon.Quant.slice(::base, 0, state-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, state-1), daikon.Quant.slice(::check, state, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, state-1), daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, state-1), daikon.Quant.slice(::check, 0, state-1))
daikon.Quant.getElement_int(::base, state) > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::base, state))
daikon.Quant.getElement_int(::base, state) <= daikon.Quant.getElement_int(::next, state)
daikon.Quant.getElement_int(::base, state) < daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::base, state) <= daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::base, state) < daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::check, state, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, state) , daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::base, state-1) < daikon.Quant.getElement_int(::next, state)
daikon.Quant.getElement_int(::base, state-1) < daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.getElement_int(::base, state-1) < daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::base, state-1) < daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::next, state))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, state), daikon.Quant.slice(::next, 0, state))
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::check, state))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, state), daikon.Quant.getElement_int(::check, state-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, state), daikon.Quant.slice(::check, 0, state))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, state-1), daikon.Quant.slice(::next, 0, state-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, state-1), daikon.Quant.slice(::check, 0, state-1))
daikon.Quant.getElement_int(::next, state) != daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.getElement_int(::next, state) >= daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::next, state) != daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::next, state-1) >= daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::next, state-1) > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, state), daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state-1), daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, state), daikon.Quant.slice(::check, 0, state))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, state-1), daikon.Quant.slice(::check, 0, state-1))
daikon.Quant.getElement_int(::base, state) == (daikon.Quant.getElement_int(::base, state-1) / daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::base, state) == (daikon.Quant.getElement_int(::base, state-1) >> daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::base, state) == (daikon.Quant.getElement_int(::base, state-1) / daikon.Quant.size(::default1)-1)
daikon.Quant.getElement_int(::base, state) == (daikon.Quant.getElement_int(::base, state-1) >> daikon.Quant.size(::default1)-1)
daikon.Quant.getElement_int(::base, state) == (daikon.Quant.getElement_int(::base, state-1) >> daikon.Quant.getElement_int(::default1, state))
===========================================================================
print_tokens.c.keyword():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(state) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(state)] ::default1[orig(state)-1] ::default1[orig(state)..] ::default1[orig(state)+1..] ::default1[0..orig(state)] ::default1[0..orig(state)-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(state)] ::base[orig(state)-1] ::base[orig(state)..] ::base[orig(state)+1..] ::base[0..orig(state)] ::base[0..orig(state)-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(state)] ::next[orig(state)-1] ::next[orig(state)..] ::next[orig(state)+1..] ::next[0..orig(state)] ::next[0..orig(state)-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(state)] ::check[orig(state)-1] ::check[orig(state)..] ::check[orig(state)+1..] ::check[0..orig(state)] ::check[0..orig(state)-1] orig(::default1[post(state)]) orig(::default1[post(state)-1]) orig(::default1[post(state)..]) orig(::default1[post(state)+1..]) orig(::default1[0..post(state)]) orig(::default1[0..post(state)-1]) orig(::base[post(state)]) orig(::base[post(state)-1]) orig(::base[post(state)..]) orig(::base[post(state)+1..]) orig(::base[0..post(state)]) orig(::base[0..post(state)-1]) orig(::next[post(state)]) orig(::next[post(state)-1]) orig(::next[post(state)..]) orig(::next[post(state)+1..]) orig(::next[0..post(state)]) orig(::next[0..post(state)-1]) orig(::check[post(state)]) orig(::check[post(state)-1]) orig(::check[post(state)..]) orig(::check[post(state)+1..]) orig(::check[0..post(state)]) orig(::check[0..post(state)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[state]) orig(::default1[state-1]) orig(::default1[state..]) orig(::default1[state+1..]) orig(::default1[0..state]) orig(::default1[0..state-1]) orig(::base[state]) orig(::base[state-1]) orig(::base[state..]) orig(::base[state+1..]) orig(::base[0..state]) orig(::base[0..state-1]) orig(::next[state]) orig(::next[state-1]) orig(::next[state..]) orig(::next[state+1..]) orig(::next[0..state]) orig(::next[0..state-1]) orig(::check[state]) orig(::check[state-1]) orig(::check[state..]) orig(::check[state+1..]) orig(::check[0..state]) orig(::check[0..state-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
return == \old(state)
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, \old(state)-1)
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(state)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, state-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == 17
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, return))
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, return-1))
daikon.Quant.getElement_int(::base, return) == -1
daikon.Quant.getElement_int(::check, return-1) >= 0
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , ::default1 )
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(return , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return-1))
(daikon.Quant.size(::default1) >> return == 0)
(daikon.Quant.size(::default1)-1 >> return == 0)
return < daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
(daikon.Quant.getElement_int(::default1, return) >> return == 0)
return < daikon.Quant.getElement_int(::default1, return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
return > daikon.Quant.getElement_int(::base, return)
return > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), return)
return != daikon.Quant.getElement_int(::next, return)
(daikon.Quant.getElement_int(::next, return-1) >> return == 0)
(return >> daikon.Quant.getElement_int(::next, return-1) == 0)
return != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
return > daikon.Quant.getElement_int(::check, return)
return > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::next) % daikon.Quant.getElement_int(::next, return) == 0
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, return)
(daikon.Quant.getElement_int(::next, return-1) >> daikon.Quant.getElement_int(::default1, return) == 0)
daikon.Quant.getElement_int(::default1, return) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::default1, return) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)) )
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::check, return-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::base, 0, return-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::base, return) > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return))
daikon.Quant.getElement_int(::base, return) <= daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.getElement_int(::base, return) <= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, return) < daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::base, return-1) < daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::check, return-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
daikon.Quant.pairwiseLTE(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::next, return) >= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return-1) >= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return-1) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return-1), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::base, return-1) / daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::base, return-1) >> daikon.Quant.size(::default1))
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::base, return-1) / daikon.Quant.size(::default1)-1)
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::base, return-1) >> daikon.Quant.size(::default1)-1)
daikon.Quant.getElement_int(::base, return) == (daikon.Quant.getElement_int(::base, return-1) >> daikon.Quant.getElement_int(::default1, return))
===========================================================================
print_tokens.c.next_state():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state ch size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(::default1, 0)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
ch != 0
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {0, 26, -1, 17, 27, 29} subset of ::next[ch+1..]
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {-1, 51, 52, 26, 54, 28} subset of ::check[ch+1..]
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
state < daikon.Quant.size(::default1)-1
state < daikon.Quant.size(::next)-1
ch != daikon.Quant.size(::default1)
ch < daikon.Quant.size(::next)-1
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, ch), ch)
===========================================================================
print_tokens.c.next_state():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state ch return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(state) orig(ch) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(state)] ::default1[orig(state)-1] ::default1[orig(state)..] ::default1[orig(state)+1..] ::default1[0..orig(state)] ::default1[0..orig(state)-1] ::default1[orig(ch)] ::default1[orig(ch)-1] ::default1[orig(ch)..] ::default1[orig(ch)+1..] ::default1[0..orig(ch)] ::default1[0..orig(ch)-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(state)] ::base[orig(state)-1] ::base[orig(state)..] ::base[orig(state)+1..] ::base[0..orig(state)] ::base[0..orig(state)-1] ::base[orig(ch)] ::base[orig(ch)-1] ::base[orig(ch)..] ::base[orig(ch)+1..] ::base[0..orig(ch)] ::base[0..orig(ch)-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(state)] ::next[orig(state)-1] ::next[orig(state)..] ::next[orig(state)+1..] ::next[0..orig(state)] ::next[0..orig(state)-1] ::next[orig(ch)] ::next[orig(ch)-1] ::next[orig(ch)..] ::next[orig(ch)+1..] ::next[0..orig(ch)] ::next[0..orig(ch)-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(state)] ::check[orig(state)-1] ::check[orig(state)..] ::check[orig(state)+1..] ::check[0..orig(state)] ::check[0..orig(state)-1] ::check[orig(ch)] ::check[orig(ch)-1] ::check[orig(ch)..] ::check[orig(ch)+1..] ::check[0..orig(ch)] ::check[0..orig(ch)-1] orig(::default1[post(state)]) orig(::default1[post(state)-1]) orig(::default1[post(state)..]) orig(::default1[post(state)+1..]) orig(::default1[0..post(state)]) orig(::default1[0..post(state)-1]) orig(::base[post(state)]) orig(::base[post(state)-1]) orig(::base[post(state)..]) orig(::base[post(state)+1..]) orig(::base[0..post(state)]) orig(::base[0..post(state)-1]) orig(::next[post(state)]) orig(::next[post(state)-1]) orig(::next[post(state)..]) orig(::next[post(state)+1..]) orig(::next[0..post(state)]) orig(::next[0..post(state)-1]) orig(::check[post(state)]) orig(::check[post(state)-1]) orig(::check[post(state)..]) orig(::check[post(state)+1..]) orig(::check[0..post(state)]) orig(::check[0..post(state)-1]) orig(::default1[post(ch)]) orig(::default1[post(ch)-1]) orig(::default1[post(ch)..]) orig(::default1[post(ch)+1..]) orig(::default1[0..post(ch)]) orig(::default1[0..post(ch)-1]) orig(::base[post(ch)]) orig(::base[post(ch)-1]) orig(::base[post(ch)..]) orig(::base[post(ch)+1..]) orig(::base[0..post(ch)]) orig(::base[0..post(ch)-1]) orig(::next[post(ch)]) orig(::next[post(ch)-1]) orig(::next[post(ch)..]) orig(::next[post(ch)+1..]) orig(::next[0..post(ch)]) orig(::next[0..post(ch)-1]) orig(::check[post(ch)]) orig(::check[post(ch)-1]) orig(::check[post(ch)..]) orig(::check[post(ch)+1..]) orig(::check[0..post(ch)]) orig(::check[0..post(ch)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[state]) orig(::default1[state-1]) orig(::default1[state..]) orig(::default1[state+1..]) orig(::default1[0..state]) orig(::default1[0..state-1]) orig(::default1[ch]) orig(::default1[ch-1]) orig(::default1[ch..]) orig(::default1[ch+1..]) orig(::default1[0..ch]) orig(::default1[0..ch-1]) orig(::base[state]) orig(::base[state-1]) orig(::base[state..]) orig(::base[state+1..]) orig(::base[0..state]) orig(::base[0..state-1]) orig(::base[ch]) orig(::base[ch-1]) orig(::base[ch..]) orig(::base[ch+1..]) orig(::base[0..ch]) orig(::base[0..ch-1]) orig(::next[state]) orig(::next[state-1]) orig(::next[state..]) orig(::next[state+1..]) orig(::next[0..state]) orig(::next[0..state-1]) orig(::next[ch]) orig(::next[ch-1]) orig(::next[ch..]) orig(::next[ch+1..]) orig(::next[0..ch]) orig(::next[0..ch-1]) orig(::check[state]) orig(::check[state-1]) orig(::check[state..]) orig(::check[state+1..]) orig(::check[0..state]) orig(::check[0..state-1]) orig(::check[ch]) orig(::check[ch-1]) orig(::check[ch..]) orig(::check[ch+1..]) orig(::check[0..ch]) orig(::check[0..ch-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(::default1, 0)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {0, 26, -1, 17, 27, 29} subset of ::next[orig(ch)+1..]
warning: method daikon.inv.unary.sequence.CommonSequence.format(OutputFormat:JML) needs to be implemented: {-1, 51, 52, 26, 54, 28} subset of ::check[orig(ch)+1..]
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
return <= \old(ch)
return < daikon.Quant.size(::default1)-1
return < daikon.Quant.size(::next)-1
\old(state) < daikon.Quant.size(::default1)-1
\old(state) < daikon.Quant.size(::next)-1
\old(ch) != daikon.Quant.size(::default1)
\old(ch) < daikon.Quant.size(::next)-1
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, \old(ch)), \old(ch))
===========================================================================
print_tokens.c.numeric_case():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string ch token_str token_ind size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1 size(token_ptr[]) size(token_ptr[])-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] tstream_ptr[ch] tstream_ptr[ch-1] tstream_ptr[ch..] tstream_ptr[ch+1..] tstream_ptr[0..ch] tstream_ptr[0..ch-1] tstream_ptr[token_ind] tstream_ptr[token_ind-1] tstream_ptr[token_ind..] tstream_ptr[token_ind+1..] tstream_ptr[0..token_ind] tstream_ptr[0..token_ind-1] tstream_ptr[ch].ch_stream tstream_ptr[ch-1].ch_stream tstream_ptr[ch..].ch_stream tstream_ptr[ch+1..].ch_stream tstream_ptr[0..ch].ch_stream tstream_ptr[0..ch-1].ch_stream tstream_ptr[token_ind].ch_stream tstream_ptr[token_ind-1].ch_stream tstream_ptr[token_ind..].ch_stream tstream_ptr[token_ind+1..].ch_stream tstream_ptr[0..token_ind].ch_stream tstream_ptr[0..token_ind-1].ch_stream tstream_ptr[ch].ch_stream[0] tstream_ptr[ch-1].ch_stream[0] tstream_ptr[ch..].ch_stream[0] tstream_ptr[ch+1..].ch_stream[0] tstream_ptr[0..ch].ch_stream[0] tstream_ptr[0..ch-1].ch_stream[0] tstream_ptr[token_ind].ch_stream[0] tstream_ptr[token_ind-1].ch_stream[0] tstream_ptr[token_ind..].ch_stream[0] tstream_ptr[token_ind+1..].ch_stream[0] tstream_ptr[0..token_ind].ch_stream[0] tstream_ptr[0..token_ind-1].ch_stream[0] tstream_ptr[ch].ch_stream->fp tstream_ptr[ch-1].ch_stream->fp tstream_ptr[ch..].ch_stream->fp tstream_ptr[ch+1..].ch_stream->fp tstream_ptr[0..ch].ch_stream->fp tstream_ptr[0..ch-1].ch_stream->fp tstream_ptr[token_ind].ch_stream->fp tstream_ptr[token_ind-1].ch_stream->fp tstream_ptr[token_ind..].ch_stream->fp tstream_ptr[token_ind+1..].ch_stream->fp tstream_ptr[0..token_ind].ch_stream->fp tstream_ptr[0..token_ind-1].ch_stream->fp tstream_ptr[ch].ch_stream->fp[0] tstream_ptr[ch-1].ch_stream->fp[0] tstream_ptr[ch..].ch_stream->fp[0] tstream_ptr[ch+1..].ch_stream->fp[0] tstream_ptr[0..ch].ch_stream->fp[0] tstream_ptr[0..ch-1].ch_stream->fp[0] tstream_ptr[token_ind].ch_stream->fp[0] tstream_ptr[token_ind-1].ch_stream->fp[0] tstream_ptr[token_ind..].ch_stream->fp[0] tstream_ptr[token_ind+1..].ch_stream->fp[0] tstream_ptr[0..token_ind].ch_stream->fp[0] tstream_ptr[0..token_ind-1].ch_stream->fp[0] tstream_ptr[ch].ch_stream->stream_ind tstream_ptr[ch-1].ch_stream->stream_ind tstream_ptr[ch..].ch_stream->stream_ind tstream_ptr[ch+1..].ch_stream->stream_ind tstream_ptr[0..ch].ch_stream->stream_ind tstream_ptr[0..ch-1].ch_stream->stream_ind tstream_ptr[token_ind].ch_stream->stream_ind tstream_ptr[token_ind-1].ch_stream->stream_ind tstream_ptr[token_ind..].ch_stream->stream_ind tstream_ptr[token_ind+1..].ch_stream->stream_ind tstream_ptr[0..token_ind].ch_stream->stream_ind tstream_ptr[0..token_ind-1].ch_stream->stream_ind token_ptr[ch] token_ptr[ch-1] token_ptr[ch..] token_ptr[ch+1..] token_ptr[0..ch] token_ptr[0..ch-1] token_ptr[token_ind] token_ptr[token_ind-1] token_ptr[token_ind..] token_ptr[token_ind+1..] token_ptr[0..token_ind] token_ptr[0..token_ind-1] token_ptr[ch].token_id token_ptr[ch-1].token_id token_ptr[ch..].token_id token_ptr[ch+1..].token_id token_ptr[0..ch].token_id token_ptr[0..ch-1].token_id token_ptr[token_ind].token_id token_ptr[token_ind-1].token_id token_ptr[token_ind..].token_id token_ptr[token_ind+1..].token_id token_ptr[0..token_ind].token_id token_ptr[0..token_ind-1].token_id
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(tstream_ptr) == daikon.Quant.size(tstream_ptr)
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, ch-1)
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, token_ind)
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, token_ind-1)
daikon.Quant.getElement_int(::default1, ch) == daikon.Quant.getElement_int(::default1, ch-1)
daikon.Quant.getElement_int(::default1, ch) == daikon.Quant.getElement_int(::default1, token_ind)
daikon.Quant.getElement_int(::default1, ch) == daikon.Quant.getElement_int(::default1, token_ind-1)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
tstream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), 23)
token_ptr != null
ch == 10
token_ind == 3
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(tstream_ptr) == 1
daikon.Quant.getElement_int(::default1, ch) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, ch) == -99
daikon.Quant.getElement_int(::base, ch-1) == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, token_ind) == -93
daikon.Quant.getElement_int(::base, token_ind-1) == -105
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, token_ind-1), new long[] { -105, -96, -32 })
daikon.Quant.getElement_int(::next, ch) == 6
daikon.Quant.getElement_int(::next, ch-1) == 20
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, token_ind) == 28
daikon.Quant.getElement_int(::next, token_ind-1) == 26
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind-1), new long[] { 0, 2, 26 })
daikon.Quant.getElement_int(::check, ch) == 5
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, token_ind), new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::default1 )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), ::next)
daikon.Quant.memberOf(ch , ::next )
daikon.Quant.memberOf(token_ind , ::next )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , ::next )
daikon.Quant.memberOf(ch , ::check )
daikon.Quant.memberOf(token_ind , ::check )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind-1) , ::check )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[0..ch]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, 0, ch))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[0..ch-1]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, 0, ch-1))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[token_ind..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[token_ind+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)))
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(ch , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::check, 0, ch) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::check, 0, ch-1) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(token_ind , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::check, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::check, 0, ch-1) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::check, 0, token_ind) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr) , daikon.Quant.slice(::check, 0, token_ind-1) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, ch, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, ch+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, token_ind, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, token_ind+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, token_ind) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, token_ind-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, ch) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::default1, ch, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::default1, ch+1, daikon.Quant.size(::default1)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch), daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch), daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch-1), daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch-1), daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch-1), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, ch-1), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::default1, token_ind, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::default1, token_ind+1, daikon.Quant.size(::default1)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind-1), daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind-1), daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind-1), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, token_ind-1), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, ch+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, ch-1) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, 0, ch-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind-1) , daikon.Quant.slice(::check, ch, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind-1) , daikon.Quant.slice(::check, ch+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind-1) , daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, token_ind-1) , daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, token_ind, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, ch) , daikon.Quant.slice(::next, token_ind+1, daikon.Quant.size(::next)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind-1), daikon.Quant.slice(::check, token_ind, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, token_ind-1), daikon.Quant.slice(::check, token_ind+1, daikon.Quant.size(::check)))
===========================================================================
print_tokens.c.numeric_case():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] tstream_ptr tstream_ptr[] tstream_ptr[].ch_stream tstream_ptr[].ch_stream[0] tstream_ptr[].ch_stream->fp tstream_ptr[].ch_stream->fp[0] tstream_ptr[].ch_stream->stream_ind tstream_ptr[].ch_stream->stream token_ptr token_ptr[] token_ptr[].token_id token_ptr[].token_string ch token_str token_ind return return[] return[].token_id return[].token_string orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(tstream_ptr) orig(tstream_ptr[]) orig(tstream_ptr[].ch_stream) orig(tstream_ptr[].ch_stream[0]) orig(tstream_ptr[].ch_stream->fp) orig(tstream_ptr[].ch_stream->fp[0]) orig(tstream_ptr[].ch_stream->stream_ind) orig(tstream_ptr[].ch_stream->stream) orig(token_ptr) orig(token_ptr[]) orig(token_ptr[].token_id) orig(token_ptr[].token_string) orig(ch) orig(token_str) orig(token_ind) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(tstream_ptr[]) size(tstream_ptr[])-1 size(tstream_ptr[].ch_stream[0]) size(tstream_ptr[].ch_stream[0])-1 size(tstream_ptr[].ch_stream->fp[0]) size(tstream_ptr[].ch_stream->fp[0])-1 size(token_ptr[]) size(token_ptr[])-1 size(return[]) size(return[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(tstream_ptr[])) orig(size(tstream_ptr[]))-1 orig(size(tstream_ptr[].ch_stream[0])) orig(size(tstream_ptr[].ch_stream[0]))-1 orig(size(tstream_ptr[].ch_stream->fp[0])) orig(size(tstream_ptr[].ch_stream->fp[0]))-1 orig(size(token_ptr[])) orig(size(token_ptr[]))-1 ::default1[ch] ::default1[ch-1] ::default1[ch..] ::default1[ch+1..] ::default1[0..ch] ::default1[0..ch-1] ::default1[token_ind] ::default1[token_ind-1] ::default1[token_ind..] ::default1[token_ind+1..] ::default1[0..token_ind] ::default1[0..token_ind-1] ::default1[orig(ch)] ::default1[orig(ch)-1] ::default1[orig(ch)..] ::default1[orig(ch)+1..] ::default1[0..orig(ch)] ::default1[0..orig(ch)-1] ::default1[orig(token_ind)] ::default1[orig(token_ind)-1] ::default1[orig(token_ind)..] ::default1[orig(token_ind)+1..] ::default1[0..orig(token_ind)] ::default1[0..orig(token_ind)-1] ::base[ch] ::base[ch-1] ::base[ch..] ::base[ch+1..] ::base[0..ch] ::base[0..ch-1] ::base[token_ind] ::base[token_ind-1] ::base[token_ind..] ::base[token_ind+1..] ::base[0..token_ind] ::base[0..token_ind-1] ::base[orig(ch)] ::base[orig(ch)-1] ::base[orig(ch)..] ::base[orig(ch)+1..] ::base[0..orig(ch)] ::base[0..orig(ch)-1] ::base[orig(token_ind)] ::base[orig(token_ind)-1] ::base[orig(token_ind)..] ::base[orig(token_ind)+1..] ::base[0..orig(token_ind)] ::base[0..orig(token_ind)-1] ::next[ch] ::next[ch-1] ::next[ch..] ::next[ch+1..] ::next[0..ch] ::next[0..ch-1] ::next[token_ind] ::next[token_ind-1] ::next[token_ind..] ::next[token_ind+1..] ::next[0..token_ind] ::next[0..token_ind-1] ::next[orig(ch)] ::next[orig(ch)-1] ::next[orig(ch)..] ::next[orig(ch)+1..] ::next[0..orig(ch)] ::next[0..orig(ch)-1] ::next[orig(token_ind)] ::next[orig(token_ind)-1] ::next[orig(token_ind)..] ::next[orig(token_ind)+1..] ::next[0..orig(token_ind)] ::next[0..orig(token_ind)-1] ::check[ch] ::check[ch-1] ::check[ch..] ::check[ch+1..] ::check[0..ch] ::check[0..ch-1] ::check[token_ind] ::check[token_ind-1] ::check[token_ind..] ::check[token_ind+1..] ::check[0..token_ind] ::check[0..token_ind-1] ::check[orig(ch)] ::check[orig(ch)-1] ::check[orig(ch)..] ::check[orig(ch)+1..] ::check[0..orig(ch)] ::check[0..orig(ch)-1] ::check[orig(token_ind)] ::check[orig(token_ind)-1] ::check[orig(token_ind)..] ::check[orig(token_ind)+1..] ::check[0..orig(token_ind)] ::check[0..orig(token_ind)-1] tstream_ptr[ch] tstream_ptr[ch-1] tstream_ptr[ch..] tstream_ptr[ch+1..] tstream_ptr[0..ch] tstream_ptr[0..ch-1] tstream_ptr[token_ind] tstream_ptr[token_ind-1] tstream_ptr[token_ind..] tstream_ptr[token_ind+1..] tstream_ptr[0..token_ind] tstream_ptr[0..token_ind-1] tstream_ptr[orig(ch)] tstream_ptr[orig(ch)-1] tstream_ptr[orig(ch)..] tstream_ptr[orig(ch)+1..] tstream_ptr[0..orig(ch)] tstream_ptr[0..orig(ch)-1] tstream_ptr[orig(token_ind)] tstream_ptr[orig(token_ind)-1] tstream_ptr[orig(token_ind)..] tstream_ptr[orig(token_ind)+1..] tstream_ptr[0..orig(token_ind)] tstream_ptr[0..orig(token_ind)-1] tstream_ptr[ch].ch_stream tstream_ptr[ch-1].ch_stream tstream_ptr[ch..].ch_stream tstream_ptr[ch+1..].ch_stream tstream_ptr[0..ch].ch_stream tstream_ptr[0..ch-1].ch_stream tstream_ptr[token_ind].ch_stream tstream_ptr[token_ind-1].ch_stream tstream_ptr[token_ind..].ch_stream tstream_ptr[token_ind+1..].ch_stream tstream_ptr[0..token_ind].ch_stream tstream_ptr[0..token_ind-1].ch_stream tstream_ptr[orig(ch)].ch_stream tstream_ptr[orig(ch)-1].ch_stream tstream_ptr[orig(ch)..].ch_stream tstream_ptr[orig(ch)+1..].ch_stream tstream_ptr[0..orig(ch)].ch_stream tstream_ptr[0..orig(ch)-1].ch_stream tstream_ptr[orig(token_ind)].ch_stream tstream_ptr[orig(token_ind)-1].ch_stream tstream_ptr[orig(token_ind)..].ch_stream tstream_ptr[orig(token_ind)+1..].ch_stream tstream_ptr[0..orig(token_ind)].ch_stream tstream_ptr[0..orig(token_ind)-1].ch_stream tstream_ptr[ch].ch_stream[0] tstream_ptr[ch-1].ch_stream[0] tstream_ptr[ch..].ch_stream[0] tstream_ptr[ch+1..].ch_stream[0] tstream_ptr[0..ch].ch_stream[0] tstream_ptr[0..ch-1].ch_stream[0] tstream_ptr[token_ind].ch_stream[0] tstream_ptr[token_ind-1].ch_stream[0] tstream_ptr[token_ind..].ch_stream[0] tstream_ptr[token_ind+1..].ch_stream[0] tstream_ptr[0..token_ind].ch_stream[0] tstream_ptr[0..token_ind-1].ch_stream[0] tstream_ptr[orig(ch)].ch_stream[0] tstream_ptr[orig(ch)-1].ch_stream[0] tstream_ptr[orig(ch)..].ch_stream[0] tstream_ptr[orig(ch)+1..].ch_stream[0] tstream_ptr[0..orig(ch)].ch_stream[0] tstream_ptr[0..orig(ch)-1].ch_stream[0] tstream_ptr[orig(token_ind)].ch_stream[0] tstream_ptr[orig(token_ind)-1].ch_stream[0] tstream_ptr[orig(token_ind)..].ch_stream[0] tstream_ptr[orig(token_ind)+1..].ch_stream[0] tstream_ptr[0..orig(token_ind)].ch_stream[0] tstream_ptr[0..orig(token_ind)-1].ch_stream[0] tstream_ptr[ch].ch_stream->fp tstream_ptr[ch-1].ch_stream->fp tstream_ptr[ch..].ch_stream->fp tstream_ptr[ch+1..].ch_stream->fp tstream_ptr[0..ch].ch_stream->fp tstream_ptr[0..ch-1].ch_stream->fp tstream_ptr[token_ind].ch_stream->fp tstream_ptr[token_ind-1].ch_stream->fp tstream_ptr[token_ind..].ch_stream->fp tstream_ptr[token_ind+1..].ch_stream->fp tstream_ptr[0..token_ind].ch_stream->fp tstream_ptr[0..token_ind-1].ch_stream->fp tstream_ptr[orig(ch)].ch_stream->fp tstream_ptr[orig(ch)-1].ch_stream->fp tstream_ptr[orig(ch)..].ch_stream->fp tstream_ptr[orig(ch)+1..].ch_stream->fp tstream_ptr[0..orig(ch)].ch_stream->fp tstream_ptr[0..orig(ch)-1].ch_stream->fp tstream_ptr[orig(token_ind)].ch_stream->fp tstream_ptr[orig(token_ind)-1].ch_stream->fp tstream_ptr[orig(token_ind)..].ch_stream->fp tstream_ptr[orig(token_ind)+1..].ch_stream->fp tstream_ptr[0..orig(token_ind)].ch_stream->fp tstream_ptr[0..orig(token_ind)-1].ch_stream->fp tstream_ptr[ch].ch_stream->fp[0] tstream_ptr[ch-1].ch_stream->fp[0] tstream_ptr[ch..].ch_stream->fp[0] tstream_ptr[ch+1..].ch_stream->fp[0] tstream_ptr[0..ch].ch_stream->fp[0] tstream_ptr[0..ch-1].ch_stream->fp[0] tstream_ptr[token_ind].ch_stream->fp[0] tstream_ptr[token_ind-1].ch_stream->fp[0] tstream_ptr[token_ind..].ch_stream->fp[0] tstream_ptr[token_ind+1..].ch_stream->fp[0] tstream_ptr[0..token_ind].ch_stream->fp[0] tstream_ptr[0..token_ind-1].ch_stream->fp[0] tstream_ptr[orig(ch)].ch_stream->fp[0] tstream_ptr[orig(ch)-1].ch_stream->fp[0] tstream_ptr[orig(ch)..].ch_stream->fp[0] tstream_ptr[orig(ch)+1..].ch_stream->fp[0] tstream_ptr[0..orig(ch)].ch_stream->fp[0] tstream_ptr[0..orig(ch)-1].ch_stream->fp[0] tstream_ptr[orig(token_ind)].ch_stream->fp[0] tstream_ptr[orig(token_ind)-1].ch_stream->fp[0] tstream_ptr[orig(token_ind)..].ch_stream->fp[0] tstream_ptr[orig(token_ind)+1..].ch_stream->fp[0] tstream_ptr[0..orig(token_ind)].ch_stream->fp[0] tstream_ptr[0..orig(token_ind)-1].ch_stream->fp[0] tstream_ptr[ch].ch_stream->stream_ind tstream_ptr[ch-1].ch_stream->stream_ind tstream_ptr[ch..].ch_stream->stream_ind tstream_ptr[ch+1..].ch_stream->stream_ind tstream_ptr[0..ch].ch_stream->stream_ind tstream_ptr[0..ch-1].ch_stream->stream_ind tstream_ptr[token_ind].ch_stream->stream_ind tstream_ptr[token_ind-1].ch_stream->stream_ind tstream_ptr[token_ind..].ch_stream->stream_ind tstream_ptr[token_ind+1..].ch_stream->stream_ind tstream_ptr[0..token_ind].ch_stream->stream_ind tstream_ptr[0..token_ind-1].ch_stream->stream_ind tstream_ptr[orig(ch)].ch_stream->stream_ind tstream_ptr[orig(ch)-1].ch_stream->stream_ind tstream_ptr[orig(ch)..].ch_stream->stream_ind tstream_ptr[orig(ch)+1..].ch_stream->stream_ind tstream_ptr[0..orig(ch)].ch_stream->stream_ind tstream_ptr[0..orig(ch)-1].ch_stream->stream_ind tstream_ptr[orig(token_ind)].ch_stream->stream_ind tstream_ptr[orig(token_ind)-1].ch_stream->stream_ind tstream_ptr[orig(token_ind)..].ch_stream->stream_ind tstream_ptr[orig(token_ind)+1..].ch_stream->stream_ind tstream_ptr[0..orig(token_ind)].ch_stream->stream_ind tstream_ptr[0..orig(token_ind)-1].ch_stream->stream_ind token_ptr[ch] token_ptr[ch-1] token_ptr[ch..] token_ptr[ch+1..] token_ptr[0..ch] token_ptr[0..ch-1] token_ptr[token_ind] token_ptr[token_ind-1] token_ptr[token_ind..] token_ptr[token_ind+1..] token_ptr[0..token_ind] token_ptr[0..token_ind-1] token_ptr[orig(ch)] token_ptr[orig(ch)-1] token_ptr[orig(ch)..] token_ptr[orig(ch)+1..] token_ptr[0..orig(ch)] token_ptr[0..orig(ch)-1] token_ptr[orig(token_ind)] token_ptr[orig(token_ind)-1] token_ptr[orig(token_ind)..] token_ptr[orig(token_ind)+1..] token_ptr[0..orig(token_ind)] token_ptr[0..orig(token_ind)-1] token_ptr[ch].token_id token_ptr[ch-1].token_id token_ptr[ch..].token_id token_ptr[ch+1..].token_id token_ptr[0..ch].token_id token_ptr[0..ch-1].token_id token_ptr[token_ind].token_id token_ptr[token_ind-1].token_id token_ptr[token_ind..].token_id token_ptr[token_ind+1..].token_id token_ptr[0..token_ind].token_id token_ptr[0..token_ind-1].token_id token_ptr[orig(ch)].token_id token_ptr[orig(ch)-1].token_id token_ptr[orig(ch)..].token_id token_ptr[orig(ch)+1..].token_id token_ptr[0..orig(ch)].token_id token_ptr[0..orig(ch)-1].token_id token_ptr[orig(token_ind)].token_id token_ptr[orig(token_ind)-1].token_id token_ptr[orig(token_ind)..].token_id token_ptr[orig(token_ind)+1..].token_id token_ptr[0..orig(token_ind)].token_id token_ptr[0..orig(token_ind)-1].token_id return[ch] return[ch-1] return[ch..] return[ch+1..] return[0..ch] return[0..ch-1] return[ch].token_id return[ch-1].token_id return[ch..].token_id return[ch+1..].token_id return[0..ch].token_id return[0..ch-1].token_id orig(::default1[post(ch)]) orig(::default1[post(ch)-1]) orig(::default1[post(ch)..]) orig(::default1[post(ch)+1..]) orig(::default1[0..post(ch)]) orig(::default1[0..post(ch)-1]) orig(::base[post(ch)]) orig(::base[post(ch)-1]) orig(::base[post(ch)..]) orig(::base[post(ch)+1..]) orig(::base[0..post(ch)]) orig(::base[0..post(ch)-1]) orig(::next[post(ch)]) orig(::next[post(ch)-1]) orig(::next[post(ch)..]) orig(::next[post(ch)+1..]) orig(::next[0..post(ch)]) orig(::next[0..post(ch)-1]) orig(::check[post(ch)]) orig(::check[post(ch)-1]) orig(::check[post(ch)..]) orig(::check[post(ch)+1..]) orig(::check[0..post(ch)]) orig(::check[0..post(ch)-1]) orig(tstream_ptr[post(ch)]) orig(tstream_ptr[post(ch)-1]) orig(tstream_ptr[post(ch)..]) orig(tstream_ptr[post(ch)+1..]) orig(tstream_ptr[0..post(ch)]) orig(tstream_ptr[0..post(ch)-1]) orig(tstream_ptr[post(ch)].ch_stream) orig(tstream_ptr[post(ch)-1].ch_stream) orig(tstream_ptr[post(ch)..].ch_stream) orig(tstream_ptr[post(ch)+1..].ch_stream) orig(tstream_ptr[0..post(ch)].ch_stream) orig(tstream_ptr[0..post(ch)-1].ch_stream) orig(tstream_ptr[post(ch)].ch_stream[0]) orig(tstream_ptr[post(ch)-1].ch_stream[0]) orig(tstream_ptr[post(ch)..].ch_stream[0]) orig(tstream_ptr[post(ch)+1..].ch_stream[0]) orig(tstream_ptr[0..post(ch)].ch_stream[0]) orig(tstream_ptr[0..post(ch)-1].ch_stream[0]) orig(tstream_ptr[post(ch)].ch_stream->fp) orig(tstream_ptr[post(ch)-1].ch_stream->fp) orig(tstream_ptr[post(ch)..].ch_stream->fp) orig(tstream_ptr[post(ch)+1..].ch_stream->fp) orig(tstream_ptr[0..post(ch)].ch_stream->fp) orig(tstream_ptr[0..post(ch)-1].ch_stream->fp) orig(tstream_ptr[post(ch)].ch_stream->fp[0]) orig(tstream_ptr[post(ch)-1].ch_stream->fp[0]) orig(tstream_ptr[post(ch)..].ch_stream->fp[0]) orig(tstream_ptr[post(ch)+1..].ch_stream->fp[0]) orig(tstream_ptr[0..post(ch)].ch_stream->fp[0]) orig(tstream_ptr[0..post(ch)-1].ch_stream->fp[0]) orig(tstream_ptr[post(ch)].ch_stream->stream_ind) orig(tstream_ptr[post(ch)-1].ch_stream->stream_ind) orig(tstream_ptr[post(ch)..].ch_stream->stream_ind) orig(tstream_ptr[post(ch)+1..].ch_stream->stream_ind) orig(tstream_ptr[0..post(ch)].ch_stream->stream_ind) orig(tstream_ptr[0..post(ch)-1].ch_stream->stream_ind) orig(token_ptr[post(ch)]) orig(token_ptr[post(ch)-1]) orig(token_ptr[post(ch)..]) orig(token_ptr[post(ch)+1..]) orig(token_ptr[0..post(ch)]) orig(token_ptr[0..post(ch)-1]) orig(token_ptr[post(ch)].token_id) orig(token_ptr[post(ch)-1].token_id) orig(token_ptr[post(ch)..].token_id) orig(token_ptr[post(ch)+1..].token_id) orig(token_ptr[0..post(ch)].token_id) orig(token_ptr[0..post(ch)-1].token_id) return[token_ind] return[token_ind-1] return[token_ind..] return[token_ind+1..] return[0..token_ind] return[0..token_ind-1] return[token_ind].token_id return[token_ind-1].token_id return[token_ind..].token_id return[token_ind+1..].token_id return[0..token_ind].token_id return[0..token_ind-1].token_id orig(::default1[post(token_ind)]) orig(::default1[post(token_ind)-1]) orig(::default1[post(token_ind)..]) orig(::default1[post(token_ind)+1..]) orig(::default1[0..post(token_ind)]) orig(::default1[0..post(token_ind)-1]) orig(::base[post(token_ind)]) orig(::base[post(token_ind)-1]) orig(::base[post(token_ind)..]) orig(::base[post(token_ind)+1..]) orig(::base[0..post(token_ind)]) orig(::base[0..post(token_ind)-1]) orig(::next[post(token_ind)]) orig(::next[post(token_ind)-1]) orig(::next[post(token_ind)..]) orig(::next[post(token_ind)+1..]) orig(::next[0..post(token_ind)]) orig(::next[0..post(token_ind)-1]) orig(::check[post(token_ind)]) orig(::check[post(token_ind)-1]) orig(::check[post(token_ind)..]) orig(::check[post(token_ind)+1..]) orig(::check[0..post(token_ind)]) orig(::check[0..post(token_ind)-1]) orig(tstream_ptr[post(token_ind)]) orig(tstream_ptr[post(token_ind)-1]) orig(tstream_ptr[post(token_ind)..]) orig(tstream_ptr[post(token_ind)+1..]) orig(tstream_ptr[0..post(token_ind)]) orig(tstream_ptr[0..post(token_ind)-1]) orig(tstream_ptr[post(token_ind)].ch_stream) orig(tstream_ptr[post(token_ind)-1].ch_stream) orig(tstream_ptr[post(token_ind)..].ch_stream) orig(tstream_ptr[post(token_ind)+1..].ch_stream) orig(tstream_ptr[0..post(token_ind)].ch_stream) orig(tstream_ptr[0..post(token_ind)-1].ch_stream) orig(tstream_ptr[post(token_ind)].ch_stream[0]) orig(tstream_ptr[post(token_ind)-1].ch_stream[0]) orig(tstream_ptr[post(token_ind)..].ch_stream[0]) orig(tstream_ptr[post(token_ind)+1..].ch_stream[0]) orig(tstream_ptr[0..post(token_ind)].ch_stream[0]) orig(tstream_ptr[0..post(token_ind)-1].ch_stream[0]) orig(tstream_ptr[post(token_ind)].ch_stream->fp) orig(tstream_ptr[post(token_ind)-1].ch_stream->fp) orig(tstream_ptr[post(token_ind)..].ch_stream->fp) orig(tstream_ptr[post(token_ind)+1..].ch_stream->fp) orig(tstream_ptr[0..post(token_ind)].ch_stream->fp) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->fp) orig(tstream_ptr[post(token_ind)].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)-1].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)..].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)+1..].ch_stream->fp[0]) orig(tstream_ptr[0..post(token_ind)].ch_stream->fp[0]) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->fp[0]) orig(tstream_ptr[post(token_ind)].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)-1].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)..].ch_stream->stream_ind) orig(tstream_ptr[post(token_ind)+1..].ch_stream->stream_ind) orig(tstream_ptr[0..post(token_ind)].ch_stream->stream_ind) orig(tstream_ptr[0..post(token_ind)-1].ch_stream->stream_ind) orig(token_ptr[post(token_ind)]) orig(token_ptr[post(token_ind)-1]) orig(token_ptr[post(token_ind)..]) orig(token_ptr[post(token_ind)+1..]) orig(token_ptr[0..post(token_ind)]) orig(token_ptr[0..post(token_ind)-1]) orig(token_ptr[post(token_ind)].token_id) orig(token_ptr[post(token_ind)-1].token_id) orig(token_ptr[post(token_ind)..].token_id) orig(token_ptr[post(token_ind)+1..].token_id) orig(token_ptr[0..post(token_ind)].token_id) orig(token_ptr[0..post(token_ind)-1].token_id) return[orig(ch)] return[orig(ch)-1] return[orig(ch)..] return[orig(ch)+1..] return[0..orig(ch)] return[0..orig(ch)-1] return[orig(token_ind)] return[orig(token_ind)-1] return[orig(token_ind)..] return[orig(token_ind)+1..] return[0..orig(token_ind)] return[0..orig(token_ind)-1] return[orig(ch)].token_id return[orig(ch)-1].token_id return[orig(ch)..].token_id return[orig(ch)+1..].token_id return[0..orig(ch)].token_id return[0..orig(ch)-1].token_id return[orig(token_ind)].token_id return[orig(token_ind)-1].token_id return[orig(token_ind)..].token_id return[orig(token_ind)+1..].token_id return[0..orig(token_ind)].token_id return[0..orig(token_ind)-1].token_id orig(::default1[ch]) orig(::default1[ch-1]) orig(::default1[ch..]) orig(::default1[ch+1..]) orig(::default1[0..ch]) orig(::default1[0..ch-1]) orig(::default1[token_ind]) orig(::default1[token_ind-1]) orig(::default1[token_ind..]) orig(::default1[token_ind+1..]) orig(::default1[0..token_ind]) orig(::default1[0..token_ind-1]) orig(::base[ch]) orig(::base[ch-1]) orig(::base[ch..]) orig(::base[ch+1..]) orig(::base[0..ch]) orig(::base[0..ch-1]) orig(::base[token_ind]) orig(::base[token_ind-1]) orig(::base[token_ind..]) orig(::base[token_ind+1..]) orig(::base[0..token_ind]) orig(::base[0..token_ind-1]) orig(::next[ch]) orig(::next[ch-1]) orig(::next[ch..]) orig(::next[ch+1..]) orig(::next[0..ch]) orig(::next[0..ch-1]) orig(::next[token_ind]) orig(::next[token_ind-1]) orig(::next[token_ind..]) orig(::next[token_ind+1..]) orig(::next[0..token_ind]) orig(::next[0..token_ind-1]) orig(::check[ch]) orig(::check[ch-1]) orig(::check[ch..]) orig(::check[ch+1..]) orig(::check[0..ch]) orig(::check[0..ch-1]) orig(::check[token_ind]) orig(::check[token_ind-1]) orig(::check[token_ind..]) orig(::check[token_ind+1..]) orig(::check[0..token_ind]) orig(::check[0..token_ind-1]) orig(tstream_ptr[ch]) orig(tstream_ptr[ch-1]) orig(tstream_ptr[ch..]) orig(tstream_ptr[ch+1..]) orig(tstream_ptr[0..ch]) orig(tstream_ptr[0..ch-1]) orig(tstream_ptr[token_ind]) orig(tstream_ptr[token_ind-1]) orig(tstream_ptr[token_ind..]) orig(tstream_ptr[token_ind+1..]) orig(tstream_ptr[0..token_ind]) orig(tstream_ptr[0..token_ind-1]) orig(tstream_ptr[ch].ch_stream) orig(tstream_ptr[ch-1].ch_stream) orig(tstream_ptr[ch..].ch_stream) orig(tstream_ptr[ch+1..].ch_stream) orig(tstream_ptr[0..ch].ch_stream) orig(tstream_ptr[0..ch-1].ch_stream) orig(tstream_ptr[token_ind].ch_stream) orig(tstream_ptr[token_ind-1].ch_stream) orig(tstream_ptr[token_ind..].ch_stream) orig(tstream_ptr[token_ind+1..].ch_stream) orig(tstream_ptr[0..token_ind].ch_stream) orig(tstream_ptr[0..token_ind-1].ch_stream) orig(tstream_ptr[ch].ch_stream[0]) orig(tstream_ptr[ch-1].ch_stream[0]) orig(tstream_ptr[ch..].ch_stream[0]) orig(tstream_ptr[ch+1..].ch_stream[0]) orig(tstream_ptr[0..ch].ch_stream[0]) orig(tstream_ptr[0..ch-1].ch_stream[0]) orig(tstream_ptr[token_ind].ch_stream[0]) orig(tstream_ptr[token_ind-1].ch_stream[0]) orig(tstream_ptr[token_ind..].ch_stream[0]) orig(tstream_ptr[token_ind+1..].ch_stream[0]) orig(tstream_ptr[0..token_ind].ch_stream[0]) orig(tstream_ptr[0..token_ind-1].ch_stream[0]) orig(tstream_ptr[ch].ch_stream->fp) orig(tstream_ptr[ch-1].ch_stream->fp) orig(tstream_ptr[ch..].ch_stream->fp) orig(tstream_ptr[ch+1..].ch_stream->fp) orig(tstream_ptr[0..ch].ch_stream->fp) orig(tstream_ptr[0..ch-1].ch_stream->fp) orig(tstream_ptr[token_ind].ch_stream->fp) orig(tstream_ptr[token_ind-1].ch_stream->fp) orig(tstream_ptr[token_ind..].ch_stream->fp) orig(tstream_ptr[token_ind+1..].ch_stream->fp) orig(tstream_ptr[0..token_ind].ch_stream->fp) orig(tstream_ptr[0..token_ind-1].ch_stream->fp) orig(tstream_ptr[ch].ch_stream->fp[0]) orig(tstream_ptr[ch-1].ch_stream->fp[0]) orig(tstream_ptr[ch..].ch_stream->fp[0]) orig(tstream_ptr[ch+1..].ch_stream->fp[0]) orig(tstream_ptr[0..ch].ch_stream->fp[0]) orig(tstream_ptr[0..ch-1].ch_stream->fp[0]) orig(tstream_ptr[token_ind].ch_stream->fp[0]) orig(tstream_ptr[token_ind-1].ch_stream->fp[0]) orig(tstream_ptr[token_ind..].ch_stream->fp[0]) orig(tstream_ptr[token_ind+1..].ch_stream->fp[0]) orig(tstream_ptr[0..token_ind].ch_stream->fp[0]) orig(tstream_ptr[0..token_ind-1].ch_stream->fp[0]) orig(tstream_ptr[ch].ch_stream->stream_ind) orig(tstream_ptr[ch-1].ch_stream->stream_ind) orig(tstream_ptr[ch..].ch_stream->stream_ind) orig(tstream_ptr[ch+1..].ch_stream->stream_ind) orig(tstream_ptr[0..ch].ch_stream->stream_ind) orig(tstream_ptr[0..ch-1].ch_stream->stream_ind) orig(tstream_ptr[token_ind].ch_stream->stream_ind) orig(tstream_ptr[token_ind-1].ch_stream->stream_ind) orig(tstream_ptr[token_ind..].ch_stream->stream_ind) orig(tstream_ptr[token_ind+1..].ch_stream->stream_ind) orig(tstream_ptr[0..token_ind].ch_stream->stream_ind) orig(tstream_ptr[0..token_ind-1].ch_stream->stream_ind) orig(token_ptr[ch]) orig(token_ptr[ch-1]) orig(token_ptr[ch..]) orig(token_ptr[ch+1..]) orig(token_ptr[0..ch]) orig(token_ptr[0..ch-1]) orig(token_ptr[token_ind]) orig(token_ptr[token_ind-1]) orig(token_ptr[token_ind..]) orig(token_ptr[token_ind+1..]) orig(token_ptr[0..token_ind]) orig(token_ptr[0..token_ind-1]) orig(token_ptr[ch].token_id) orig(token_ptr[ch-1].token_id) orig(token_ptr[ch..].token_id) orig(token_ptr[ch+1..].token_id) orig(token_ptr[0..ch].token_id) orig(token_ptr[0..ch-1].token_id) orig(token_ptr[token_ind].token_id) orig(token_ptr[token_ind-1].token_id) orig(token_ptr[token_ind..].token_id) orig(token_ptr[token_ind+1..].token_id) orig(token_ptr[0..token_ind].token_id) orig(token_ptr[0..token_ind-1].token_id)
assignable tstream_ptr[].ch_stream->fp[0], tstream_ptr[].ch_stream->stream_ind, tstream_ptr[].ch_stream->stream, token_ptr[*], token_ptr[].token_id, token_ptr[].token_string
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(tstream_ptr, \old(tstream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]")))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), \old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp")))
daikon.Quant.pairwiseEqual(token_ptr, return)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.collectObject(return, "token_id"))
return == \old(token_ptr)
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, \old(ch)-1)
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, \old(token_ind))
daikon.Quant.size(tstream_ptr)-1 == daikon.Quant.getElement_int(::check, \old(token_ind)-1)
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, \new(ch)-1))
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, \new(token_ind)))
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, \new(token_ind)-1))
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, ch-1))
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, token_ind))
daikon.Quant.size(tstream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, token_ind-1))
daikon.Quant.size(return) == \old(daikon.Quant.size(tstream_ptr))
daikon.Quant.size(return) == \old(daikon.Quant.size(tstream_ptr))
daikon.Quant.getElement_int(::default1, \old(ch)) == daikon.Quant.getElement_int(::default1, \old(ch)-1)
daikon.Quant.getElement_int(::default1, \old(ch)) == daikon.Quant.getElement_int(::default1, \old(token_ind))
daikon.Quant.getElement_int(::default1, \old(ch)) == daikon.Quant.getElement_int(::default1, \old(token_ind)-1)
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, \new(ch)-1))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, \new(token_ind)))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, \new(token_ind)-1))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, ch-1))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, token_ind))
daikon.Quant.getElement_int(::default1, \old(ch)) == \old(daikon.Quant.getElement_int(::default1, token_ind-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(tstream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.[0]"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.fp"), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), 22)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(token_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_id"), 18)
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(token_ptr, "token_string"), new String[] { "0" })
daikon.Quant.eltsEqual(daikon.Quant.collectObject(token_ptr, "token_string"), "0")
return != null
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(return) == 1
daikon.Quant.getElement_int(::default1, \old(ch)) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)), new long[] { 17, 54 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, \old(ch)) == -99
daikon.Quant.getElement_int(::base, \old(ch)-1) == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::base, \old(token_ind)) == -93
daikon.Quant.getElement_int(::base, \old(token_ind)-1) == -105
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::base, 0, \old(token_ind)-1), new long[] { -105, -96, -32 })
daikon.Quant.getElement_int(::next, \old(ch)) == 6
daikon.Quant.getElement_int(::next, \old(ch)-1) == 20
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, \old(token_ind)) == 28
daikon.Quant.getElement_int(::next, \old(token_ind)-1) == 26
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)-1), new long[] { 0, 2, 26 })
daikon.Quant.getElement_int(::check, \old(ch)) == 5
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::check, 0, \old(token_ind)), new long[] { 0, 1 })
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::default1 )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::base )
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), ::next)
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), ::next)
daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), ::next)
daikon.Quant.memberOf(\old(ch) , ::next )
daikon.Quant.memberOf(\old(token_ind) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , ::next )
daikon.Quant.memberOf(daikon.Quant.size(return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , ::next )
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), ::check)
daikon.Quant.memberOf(\old(ch) , ::check )
daikon.Quant.memberOf(\old(token_ind) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(return) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)-1) , ::check )
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(ch)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(ch)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: tstream_ptr[].ch_stream->stream_ind is a subsequence of ::next[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind"), daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[orig(ch)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[orig(ch)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::next[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::check[orig(ch)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::check[orig(ch)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::check[orig(token_ind)..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: token_ptr[].token_id is a subsequence of ::check[orig(token_ind)+1..]
daikon.Quant.subsetOf(daikon.Quant.collectObject(token_ptr, "token_id"), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: orig(tstream_ptr[].ch_stream->stream_ind) is a subsequence of ::next[0..orig(ch)]
daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.slice(::next, 0, \old(ch)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: orig(tstream_ptr[].ch_stream->stream_ind) is a subsequence of ::next[0..orig(ch)-1]
daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.slice(::next, 0, \old(ch)-1))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: orig(tstream_ptr[].ch_stream->stream_ind) is a subsequence of ::next[orig(token_ind)..]
daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)))
warning: method daikon.inv.binary.twoSequence.SubSequence.format(OutputFormat:JML) needs to be implemented: orig(tstream_ptr[].ch_stream->stream_ind) is a subsequence of ::next[orig(token_ind)+1..]
daikon.Quant.subsetOf(\old(daikon.Quant.collectObject(tstream_ptr, "ch_stream.stream_ind")), daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)))
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(ch) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::check, 0, \old(ch)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::check, 0, \old(ch)-1) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(\old(token_ind) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, \old(ch), daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, \old(ch)+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, \old(token_ind), daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::base, \old(token_ind)+1, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(token_ind)) )
daikon.Quant.memberOf(daikon.Quant.size(tstream_ptr)-1 , daikon.Quant.slice(::next, 0, \old(token_ind)-1) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::check, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::check, 0, \old(ch)-1) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::check, 0, \old(token_ind)) )
daikon.Quant.memberOf(daikon.Quant.size(return) , daikon.Quant.slice(::check, 0, \old(token_ind)-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, \old(ch)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::default1, \old(ch), daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::default1, \old(ch)+1, daikon.Quant.size(::default1)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)-1), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)-1), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)-1), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(ch)-1), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::default1, \old(token_ind), daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::default1, \old(token_ind)+1, daikon.Quant.size(::default1)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(ch)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, \old(ch)-1) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, 0, \old(ch)-1) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)-1) , daikon.Quant.slice(::check, \old(ch), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)-1) , daikon.Quant.slice(::check, \old(ch)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)-1) , daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, \old(token_ind)-1) , daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, \old(token_ind), daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, \old(ch)) , daikon.Quant.slice(::next, \old(token_ind)+1, daikon.Quant.size(::next)) )
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(token_ind), daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::next, 0, \old(token_ind)-1), daikon.Quant.slice(::check, \old(token_ind)+1, daikon.Quant.size(::check)))
===========================================================================
print_tokens.c.skip():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
stream_ptr != null
stream_ptr != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.size(stream_ptr) == 1
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::next )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr) , ::check )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::check )
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(stream_ptr))
===========================================================================
print_tokens.c.skip():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] stream_ptr stream_ptr[] stream_ptr[].fp stream_ptr[].fp[0] stream_ptr[].stream_ind stream_ptr[].stream return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(stream_ptr) orig(stream_ptr[]) orig(stream_ptr[].fp) orig(stream_ptr[].fp[0]) orig(stream_ptr[].stream_ind) orig(stream_ptr[].stream) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 size(stream_ptr[]) size(stream_ptr[])-1 size(stream_ptr[].fp[0]) size(stream_ptr[].fp[0])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 orig(size(stream_ptr[])) orig(size(stream_ptr[]))-1 orig(size(stream_ptr[].fp[0])) orig(size(stream_ptr[].fp[0]))-1 ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] stream_ptr[return] stream_ptr[return-1] stream_ptr[return..] stream_ptr[return+1..] stream_ptr[0..return] stream_ptr[0..return-1] stream_ptr[return].fp stream_ptr[return-1].fp stream_ptr[return..].fp stream_ptr[return+1..].fp stream_ptr[0..return].fp stream_ptr[0..return-1].fp stream_ptr[return].fp[0] stream_ptr[return-1].fp[0] stream_ptr[return..].fp[0] stream_ptr[return+1..].fp[0] stream_ptr[0..return].fp[0] stream_ptr[0..return-1].fp[0] stream_ptr[return].stream_ind stream_ptr[return-1].stream_ind stream_ptr[return..].stream_ind stream_ptr[return+1..].stream_ind stream_ptr[0..return].stream_ind stream_ptr[0..return-1].stream_ind orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(stream_ptr[post(return)]) orig(stream_ptr[post(return)-1]) orig(stream_ptr[post(return)..]) orig(stream_ptr[post(return)+1..]) orig(stream_ptr[0..post(return)]) orig(stream_ptr[0..post(return)-1]) orig(stream_ptr[post(return)].fp) orig(stream_ptr[post(return)-1].fp) orig(stream_ptr[post(return)..].fp) orig(stream_ptr[post(return)+1..].fp) orig(stream_ptr[0..post(return)].fp) orig(stream_ptr[0..post(return)-1].fp) orig(stream_ptr[post(return)].fp[0]) orig(stream_ptr[post(return)-1].fp[0]) orig(stream_ptr[post(return)..].fp[0]) orig(stream_ptr[post(return)+1..].fp[0]) orig(stream_ptr[0..post(return)].fp[0]) orig(stream_ptr[0..post(return)-1].fp[0]) orig(stream_ptr[post(return)].stream_ind) orig(stream_ptr[post(return)-1].stream_ind) orig(stream_ptr[post(return)..].stream_ind) orig(stream_ptr[post(return)+1..].stream_ind) orig(stream_ptr[0..post(return)].stream_ind) orig(stream_ptr[0..post(return)-1].stream_ind)
assignable stream_ptr[].fp[0], stream_ptr[].stream_ind, stream_ptr[].stream
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
daikon.Quant.pairwiseEqual(stream_ptr, \old(stream_ptr))
daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(stream_ptr, "fp"), \old(daikon.Quant.collectObject(stream_ptr, "fp")))
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.size(stream_ptr)-1 == daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(stream_ptr)-1 == \old(daikon.Quant.getElement_int(::check, \new(return)-1))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::default1, \new(return)-1))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::base)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
daikon.Quant.eltsNotEqual(stream_ptr, null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(stream_ptr, "fp"), null)
daikon.Quant.eltsGtIndex(daikon.Quant.collectObject(stream_ptr, "stream_ind"))
return == 10
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == 17
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), new long[] { 17, 54 })
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, return))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltwiseGTE(daikon.Quant.slice(::default1, 0, return-1))
daikon.Quant.getElement_int(::base, return) == -99
daikon.Quant.getElement_int(::base, return-1) == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::next, return) == 6
daikon.Quant.getElement_int(::next, return-1) == 20
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::next, return, daikon.Quant.size(::next)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.getElement_int(::check, return) == 5
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(::default1, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , ::default1 )
daikon.Quant.lexLT(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::base, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLT(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::base, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::base )
daikon.Quant.lexLT(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::next, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.memberOf(return , ::next )
daikon.Quant.lexLT(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::next, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , ::next )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.eltsGT(::next, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.lexLT(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.lexLTE(::check, daikon.Quant.collectObject(stream_ptr, "stream_ind"))
daikon.Quant.memberOf(return , ::check )
daikon.Quant.lexLT(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.lexLTE(::check, \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , ::check )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsGT(::check, daikon.Quant.getElement_int(::base, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), return)
warning: method daikon.inv.binary.twoSequence.PairwiseLinearBinary.format(OutputFormat:JML) needs to be implemented: stream_ptr[].stream_ind - orig(stream_ptr[].stream_ind) - 1 == 0
daikon.Quant.pairwiseGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.collectObject(stream_ptr, "stream_ind")))
daikon.Quant.eltsLTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), \old(daikon.Quant.size(stream_ptr)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)))
daikon.Quant.lexGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.eltsGT(daikon.Quant.collectObject(stream_ptr, "stream_ind"), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), return)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), return)
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), return)
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(return , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.eltsLT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.size(::next)-1)
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.lexGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)))
daikon.Quant.lexGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)))
daikon.Quant.lexGTE(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.eltsGT(\old(daikon.Quant.collectObject(stream_ptr, "stream_ind")), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(::default1)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::base, return, daikon.Quant.size(::base)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.size(stream_ptr)-1 , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.size(stream_ptr)-1)
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), \old(daikon.Quant.size(stream_ptr)))
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, return) )
daikon.Quant.memberOf(\old(daikon.Quant.size(stream_ptr)) , daikon.Quant.slice(::check, 0, return-1) )
daikon.Quant.eltsGTE(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::default1, return+1, daikon.Quant.size(::default1)) )
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::base, 0, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.getElement_int(::check, return))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::base, 0, return-1))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return, daikon.Quant.size(::check)))
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)))
daikon.Quant.pairwiseGT(daikon.Quant.slice(::default1, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, return, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsGT(daikon.Quant.slice(::base, return+1, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::base, return))
daikon.Quant.eltsLTE(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.eltsGT(daikon.Quant.slice(::next, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::base, return-1) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.eltsGT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::next, 0, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.getElement_int(::check, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::next, 0, return-1))
daikon.Quant.pairwiseLT(daikon.Quant.slice(::base, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::check, return))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return-1), daikon.Quant.getElement_int(::check, return))
===========================================================================
print_tokens.c.special():::ENTER
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1]
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.getElement_int(::default1, state) == daikon.Quant.getElement_int(::base, state)
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, state) == -1
daikon.Quant.getElement_int(::default1, state-1) == -2 || daikon.Quant.getElement_int(::default1, state-1) == -1
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, state, daikon.Quant.size(::default1)), new long[] { -3, -1, 52 })
daikon.Quant.getElement_int(::base, state-1) == -1 || daikon.Quant.getElement_int(::base, state-1) == 0 || daikon.Quant.getElement_int(::base, state-1) == 43
daikon.Quant.getElement_int(::next, state) == 16 || daikon.Quant.getElement_int(::next, state) == 18
daikon.Quant.getElement_int(::next, state) % 2 == 0
daikon.Quant.getElement_int(::next, state-1) == 15 || daikon.Quant.getElement_int(::next, state-1) == 18
daikon.Quant.getElement_int(::check, state) == 0 || daikon.Quant.getElement_int(::check, state) == 15
daikon.Quant.getElement_int(::check, state-1) == 0 || daikon.Quant.getElement_int(::check, state-1) == 14
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(state , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::default1, state))
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::default1, state-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::default1, state))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::default1, state-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, state-1) , ::check )
(daikon.Quant.size(::default1) >> state == 0)
(daikon.Quant.size(::default1)-1 >> state == 0)
state < daikon.Quant.size(::default1)-1
(daikon.Quant.size(::next) >> state == 0)
(daikon.Quant.size(::next)-1 >> state == 0)
state < daikon.Quant.size(::next)-1
state > daikon.Quant.getElement_int(::default1, state)
state > daikon.Quant.getElement_int(::default1, state-1)
state != daikon.Quant.getElement_int(::base, state-1)
(state >> daikon.Quant.getElement_int(::next, state) == 0)
state > daikon.Quant.getElement_int(::next, state)
(state >> daikon.Quant.getElement_int(::next, state-1) == 0)
state > daikon.Quant.getElement_int(::next, state-1)
(state & daikon.Quant.getElement_int(::check, state)) == 0
state > daikon.Quant.getElement_int(::check, state)
(state & daikon.Quant.getElement_int(::check, state-1)) == 0
state > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state), state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, state-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, state)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, state)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, state)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::default1, state) >= daikon.Quant.getElement_int(::default1, state-1)
daikon.Quant.getElement_int(::default1, state) <= daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, state, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::default1, state))
daikon.Quant.getElement_int(::default1, state) < daikon.Quant.getElement_int(::next, state)
daikon.Quant.getElement_int(::default1, state) < daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, 0, state) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::next, 0, state-1) )
daikon.Quant.getElement_int(::default1, state) < daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::default1, state) < daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, state, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, state+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, 0, state) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, state) , daikon.Quant.slice(::check, 0, state-1) )
daikon.Quant.getElement_int(::default1, state-1) <= daikon.Quant.getElement_int(::base, state-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, state, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::default1, state-1))
daikon.Quant.getElement_int(::default1, state-1) < daikon.Quant.getElement_int(::next, state)
daikon.Quant.getElement_int(::default1, state-1) < daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.getElement_int(::default1, state-1) < daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::default1, state-1) < daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::base, state-1) != daikon.Quant.getElement_int(::next, state)
daikon.Quant.getElement_int(::base, state-1) != daikon.Quant.getElement_int(::next, state-1)
(daikon.Quant.getElement_int(::base, state-1) & daikon.Quant.getElement_int(::check, state)) == 0
daikon.Quant.getElement_int(::base, state-1) != daikon.Quant.getElement_int(::check, state)
(daikon.Quant.getElement_int(::base, state-1) & daikon.Quant.getElement_int(::check, state-1)) == 0
daikon.Quant.getElement_int(::base, state-1) != daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::next, state) >= daikon.Quant.getElement_int(::next, state-1)
daikon.Quant.getElement_int(::next, state) > daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::next, state) > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state), daikon.Quant.getElement_int(::next, state))
daikon.Quant.getElement_int(::next, state-1) >= daikon.Quant.getElement_int(::check, state)
daikon.Quant.getElement_int(::next, state-1) > daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, state-1) , daikon.Quant.slice(::check, state, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, state), daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, state-1), daikon.Quant.getElement_int(::next, state-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state-1) , daikon.Quant.slice(::next, state, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state-1) , daikon.Quant.slice(::next, state+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, state) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, state), daikon.Quant.slice(::check, 0, state))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, state) , daikon.Quant.slice(::next, 0, state-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, state-1), daikon.Quant.slice(::check, 0, state-1))
daikon.Quant.getElement_int(::check, state) >= daikon.Quant.getElement_int(::check, state-1)
daikon.Quant.getElement_int(::default1, state) == (daikon.Quant.getElement_int(::default1, state-1) >> state)
daikon.Quant.getElement_int(::default1, state) == (state | daikon.Quant.getElement_int(::default1, state-1))
daikon.Quant.getElement_int(::default1, state) == (daikon.Quant.getElement_int(::default1, state-1) | daikon.Quant.getElement_int(::base, state-1))
daikon.Quant.getElement_int(::check, state) == (daikon.Quant.getElement_int(::next, state-1) % daikon.Quant.getElement_int(::next, state))
===========================================================================
print_tokens.c.special():::EXIT
    Variables: ::default1 ::default1[] ::base ::base[] ::next ::next[] ::check ::check[] state return orig(::default1) orig(::default1[]) orig(::base) orig(::base[]) orig(::next) orig(::next[]) orig(::check) orig(::check[]) orig(state) size(::default1[]) size(::default1[])-1 size(::base[]) size(::base[])-1 size(::next[]) size(::next[])-1 size(::check[]) size(::check[])-1 orig(size(::default1[])) orig(size(::default1[]))-1 orig(size(::base[])) orig(size(::base[]))-1 orig(size(::next[])) orig(size(::next[]))-1 orig(size(::check[])) orig(size(::check[]))-1 ::default1[state] ::default1[state-1] ::default1[state..] ::default1[state+1..] ::default1[0..state] ::default1[0..state-1] ::default1[return] ::default1[return-1] ::default1[return..] ::default1[return+1..] ::default1[0..return] ::default1[0..return-1] ::default1[orig(state)] ::default1[orig(state)-1] ::default1[orig(state)..] ::default1[orig(state)+1..] ::default1[0..orig(state)] ::default1[0..orig(state)-1] ::base[state] ::base[state-1] ::base[state..] ::base[state+1..] ::base[0..state] ::base[0..state-1] ::base[return] ::base[return-1] ::base[return..] ::base[return+1..] ::base[0..return] ::base[0..return-1] ::base[orig(state)] ::base[orig(state)-1] ::base[orig(state)..] ::base[orig(state)+1..] ::base[0..orig(state)] ::base[0..orig(state)-1] ::next[state] ::next[state-1] ::next[state..] ::next[state+1..] ::next[0..state] ::next[0..state-1] ::next[return] ::next[return-1] ::next[return..] ::next[return+1..] ::next[0..return] ::next[0..return-1] ::next[orig(state)] ::next[orig(state)-1] ::next[orig(state)..] ::next[orig(state)+1..] ::next[0..orig(state)] ::next[0..orig(state)-1] ::check[state] ::check[state-1] ::check[state..] ::check[state+1..] ::check[0..state] ::check[0..state-1] ::check[return] ::check[return-1] ::check[return..] ::check[return+1..] ::check[0..return] ::check[0..return-1] ::check[orig(state)] ::check[orig(state)-1] ::check[orig(state)..] ::check[orig(state)+1..] ::check[0..orig(state)] ::check[0..orig(state)-1] orig(::default1[post(state)]) orig(::default1[post(state)-1]) orig(::default1[post(state)..]) orig(::default1[post(state)+1..]) orig(::default1[0..post(state)]) orig(::default1[0..post(state)-1]) orig(::base[post(state)]) orig(::base[post(state)-1]) orig(::base[post(state)..]) orig(::base[post(state)+1..]) orig(::base[0..post(state)]) orig(::base[0..post(state)-1]) orig(::next[post(state)]) orig(::next[post(state)-1]) orig(::next[post(state)..]) orig(::next[post(state)+1..]) orig(::next[0..post(state)]) orig(::next[0..post(state)-1]) orig(::check[post(state)]) orig(::check[post(state)-1]) orig(::check[post(state)..]) orig(::check[post(state)+1..]) orig(::check[0..post(state)]) orig(::check[0..post(state)-1]) orig(::default1[post(return)]) orig(::default1[post(return)-1]) orig(::default1[post(return)..]) orig(::default1[post(return)+1..]) orig(::default1[0..post(return)]) orig(::default1[0..post(return)-1]) orig(::base[post(return)]) orig(::base[post(return)-1]) orig(::base[post(return)..]) orig(::base[post(return)+1..]) orig(::base[0..post(return)]) orig(::base[0..post(return)-1]) orig(::next[post(return)]) orig(::next[post(return)-1]) orig(::next[post(return)..]) orig(::next[post(return)+1..]) orig(::next[0..post(return)]) orig(::next[0..post(return)-1]) orig(::check[post(return)]) orig(::check[post(return)-1]) orig(::check[post(return)..]) orig(::check[post(return)+1..]) orig(::check[0..post(return)]) orig(::check[0..post(return)-1]) orig(::default1[state]) orig(::default1[state-1]) orig(::default1[state..]) orig(::default1[state+1..]) orig(::default1[0..state]) orig(::default1[0..state-1]) orig(::base[state]) orig(::base[state-1]) orig(::base[state..]) orig(::base[state+1..]) orig(::base[0..state]) orig(::base[0..state-1]) orig(::next[state]) orig(::next[state-1]) orig(::next[state..]) orig(::next[state+1..]) orig(::next[0..state]) orig(::next[0..state-1]) orig(::check[state]) orig(::check[state-1]) orig(::check[state..]) orig(::check[state+1..]) orig(::check[0..state]) orig(::check[0..state-1])
::default1 == \old(::default1)
daikon.Quant.pairwiseEqual(::default1, \old(::default1))
::base == \old(::base)
daikon.Quant.pairwiseEqual(::base, \old(::base))
::next == \old(::next)
daikon.Quant.pairwiseEqual(::next, \old(::next))
::check == \old(::check)
daikon.Quant.pairwiseEqual(::check, \old(::check))
return == \old(state)
daikon.Quant.size(::default1) == daikon.Quant.size(::base)
daikon.Quant.size(::default1) == \old(daikon.Quant.size(::base))
daikon.Quant.size(::next) == daikon.Quant.size(::check)
daikon.Quant.size(::next) == \old(daikon.Quant.size(::check))
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::base, return)
daikon.Quant.getElement_int(::default1, return) == daikon.Quant.getElement_int(::base, \old(state))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, \new(state)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, \new(return)))
daikon.Quant.getElement_int(::default1, return) == \old(daikon.Quant.getElement_int(::base, state))
::default1 != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsNotEqualIndex(::default1)
::base != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
::next != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::next, -1)
::check != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::check, -1)
daikon.Quant.size(::default1) == 60
daikon.Quant.size(::next) == 360
daikon.Quant.getElement_int(::default1, return) == -1
daikon.Quant.getElement_int(::default1, return-1) == -2 || daikon.Quant.getElement_int(::default1, return-1) == -1
daikon.Quant.subsetOf(daikon.Quant.slice(::default1, return, daikon.Quant.size(::default1)), new long[] { -3, -1, 52 })
daikon.Quant.getElement_int(::base, return-1) == -1 || daikon.Quant.getElement_int(::base, return-1) == 0 || daikon.Quant.getElement_int(::base, return-1) == 43
daikon.Quant.getElement_int(::next, return) == 16 || daikon.Quant.getElement_int(::next, return) == 18
daikon.Quant.getElement_int(::next, return) % 2 == 0
daikon.Quant.getElement_int(::next, return-1) == 15 || daikon.Quant.getElement_int(::next, return-1) == 18
daikon.Quant.getElement_int(::check, return) == 0 || daikon.Quant.getElement_int(::check, return) == 15
daikon.Quant.getElement_int(::check, return-1) == 0 || daikon.Quant.getElement_int(::check, return-1) == 14
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::default1, daikon.Quant.size(::next)-1)
daikon.Quant.eltsLT(::base, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(return , ::next )
daikon.Quant.eltsLT(::next, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::next, daikon.Quant.size(::next)-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::next )
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::default1, return))
daikon.Quant.eltsGTE(::next, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , ::next )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , ::next )
daikon.Quant.eltsLT(::check, daikon.Quant.size(::default1)-1)
daikon.Quant.eltsLT(::check, daikon.Quant.size(::next)-1)
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::default1, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , ::check )
daikon.Quant.eltsGTE(::check, daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return-1) , ::check )
(daikon.Quant.size(::default1) >> return == 0)
(daikon.Quant.size(::default1)-1 >> return == 0)
return < daikon.Quant.size(::default1)-1
(daikon.Quant.size(::next) >> return == 0)
(daikon.Quant.size(::next)-1 >> return == 0)
return < daikon.Quant.size(::next)-1
return > daikon.Quant.getElement_int(::default1, return)
return > daikon.Quant.getElement_int(::default1, return-1)
return != daikon.Quant.getElement_int(::base, return-1)
(return >> daikon.Quant.getElement_int(::next, return) == 0)
return > daikon.Quant.getElement_int(::next, return)
(return >> daikon.Quant.getElement_int(::next, return-1) == 0)
return > daikon.Quant.getElement_int(::next, return-1)
(return & daikon.Quant.getElement_int(::check, return)) == 0
return > daikon.Quant.getElement_int(::check, return)
(return & daikon.Quant.getElement_int(::check, return-1)) == 0
return > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::default1)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return)
daikon.Quant.size(::next)-1 > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::default1, return) >= daikon.Quant.getElement_int(::default1, return-1)
daikon.Quant.getElement_int(::default1, return) <= daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, return, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::default1, return))
daikon.Quant.getElement_int(::default1, return) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::default1, return) < daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.getElement_int(::default1, return) < daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::default1, return) < daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, return+1, daikon.Quant.size(::check)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, 0, return) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::default1, return) , daikon.Quant.slice(::check, 0, return-1) )
daikon.Quant.getElement_int(::default1, return-1) <= daikon.Quant.getElement_int(::base, return-1)
daikon.Quant.eltsGTE(daikon.Quant.slice(::base, return, daikon.Quant.size(::base)), daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return-1) < daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::default1, return-1) < daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::default1, return-1) < daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::default1, return-1) < daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, return)
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::next, return-1)
(daikon.Quant.getElement_int(::base, return-1) & daikon.Quant.getElement_int(::check, return)) == 0
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, return)
(daikon.Quant.getElement_int(::base, return-1) & daikon.Quant.getElement_int(::check, return-1)) == 0
daikon.Quant.getElement_int(::base, return-1) != daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::next, return) >= daikon.Quant.getElement_int(::next, return-1)
daikon.Quant.getElement_int(::next, return) > daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return))
daikon.Quant.getElement_int(::next, return-1) >= daikon.Quant.getElement_int(::check, return)
daikon.Quant.getElement_int(::next, return-1) > daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.memberOf(daikon.Quant.getElement_int(::next, return-1) , daikon.Quant.slice(::check, return, daikon.Quant.size(::check)) )
daikon.Quant.eltsLTE(daikon.Quant.slice(::check, 0, return), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.eltsLT(daikon.Quant.slice(::check, 0, return-1), daikon.Quant.getElement_int(::next, return-1))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , daikon.Quant.slice(::next, return, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return-1) , daikon.Quant.slice(::next, return+1, daikon.Quant.size(::next)) )
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return), daikon.Quant.slice(::check, 0, return))
daikon.Quant.memberOf(daikon.Quant.getElement_int(::check, return) , daikon.Quant.slice(::next, 0, return-1) )
daikon.Quant.pairwiseGTE(daikon.Quant.slice(::next, 0, return-1), daikon.Quant.slice(::check, 0, return-1))
daikon.Quant.getElement_int(::check, return) >= daikon.Quant.getElement_int(::check, return-1)
daikon.Quant.getElement_int(::default1, return) == (daikon.Quant.getElement_int(::default1, return-1) >> return)
daikon.Quant.getElement_int(::default1, return) == (return | daikon.Quant.getElement_int(::default1, return-1))
daikon.Quant.getElement_int(::default1, return) == (daikon.Quant.getElement_int(::default1, return-1) | daikon.Quant.getElement_int(::base, return-1))
daikon.Quant.getElement_int(::check, return) == (daikon.Quant.getElement_int(::next, return-1) % daikon.Quant.getElement_int(::next, return))
