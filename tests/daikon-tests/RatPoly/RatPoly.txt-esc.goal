===========================================================================
PolyCalc.RatNum:::OBJECT
    Variables: this this.numer this.denom
this.denom >= 0
===========================================================================
PolyCalc.RatNum.RatNum(int):::ENTER
    Variables: n
===========================================================================
PolyCalc.RatNum.RatNum(int):::EXIT
    Variables: this this.numer this.denom n orig(n)
      Unmodified variables: n
this.numer == \old(n)
this.denom == 1
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::ENTER
    Variables: n d
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT55
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
this.numer == \old(n)
this.denom == \old(d)
this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT67
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
this.denom >= 1
\old(d) != 0
\old(d) % this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
(this.denom == 0)  ==  (\old(d) == 0)
(this.denom == 0)  ==>  (\old(d) is a pointer)
(this.denom == 0)  ==>  (this.denom == \old(d))
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer == \old(n))
(\old(n) == 0) ==> (this.numer == 0)
(this.numer == 0) ==> (\old(n) == 0)
(\old(d) == 0) ==> (this.denom == 0)
(this.denom == 0) ==> (\old(d) == 0)
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.denom == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.approx():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT117
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 0
\result == Double.NaN
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT120
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom >= 1
===========================================================================
PolyCalc.RatNum.approx():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(this.denom == 0)  ==>  (\result == Double.NaN)
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer != this.denom)
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom rn rn.numer rn.denom
rn != null
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT101
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom >= 1
rn.denom >= 1
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT94
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom == \result
rn.denom == \result
\result == \old(this.denom)
\result == \old(rn.denom)
\result == 0
this.numer != \result
rn.numer != \result
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT96
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom == 0
rn.numer >= -1
rn.denom >= 1
\result == 1
this.numer != this.denom
this.denom < rn.denom
rn.denom >= \result
warning: method daikon.inv.ternary.threeScalar.FunctionBinary$GcdLong_zxy.format(OutputFormat:ESC/Java) needs to be implemented: return == (plume.MathMDE.gcd(rn.numer, rn.denom))
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT98
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom >= 1
rn.numer != 0
rn.denom == 0
\result == -1
this.denom > rn.denom
this.denom > \result
rn.numer != rn.denom
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.debugPrint():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.debugPrint():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT187
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.numer == \result.numer
arg.denom == \result.denom
\result == \old(arg)
arg.denom == 0
(arg.numer == 0) ==> (this.numer == 0)
this.denom >= arg.denom
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT189
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 1
(this.numer == 0) ==> (\result.numer == 0)
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
(arg.denom == 0)  ==>  ((arg.numer == 0) ==> (this.numer == 0))
(arg.denom == 0)  ==>  (arg.denom == \result.denom)
(arg.denom == 0)  ==>  (arg.denom is a pointer)
(arg.denom == 0)  ==>  (arg.numer == \result.numer)
(arg.denom == 0)  ==>  (\result == \old(arg))
(arg.denom == 0)  ==>  (\result.denom == 0)
(arg.denom == 0)  ==>  (\result.denom is a pointer)
(arg.denom == 0)  ==>  (this.denom >= arg.denom)
(arg.denom == 0)  ==>  (this.denom >= \result.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(\result.numer == 0) ==> (this.numer == 0)
(this.denom == 0) ==> (\result.denom == 0)
(arg.numer == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::ENTER
    Variables: this this.numer this.denom obj obj.getClass().getName()
obj != null
\typeof(obj) == \type(PolyCalc.RatNum)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT230
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
this.denom == 0
\result == true
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT232
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
(\result == true)  ==>  (this.denom >= 1)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
===========================================================================
PolyCalc.RatNum.gcd(int, int):::ENTER
    Variables: _a _b
_b != 0
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT209
    Variables: _a _b return orig(_a) orig(_b)
      Unmodified variables: _a _b
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT
    Variables: _a _b return orig(_a) orig(_b)
      Unmodified variables: _a _b
\result != 0
\old(_a) % \result == 0
\old(_b) % \result == 0
===========================================================================
PolyCalc.RatNum.isNaN():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNaN():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(this.denom == 0)  ==  (\result == true)
(this.denom == 0)  ==>  (this.denom is a pointer)
===========================================================================
PolyCalc.RatNum.isNegative():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNegative():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(\result == true)  ==>  (this.denom >= 1)
(\result == true)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer <= -1)
===========================================================================
PolyCalc.RatNum.isPositive():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isPositive():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(\result == false)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer != 0)
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.numer == 0) ==> (\result.numer == 0)
(this.denom == 0) ==> (\result.denom == 0)
(arg.numer == 0) ==> (\result.numer == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.negate():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.negate():::EXIT
    Variables: this this.numer this.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == \result.denom
\result != null
(\result.numer == 0) ==> (this.numer == 0)
(this.numer == 0) ==> (\result.numer == 0)
this.numer + \result.numer == 0
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::ENTER
    Variables: ratStr ratStr.toString
ratStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString is printable
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT264
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString == "NaN"
\result.numer == 1
\result.denom == 0
\old(ratStr) != null
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT267
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
\result.denom == 1
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT273
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString is printable
\result != null
\result.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.denom == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.toString():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.toString():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.unparse():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT133
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 0
\result != null
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString == "NaN"
===========================================================================
PolyCalc.RatNum.unparse():::EXIT135
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.numer != 0
this.denom >= 2
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT137
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 1
===========================================================================
PolyCalc.RatNum.unparse():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly:::OBJECT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
this.terms != null
this.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] contains no duplicates
this.terms.wrapped.containsNull == false
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::ENTER
    Variables: rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() size(rt.wrapped[]) size(rt.wrapped[])-1
rt != null
rt.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: rt.wrapped[] contains no duplicates
rt.wrapped.containsNull == false
rt.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() orig(rt) orig(rt.wrapped) orig(rt.wrapped[]) orig(rt.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(rt.wrapped[]) size(rt.wrapped[])-1 orig(size(rt.wrapped[])) orig(size(rt.wrapped[]))-1
      Unmodified variables: rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() size(rt.wrapped[])
this.terms == \old(rt)
this.terms.wrapped == rt.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == rt.wrapped[]
rt.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: rt.wrapped[] contains no duplicates
rt.wrapped.containsNull == false
rt.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::ENTER
    Variables: c e
e >= 0
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() c e orig(c) orig(e) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 this.terms.wrapped[c] this.terms.wrapped[c-1] this.terms.wrapped[c..] this.terms.wrapped[c+1..] this.terms.wrapped[0..c] this.terms.wrapped[0..c-1] this.terms.wrapped[e] this.terms.wrapped[e-1] this.terms.wrapped[e..] this.terms.wrapped[e+1..] this.terms.wrapped[0..e] this.terms.wrapped[0..e-1] this.terms.wrapped[orig(c)] this.terms.wrapped[orig(c)-1] this.terms.wrapped[orig(c)..] this.terms.wrapped[orig(c)+1..] this.terms.wrapped[0..orig(c)] this.terms.wrapped[0..orig(c)-1] this.terms.wrapped[orig(e)] this.terms.wrapped[orig(e)-1] this.terms.wrapped[orig(e)..] this.terms.wrapped[orig(e)+1..] this.terms.wrapped[0..orig(e)] this.terms.wrapped[0..orig(e)-1]
      Unmodified variables: c e
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (orig(c) == 0) ==> (size(this.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (orig(c) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (orig(c) & size(this.terms.wrapped[])-1) == 0
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(c) != size(this.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(e) >= size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT350
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == return.terms.wrapped[]
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 >= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT354
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] == return.terms.wrapped[]
\result == \old(p)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT363
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[])-1 <= size(return.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::ENTER
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
sb != null
rt != null
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(rt.coeff.denom == 0) ==> (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT229
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
      Unmodified variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
      Unmodified variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(rt.coeff.denom == 0) ==> (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::ENTER
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() size(v.wrapped[]) size(v.wrapped[])-1
v != null
v.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: v.wrapped[] contains no duplicates
v.wrapped.containsNull == false
v.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::EXIT
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() orig(v) orig(v.wrapped) orig(v.wrapped[]) orig(v.wrapped[].getClass().getName()) size(v.wrapped[]) size(v.wrapped[])-1 orig(size(v.wrapped[])) orig(size(v.wrapped[]))-1
      Unmodified variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() size(v.wrapped[])
v.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: v.wrapped[] contains no duplicates
v.wrapped.containsNull == false
v.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.checkRep():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.checkRep():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.coeff(int):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1]
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT120
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1] this.terms.wrapped[return.numer] this.terms.wrapped[return.numer-1] this.terms.wrapped[return.numer..] this.terms.wrapped[return.numer+1..] this.terms.wrapped[0..return.numer] this.terms.wrapped[0..return.numer-1] this.terms.wrapped[return.denom] this.terms.wrapped[return.denom-1] this.terms.wrapped[return.denom..] this.terms.wrapped[return.denom+1..] this.terms.wrapped[0..return.denom] this.terms.wrapped[0..return.denom-1] this.terms.wrapped[orig(deg)] this.terms.wrapped[orig(deg)-1] this.terms.wrapped[orig(deg)..] this.terms.wrapped[orig(deg)+1..] this.terms.wrapped[0..orig(deg)] this.terms.wrapped[0..orig(deg)-1] orig(this.terms.wrapped[post(deg)]) orig(this.terms.wrapped[post(deg)-1]) orig(this.terms.wrapped[post(deg)..]) orig(this.terms.wrapped[post(deg)+1..]) orig(this.terms.wrapped[0..post(deg)]) orig(this.terms.wrapped[0..post(deg)-1]) orig(this.terms.wrapped[post(return.numer)]) orig(this.terms.wrapped[post(return.numer)-1]) orig(this.terms.wrapped[post(return.numer)..]) orig(this.terms.wrapped[post(return.numer)+1..]) orig(this.terms.wrapped[0..post(return.numer)]) orig(this.terms.wrapped[0..post(return.numer)-1]) orig(this.terms.wrapped[post(return.denom)]) orig(this.terms.wrapped[post(return.denom)-1]) orig(this.terms.wrapped[post(return.denom)..]) orig(this.terms.wrapped[post(return.denom)+1..]) orig(this.terms.wrapped[0..post(return.denom)]) orig(this.terms.wrapped[0..post(return.denom)-1]) orig(this.terms.wrapped[deg]) orig(this.terms.wrapped[deg-1]) orig(this.terms.wrapped[deg..]) orig(this.terms.wrapped[deg+1..]) orig(this.terms.wrapped[0..deg]) orig(this.terms.wrapped[0..deg-1])
      Modified primitive arguments: this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1]
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
\result.numer != 0
\old(deg) >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT124
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1] this.terms.wrapped[return.numer] this.terms.wrapped[return.numer-1] this.terms.wrapped[return.numer..] this.terms.wrapped[return.numer+1..] this.terms.wrapped[0..return.numer] this.terms.wrapped[0..return.numer-1] this.terms.wrapped[return.denom] this.terms.wrapped[return.denom-1] this.terms.wrapped[return.denom..] this.terms.wrapped[return.denom+1..] this.terms.wrapped[0..return.denom] this.terms.wrapped[0..return.denom-1] this.terms.wrapped[orig(deg)] this.terms.wrapped[orig(deg)-1] this.terms.wrapped[orig(deg)..] this.terms.wrapped[orig(deg)+1..] this.terms.wrapped[0..orig(deg)] this.terms.wrapped[0..orig(deg)-1] orig(this.terms.wrapped[post(deg)]) orig(this.terms.wrapped[post(deg)-1]) orig(this.terms.wrapped[post(deg)..]) orig(this.terms.wrapped[post(deg)+1..]) orig(this.terms.wrapped[0..post(deg)]) orig(this.terms.wrapped[0..post(deg)-1]) orig(this.terms.wrapped[post(return.numer)]) orig(this.terms.wrapped[post(return.numer)-1]) orig(this.terms.wrapped[post(return.numer)..]) orig(this.terms.wrapped[post(return.numer)+1..]) orig(this.terms.wrapped[0..post(return.numer)]) orig(this.terms.wrapped[0..post(return.numer)-1]) orig(this.terms.wrapped[post(return.denom)]) orig(this.terms.wrapped[post(return.denom)-1]) orig(this.terms.wrapped[post(return.denom)..]) orig(this.terms.wrapped[post(return.denom)+1..]) orig(this.terms.wrapped[0..post(return.denom)]) orig(this.terms.wrapped[0..post(return.denom)-1]) orig(this.terms.wrapped[deg]) orig(this.terms.wrapped[deg-1]) orig(this.terms.wrapped[deg..]) orig(this.terms.wrapped[deg+1..]) orig(this.terms.wrapped[0..deg]) orig(this.terms.wrapped[0..deg-1])
      Modified primitive arguments: this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1]
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
\result.numer == 0
\result.denom == 1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[0..return.numer-1] == []
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return.numer <= size(this.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1] this.terms.wrapped[return.numer] this.terms.wrapped[return.numer-1] this.terms.wrapped[return.numer..] this.terms.wrapped[return.numer+1..] this.terms.wrapped[0..return.numer] this.terms.wrapped[0..return.numer-1] this.terms.wrapped[return.denom] this.terms.wrapped[return.denom-1] this.terms.wrapped[return.denom..] this.terms.wrapped[return.denom+1..] this.terms.wrapped[0..return.denom] this.terms.wrapped[0..return.denom-1] this.terms.wrapped[orig(deg)] this.terms.wrapped[orig(deg)-1] this.terms.wrapped[orig(deg)..] this.terms.wrapped[orig(deg)+1..] this.terms.wrapped[0..orig(deg)] this.terms.wrapped[0..orig(deg)-1] orig(this.terms.wrapped[post(deg)]) orig(this.terms.wrapped[post(deg)-1]) orig(this.terms.wrapped[post(deg)..]) orig(this.terms.wrapped[post(deg)+1..]) orig(this.terms.wrapped[0..post(deg)]) orig(this.terms.wrapped[0..post(deg)-1]) orig(this.terms.wrapped[post(return.numer)]) orig(this.terms.wrapped[post(return.numer)-1]) orig(this.terms.wrapped[post(return.numer)..]) orig(this.terms.wrapped[post(return.numer)+1..]) orig(this.terms.wrapped[0..post(return.numer)]) orig(this.terms.wrapped[0..post(return.numer)-1]) orig(this.terms.wrapped[post(return.denom)]) orig(this.terms.wrapped[post(return.denom)-1]) orig(this.terms.wrapped[post(return.denom)..]) orig(this.terms.wrapped[post(return.denom)+1..]) orig(this.terms.wrapped[0..post(return.denom)]) orig(this.terms.wrapped[0..post(return.denom)-1]) orig(this.terms.wrapped[deg]) orig(this.terms.wrapped[deg-1]) orig(this.terms.wrapped[deg..]) orig(this.terms.wrapped[deg+1..]) orig(this.terms.wrapped[0..deg]) orig(this.terms.wrapped[0..deg-1])
      Modified primitive arguments: this.terms.wrapped[deg] this.terms.wrapped[deg-1] this.terms.wrapped[deg..] this.terms.wrapped[deg+1..] this.terms.wrapped[0..deg] this.terms.wrapped[0..deg-1]
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
(\result.numer != 0)  ==>  (\old(deg) >= 0)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer != 0)  ==>  (size(this.terms.wrapped[]) >= 1)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer == 0)  ==>  (orig(this.terms.wrapped[0..post(return.numer)-1]) == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer == 0)  ==>  (orig(this.terms.wrapped[post(return.numer)..]) contains no duplicates)
(\result.numer == 0)  ==>  ((\forall int i; (\result.numer <= i && i <= \old(this.terms.wrapped.length-1)) ==> (\old(this.terms.wrapped[i]) != null)))
(\result.numer == 0)  ==>  (\result.denom == 1)
(\result.numer == 0)  ==>  (\result.numer < \result.denom)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer == 0)  ==>  (return.numer <= size(this.terms.wrapped[]))
(\result.numer == 0)  ==>  (\result.numer is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer == 0)  ==>  (this.terms.wrapped[0..return.numer-1] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer == 0)  ==>  (this.terms.wrapped[return.numer..] contains no duplicates)
(\result.numer == 0)  ==>  ((\forall int i; (\result.numer <= i && i <= this.terms.wrapped.length-1) ==> (this.terms.wrapped[i] != null)))
\result != null
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (return.numer == 0)
(\result.denom == 0) ==> (\old(deg) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (return.denom == 0) ==> (size(this.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.degree():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.degree():::EXIT102
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[return] this.terms.wrapped[return-1] this.terms.wrapped[return..] this.terms.wrapped[return+1..] this.terms.wrapped[0..return] this.terms.wrapped[0..return-1] orig(this.terms.wrapped[post(return)]) orig(this.terms.wrapped[post(return)-1]) orig(this.terms.wrapped[post(return)..]) orig(this.terms.wrapped[post(return)+1..]) orig(this.terms.wrapped[0..post(return)]) orig(this.terms.wrapped[0..post(return)-1])
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (return == 0) ==> (size(this.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.degree():::EXIT105
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[return] this.terms.wrapped[return-1] this.terms.wrapped[return..] this.terms.wrapped[return+1..] this.terms.wrapped[0..return] this.terms.wrapped[0..return-1] orig(this.terms.wrapped[post(return)]) orig(this.terms.wrapped[post(return)-1]) orig(this.terms.wrapped[post(return)..]) orig(this.terms.wrapped[post(return)+1..]) orig(this.terms.wrapped[0..post(return)]) orig(this.terms.wrapped[0..post(return)-1])
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == size(this.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == orig(size(this.terms.wrapped[]))
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
===========================================================================
PolyCalc.RatPoly.degree():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[return] this.terms.wrapped[return-1] this.terms.wrapped[return..] this.terms.wrapped[return+1..] this.terms.wrapped[0..return] this.terms.wrapped[0..return-1] orig(this.terms.wrapped[post(return)]) orig(this.terms.wrapped[post(return)-1]) orig(this.terms.wrapped[post(return)..]) orig(this.terms.wrapped[post(return)+1..]) orig(this.terms.wrapped[0..post(return)]) orig(this.terms.wrapped[0..post(return)-1])
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (orig(this.terms.wrapped[0..post(return)-1]) == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (orig(this.terms.wrapped[post(return)..]) == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return == size(this.terms.wrapped[]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (size(this.terms.wrapped[]) is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[0..return-1] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[].getClass().getName() == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[return..] == [])
\result >= 0
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (return == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: return >= size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(this.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT435
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) <= size(return.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) <= size(return.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[])-1 <= size(return.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT438
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) != size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[])-1 == 0) ==> (size(p.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(this.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.getClass().getName() return[] return[].terms return[].terms.wrapped orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return[]) size(return[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\typeof(\result) == \type(PolyCalc.RatPoly[])
\nonnullelements(\result)
(\forall int i; (0 <= i && i <= \result.length-1) ==> (\result[i].terms != null))
(\forall int i; (0 <= i && i <= \result.length-1) ==> (\result[i].terms.wrapped != null))
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
\result.length == 2
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= size(return[])-1
===========================================================================
PolyCalc.RatPoly.eval(double):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
d >= 0.0
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) & size(this.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.eval(double):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(d) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) & size(this.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[]) size(ts.wrapped[])-1 ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT521
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return] ts.wrapped[return-1] ts.wrapped[return..] ts.wrapped[return+1..] ts.wrapped[0..return] ts.wrapped[0..return-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return)]) orig(ts.wrapped[post(return)-1]) orig(ts.wrapped[post(return)..]) orig(ts.wrapped[post(return)+1..]) orig(ts.wrapped[0..post(return)]) orig(ts.wrapped[0..post(return)-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(ts.wrapped[])-1 == 0) ==> (return == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return <= size(ts.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT523
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return] ts.wrapped[return-1] ts.wrapped[return..] ts.wrapped[return+1..] ts.wrapped[0..return] ts.wrapped[0..return-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return)]) orig(ts.wrapped[post(return)-1]) orig(ts.wrapped[post(return)..]) orig(ts.wrapped[post(return)+1..]) orig(ts.wrapped[0..post(return)]) orig(ts.wrapped[0..post(return)-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return <= size(ts.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT526
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return] ts.wrapped[return-1] ts.wrapped[return..] ts.wrapped[return+1..] ts.wrapped[0..return] ts.wrapped[0..return-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return)]) orig(ts.wrapped[post(return)-1]) orig(ts.wrapped[post(return)..]) orig(ts.wrapped[post(return)+1..]) orig(ts.wrapped[0..post(return)]) orig(ts.wrapped[0..post(return)-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == size(ts.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == orig(size(ts.wrapped[]))
\result >= 1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[return..] == []
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return] ts.wrapped[return-1] ts.wrapped[return..] ts.wrapped[return+1..] ts.wrapped[0..return] ts.wrapped[0..return-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return)]) orig(ts.wrapped[post(return)-1]) orig(ts.wrapped[post(return)..]) orig(ts.wrapped[post(return)+1..]) orig(ts.wrapped[0..post(return)]) orig(ts.wrapped[0..post(return)-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
\result >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return <= size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) size(ts.wrapped[])-1 ts.wrapped[i] ts.wrapped[i-1] ts.wrapped[i..] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[0..i-1] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
i >= 0
expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: i <= size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT534
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[i] ts.wrapped[i-1] ts.wrapped[i..] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[0..i-1] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return.coeff.numer] ts.wrapped[return.coeff.numer-1] ts.wrapped[return.coeff.numer..] ts.wrapped[return.coeff.numer+1..] ts.wrapped[0..return.coeff.numer] ts.wrapped[0..return.coeff.numer-1] ts.wrapped[return.coeff.denom] ts.wrapped[return.coeff.denom-1] ts.wrapped[return.coeff.denom..] ts.wrapped[return.coeff.denom+1..] ts.wrapped[0..return.coeff.denom] ts.wrapped[0..return.coeff.denom-1] ts.wrapped[return.expt] ts.wrapped[return.expt-1] ts.wrapped[return.expt..] ts.wrapped[return.expt+1..] ts.wrapped[0..return.expt] ts.wrapped[0..return.expt-1] ts.wrapped[orig(i)] ts.wrapped[orig(i)-1] ts.wrapped[orig(i)..] ts.wrapped[orig(i)+1..] ts.wrapped[0..orig(i)] ts.wrapped[0..orig(i)-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(i)]) orig(ts.wrapped[post(i)-1]) orig(ts.wrapped[post(i)..]) orig(ts.wrapped[post(i)+1..]) orig(ts.wrapped[0..post(i)]) orig(ts.wrapped[0..post(i)-1]) orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return.coeff.numer)]) orig(ts.wrapped[post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.numer)..]) orig(ts.wrapped[post(return.coeff.numer)+1..]) orig(ts.wrapped[0..post(return.coeff.numer)]) orig(ts.wrapped[0..post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.denom)]) orig(ts.wrapped[post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.coeff.denom)..]) orig(ts.wrapped[post(return.coeff.denom)+1..]) orig(ts.wrapped[0..post(return.coeff.denom)]) orig(ts.wrapped[0..post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.expt)]) orig(ts.wrapped[post(return.expt)-1]) orig(ts.wrapped[post(return.expt)..]) orig(ts.wrapped[post(return.expt)+1..]) orig(ts.wrapped[0..post(return.expt)]) orig(ts.wrapped[0..post(return.expt)-1]) orig(ts.wrapped[i]) orig(ts.wrapped[i-1]) orig(ts.wrapped[i..]) orig(ts.wrapped[i+1..]) orig(ts.wrapped[0..i]) orig(ts.wrapped[0..i-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[i-1] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) ts.wrapped[i] ts.wrapped[i..] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[0..i-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == ts.wrapped[orig(i)]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in ts.wrapped[]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in ts.wrapped[orig(i)..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in ts.wrapped[0..orig(i)]
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(ts.wrapped[])-1 == 0) ==> (orig(i) == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(i) <= size(ts.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT537
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[i] ts.wrapped[i-1] ts.wrapped[i..] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[0..i-1] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return.coeff.numer] ts.wrapped[return.coeff.numer-1] ts.wrapped[return.coeff.numer..] ts.wrapped[return.coeff.numer+1..] ts.wrapped[0..return.coeff.numer] ts.wrapped[0..return.coeff.numer-1] ts.wrapped[return.coeff.denom] ts.wrapped[return.coeff.denom-1] ts.wrapped[return.coeff.denom..] ts.wrapped[return.coeff.denom+1..] ts.wrapped[0..return.coeff.denom] ts.wrapped[0..return.coeff.denom-1] ts.wrapped[return.expt] ts.wrapped[return.expt-1] ts.wrapped[return.expt..] ts.wrapped[return.expt+1..] ts.wrapped[0..return.expt] ts.wrapped[0..return.expt-1] ts.wrapped[orig(i)] ts.wrapped[orig(i)-1] ts.wrapped[orig(i)..] ts.wrapped[orig(i)+1..] ts.wrapped[0..orig(i)] ts.wrapped[0..orig(i)-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(i)]) orig(ts.wrapped[post(i)-1]) orig(ts.wrapped[post(i)..]) orig(ts.wrapped[post(i)+1..]) orig(ts.wrapped[0..post(i)]) orig(ts.wrapped[0..post(i)-1]) orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return.coeff.numer)]) orig(ts.wrapped[post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.numer)..]) orig(ts.wrapped[post(return.coeff.numer)+1..]) orig(ts.wrapped[0..post(return.coeff.numer)]) orig(ts.wrapped[0..post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.denom)]) orig(ts.wrapped[post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.coeff.denom)..]) orig(ts.wrapped[post(return.coeff.denom)+1..]) orig(ts.wrapped[0..post(return.coeff.denom)]) orig(ts.wrapped[0..post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.expt)]) orig(ts.wrapped[post(return.expt)-1]) orig(ts.wrapped[post(return.expt)..]) orig(ts.wrapped[post(return.expt)+1..]) orig(ts.wrapped[0..post(return.expt)]) orig(ts.wrapped[0..post(return.expt)-1]) orig(ts.wrapped[i]) orig(ts.wrapped[i-1]) orig(ts.wrapped[i..]) orig(ts.wrapped[i+1..]) orig(ts.wrapped[0..i]) orig(ts.wrapped[0..i-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[i] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) ts.wrapped[i-1] ts.wrapped[i..] ts.wrapped[0..i-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[return.coeff.numer] == ts.wrapped[return.coeff.denom-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[return.coeff.numer] == orig(ts.wrapped[post(return.coeff.denom)-1])
\result.coeff.numer == 0
\result.coeff.denom == 1
\old(i) >= 1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[0..return.coeff.numer-1] == []
\result.coeff.numer <= \result.expt
\result.coeff.numer < \old(i)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return.coeff.numer <= size(ts.wrapped[])-1
\result.coeff.denom <= \old(i)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: return.coeff.denom <= size(ts.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.SeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[0..return.coeff.numer] elements == ts.wrapped[return.coeff.numer]
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[i] ts.wrapped[i-1] ts.wrapped[i..] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[0..i-1] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1] ts.wrapped[return.coeff.numer] ts.wrapped[return.coeff.numer-1] ts.wrapped[return.coeff.numer..] ts.wrapped[return.coeff.numer+1..] ts.wrapped[0..return.coeff.numer] ts.wrapped[0..return.coeff.numer-1] ts.wrapped[return.coeff.denom] ts.wrapped[return.coeff.denom-1] ts.wrapped[return.coeff.denom..] ts.wrapped[return.coeff.denom+1..] ts.wrapped[0..return.coeff.denom] ts.wrapped[0..return.coeff.denom-1] ts.wrapped[return.expt] ts.wrapped[return.expt-1] ts.wrapped[return.expt..] ts.wrapped[return.expt+1..] ts.wrapped[0..return.expt] ts.wrapped[0..return.expt-1] ts.wrapped[orig(i)] ts.wrapped[orig(i)-1] ts.wrapped[orig(i)..] ts.wrapped[orig(i)+1..] ts.wrapped[0..orig(i)] ts.wrapped[0..orig(i)-1] ts.wrapped[orig(expt)] ts.wrapped[orig(expt)-1] ts.wrapped[orig(expt)..] ts.wrapped[orig(expt)+1..] ts.wrapped[0..orig(expt)] ts.wrapped[0..orig(expt)-1] orig(ts.wrapped[post(i)]) orig(ts.wrapped[post(i)-1]) orig(ts.wrapped[post(i)..]) orig(ts.wrapped[post(i)+1..]) orig(ts.wrapped[0..post(i)]) orig(ts.wrapped[0..post(i)-1]) orig(ts.wrapped[post(expt)]) orig(ts.wrapped[post(expt)-1]) orig(ts.wrapped[post(expt)..]) orig(ts.wrapped[post(expt)+1..]) orig(ts.wrapped[0..post(expt)]) orig(ts.wrapped[0..post(expt)-1]) orig(ts.wrapped[post(return.coeff.numer)]) orig(ts.wrapped[post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.numer)..]) orig(ts.wrapped[post(return.coeff.numer)+1..]) orig(ts.wrapped[0..post(return.coeff.numer)]) orig(ts.wrapped[0..post(return.coeff.numer)-1]) orig(ts.wrapped[post(return.coeff.denom)]) orig(ts.wrapped[post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.coeff.denom)..]) orig(ts.wrapped[post(return.coeff.denom)+1..]) orig(ts.wrapped[0..post(return.coeff.denom)]) orig(ts.wrapped[0..post(return.coeff.denom)-1]) orig(ts.wrapped[post(return.expt)]) orig(ts.wrapped[post(return.expt)-1]) orig(ts.wrapped[post(return.expt)..]) orig(ts.wrapped[post(return.expt)+1..]) orig(ts.wrapped[0..post(return.expt)]) orig(ts.wrapped[0..post(return.expt)-1]) orig(ts.wrapped[i]) orig(ts.wrapped[i-1]) orig(ts.wrapped[i..]) orig(ts.wrapped[i+1..]) orig(ts.wrapped[0..i]) orig(ts.wrapped[0..i-1]) orig(ts.wrapped[expt]) orig(ts.wrapped[expt-1]) orig(ts.wrapped[expt..]) orig(ts.wrapped[expt+1..]) orig(ts.wrapped[0..expt]) orig(ts.wrapped[0..expt-1])
      Modified primitive arguments: ts.wrapped[i] ts.wrapped[i-1] ts.wrapped[i+1..] ts.wrapped[0..i] ts.wrapped[expt] ts.wrapped[expt-1] ts.wrapped[expt..] ts.wrapped[expt+1..] ts.wrapped[0..expt] ts.wrapped[0..expt-1]
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) ts.wrapped[i..] ts.wrapped[0..i-1]
\result.expt == \old(expt)
(\result.coeff.numer == 0)  ==>  (\old(i) >= 1)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.denom)-1]) elements == orig(ts.wrapped[post(return.coeff.denom)-1]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.denom)-1]) elements == orig(ts.wrapped[post(return.coeff.numer)]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.denom)-1]) elements == ts.wrapped[return.coeff.denom-1])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.denom)-1]) elements == ts.wrapped[return.coeff.numer])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.numer)-1]) == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.numer)]) elements == orig(ts.wrapped[post(return.coeff.denom)-1]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.numer)]) elements == orig(ts.wrapped[post(return.coeff.numer)]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.numer)]) elements == ts.wrapped[return.coeff.denom-1])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[0..post(return.coeff.numer)]) elements == ts.wrapped[return.coeff.numer])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (orig(ts.wrapped[post(return.coeff.numer)..]) contains no duplicates)
(\result.coeff.numer == 0)  ==>  ((\forall int i; (\result.coeff.numer <= i && i <= \old(ts.wrapped.length-1)) ==> (\old(ts.wrapped[i]) != null)))
(\result.coeff.numer == 0)  ==>  (\result.coeff.denom <= \old(i))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (return.coeff.denom <= size(ts.wrapped[]))
(\result.coeff.numer == 0)  ==>  (\result.coeff.denom == 1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer < \old(i))
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer < \result.coeff.denom)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer <= \result.expt)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (return.coeff.numer <= size(ts.wrapped[])-1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.denom-1] elements == orig(ts.wrapped[post(return.coeff.denom)-1]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.denom-1] elements == orig(ts.wrapped[post(return.coeff.numer)]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.denom-1] elements == ts.wrapped[return.coeff.denom-1])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.denom-1] elements == ts.wrapped[return.coeff.numer])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.numer-1] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.numer] elements == orig(ts.wrapped[post(return.coeff.denom)-1]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.numer] elements == orig(ts.wrapped[post(return.coeff.numer)]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.numer] elements == ts.wrapped[return.coeff.denom-1])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[0..return.coeff.numer] elements == ts.wrapped[return.coeff.numer])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[return.coeff.numer..] contains no duplicates)
(\result.coeff.numer == 0)  ==>  ((\forall int i; (\result.coeff.numer <= i && i <= ts.wrapped.length-1) ==> (ts.wrapped[i] != null)))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[return.coeff.numer] == orig(ts.wrapped[post(return.coeff.denom)-1]))
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.numer == 0)  ==>  (ts.wrapped[return.coeff.numer] == ts.wrapped[return.coeff.denom-1])
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.coeff != null
\result.coeff.denom >= 1
\result.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(i) <= size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree size(vec.wrapped[]) size(vec.wrapped[])-1 vec.wrapped[degree] vec.wrapped[degree-1] vec.wrapped[degree..] vec.wrapped[degree+1..] vec.wrapped[0..degree] vec.wrapped[0..degree-1]
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
degree >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(degree) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[degree] vec.wrapped[degree-1] vec.wrapped[degree..] vec.wrapped[degree+1..] vec.wrapped[0..degree] vec.wrapped[0..degree-1] vec.wrapped[orig(degree)] vec.wrapped[orig(degree)-1] vec.wrapped[orig(degree)..] vec.wrapped[orig(degree)+1..] vec.wrapped[0..orig(degree)] vec.wrapped[0..orig(degree)-1] orig(vec.wrapped[post(degree)]) orig(vec.wrapped[post(degree)-1]) orig(vec.wrapped[post(degree)..]) orig(vec.wrapped[post(degree)+1..]) orig(vec.wrapped[0..post(degree)]) orig(vec.wrapped[0..post(degree)-1]) orig(vec.wrapped[degree]) orig(vec.wrapped[degree-1]) orig(vec.wrapped[degree..]) orig(vec.wrapped[degree+1..]) orig(vec.wrapped[0..degree]) orig(vec.wrapped[0..degree-1])
      Modified variables: vec.wrapped[]
      Modified primitive arguments: vec.wrapped[degree] vec.wrapped[degree-1] vec.wrapped[degree..] vec.wrapped[degree+1..] vec.wrapped[0..degree] vec.wrapped[0..degree-1]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() degree size(vec.wrapped[])
modifies vec.wrapped[*]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.isNaN():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT86
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result == true
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT90
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
\result == false
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return == true)  ==>  (size(this.terms.wrapped[]) == 1)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return == true)  ==>  (size(this.terms.wrapped[])-1 is a pointer)
(\result == true)  ==>  (this.terms.wrapped.elementType == \type(PolyCalc.RatTerm))
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT390
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == return.terms.wrapped[]
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 >= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT394
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] == return.terms.wrapped[]
\result == \old(p)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT404
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(this.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[])-1 == 0) ==> (size(p.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[])-1 == 0) ==> (size(this.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[])-1 == 0) ==> (size(p.terms.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) == 0) ==> (size(this.terms.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 != size(return.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[])-1 == 0) ==> (size(return.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[])-1 <= size(return.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.negate():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.negate():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == size(return.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
\result.terms.wrapped.containsNull == false
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::ENTER
    Variables: polyStr polyStr.toString
polyStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: polyStr.toString is printable
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::EXIT
    Variables: polyStr polyStr.toString return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(polyStr) orig(polyStr.toString) size(return.terms.wrapped[]) size(return.terms.wrapped[])-1
      Unmodified variables: polyStr polyStr.toString
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: polyStr.toString is printable
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::ENTER
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index size(ts.wrapped[]) size(ts.wrapped[])-1 ts.wrapped[term.coeff.numer] ts.wrapped[term.coeff.numer-1] ts.wrapped[term.coeff.numer..] ts.wrapped[term.coeff.numer+1..] ts.wrapped[0..term.coeff.numer] ts.wrapped[0..term.coeff.numer-1] ts.wrapped[term.coeff.denom] ts.wrapped[term.coeff.denom-1] ts.wrapped[term.coeff.denom..] ts.wrapped[term.coeff.denom+1..] ts.wrapped[0..term.coeff.denom] ts.wrapped[0..term.coeff.denom-1] ts.wrapped[term.expt] ts.wrapped[term.expt-1] ts.wrapped[term.expt..] ts.wrapped[term.expt+1..] ts.wrapped[0..term.expt] ts.wrapped[0..term.expt-1] ts.wrapped[index] ts.wrapped[index-1] ts.wrapped[index..] ts.wrapped[index+1..] ts.wrapped[0..index] ts.wrapped[0..index-1]
term != null
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
index >= 1
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: index <= size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::EXIT
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index orig(term) orig(term.coeff) orig(term.coeff.numer) orig(term.coeff.denom) orig(term.expt) orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(index) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1 ts.wrapped[term.coeff.numer] ts.wrapped[term.coeff.numer-1] ts.wrapped[term.coeff.numer..] ts.wrapped[term.coeff.numer+1..] ts.wrapped[0..term.coeff.numer] ts.wrapped[0..term.coeff.numer-1] orig(ts.wrapped[post(term.coeff.numer)]) orig(ts.wrapped[post(term.coeff.numer)-1]) orig(ts.wrapped[post(term.coeff.numer)..]) orig(ts.wrapped[post(term.coeff.numer)+1..]) orig(ts.wrapped[0..post(term.coeff.numer)]) orig(ts.wrapped[0..post(term.coeff.numer)-1]) ts.wrapped[term.coeff.denom] ts.wrapped[term.coeff.denom-1] ts.wrapped[term.coeff.denom..] ts.wrapped[term.coeff.denom+1..] ts.wrapped[0..term.coeff.denom] ts.wrapped[0..term.coeff.denom-1] orig(ts.wrapped[post(term.coeff.denom)]) orig(ts.wrapped[post(term.coeff.denom)-1]) orig(ts.wrapped[post(term.coeff.denom)..]) orig(ts.wrapped[post(term.coeff.denom)+1..]) orig(ts.wrapped[0..post(term.coeff.denom)]) orig(ts.wrapped[0..post(term.coeff.denom)-1]) ts.wrapped[term.expt] ts.wrapped[term.expt-1] ts.wrapped[term.expt..] ts.wrapped[term.expt+1..] ts.wrapped[0..term.expt] ts.wrapped[0..term.expt-1] orig(ts.wrapped[post(term.expt)]) orig(ts.wrapped[post(term.expt)-1]) orig(ts.wrapped[post(term.expt)..]) orig(ts.wrapped[post(term.expt)+1..]) orig(ts.wrapped[0..post(term.expt)]) orig(ts.wrapped[0..post(term.expt)-1]) ts.wrapped[index] ts.wrapped[index-1] ts.wrapped[index..] ts.wrapped[index+1..] ts.wrapped[0..index] ts.wrapped[0..index-1] ts.wrapped[orig(term.coeff.numer)] ts.wrapped[orig(term.coeff.numer)-1] ts.wrapped[orig(term.coeff.numer)..] ts.wrapped[orig(term.coeff.numer)+1..] ts.wrapped[0..orig(term.coeff.numer)] ts.wrapped[0..orig(term.coeff.numer)-1] ts.wrapped[orig(term.coeff.denom)] ts.wrapped[orig(term.coeff.denom)-1] ts.wrapped[orig(term.coeff.denom)..] ts.wrapped[orig(term.coeff.denom)+1..] ts.wrapped[0..orig(term.coeff.denom)] ts.wrapped[0..orig(term.coeff.denom)-1] ts.wrapped[orig(term.expt)] ts.wrapped[orig(term.expt)-1] ts.wrapped[orig(term.expt)..] ts.wrapped[orig(term.expt)+1..] ts.wrapped[0..orig(term.expt)] ts.wrapped[0..orig(term.expt)-1] ts.wrapped[orig(index)] ts.wrapped[orig(index)-1] ts.wrapped[orig(index)..] ts.wrapped[orig(index)+1..] ts.wrapped[0..orig(index)] ts.wrapped[0..orig(index)-1] orig(ts.wrapped[post(index)]) orig(ts.wrapped[post(index)-1]) orig(ts.wrapped[post(index)..]) orig(ts.wrapped[post(index)+1..]) orig(ts.wrapped[0..post(index)]) orig(ts.wrapped[0..post(index)-1]) orig(ts.wrapped[term.coeff.numer]) orig(ts.wrapped[term.coeff.numer-1]) orig(ts.wrapped[term.coeff.numer..]) orig(ts.wrapped[term.coeff.numer+1..]) orig(ts.wrapped[0..term.coeff.numer]) orig(ts.wrapped[0..term.coeff.numer-1]) orig(ts.wrapped[term.coeff.denom]) orig(ts.wrapped[term.coeff.denom-1]) orig(ts.wrapped[term.coeff.denom..]) orig(ts.wrapped[term.coeff.denom+1..]) orig(ts.wrapped[0..term.coeff.denom]) orig(ts.wrapped[0..term.coeff.denom-1]) orig(ts.wrapped[term.expt]) orig(ts.wrapped[term.expt-1]) orig(ts.wrapped[term.expt..]) orig(ts.wrapped[term.expt+1..]) orig(ts.wrapped[0..term.expt]) orig(ts.wrapped[0..term.expt-1]) orig(ts.wrapped[index]) orig(ts.wrapped[index-1]) orig(ts.wrapped[index..]) orig(ts.wrapped[index+1..]) orig(ts.wrapped[0..index]) orig(ts.wrapped[0..index-1])
      Modified variables: ts.wrapped[] ts.wrapped[].getClass().getName() size(ts.wrapped[]) ts.wrapped[term.coeff.numer] ts.wrapped[term.coeff.numer-1] ts.wrapped[term.coeff.numer..] ts.wrapped[term.coeff.numer+1..] ts.wrapped[0..term.coeff.numer] ts.wrapped[0..term.coeff.numer-1] ts.wrapped[term.coeff.denom] ts.wrapped[term.coeff.denom-1] ts.wrapped[term.coeff.denom..] ts.wrapped[term.coeff.denom+1..] ts.wrapped[0..term.coeff.denom] ts.wrapped[0..term.coeff.denom-1] ts.wrapped[term.expt] ts.wrapped[term.expt-1] ts.wrapped[term.expt..] ts.wrapped[term.expt+1..] ts.wrapped[0..term.expt] ts.wrapped[0..term.expt-1]
      Modified primitive arguments: ts.wrapped[index] ts.wrapped[index..] ts.wrapped[index+1..] ts.wrapped[0..index]
      Unmodified variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped index ts.wrapped[index-1] ts.wrapped[0..index-1]
modifies ts.wrapped[*], ts.wrapped[term.coeff.numer], ts.wrapped[term.coeff.numer-1], ts.wrapped[term.coeff.numer..], ts.wrapped[term.coeff.numer+1..], ts.wrapped[0..term.coeff.numer], ts.wrapped[0..term.coeff.numer-1], ts.wrapped[term.coeff.denom], ts.wrapped[term.coeff.denom-1], ts.wrapped[term.coeff.denom..], ts.wrapped[term.coeff.denom+1..], ts.wrapped[0..term.coeff.denom], ts.wrapped[0..term.coeff.denom-1], ts.wrapped[term.expt], ts.wrapped[term.expt-1], ts.wrapped[term.expt..], ts.wrapped[term.expt+1..], ts.wrapped[0..term.expt], ts.wrapped[0..term.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[orig(index)-1] == orig(ts.wrapped[post(index)-1])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[orig(index)-1] == orig(ts.wrapped[index-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[0..orig(index)-1] == orig(ts.wrapped[0..post(index)-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[0..orig(index)-1] == orig(ts.wrapped[0..index-1])
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(ts.wrapped[])-1 == 0) ==> (term.coeff.numer == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(index) <= size(ts.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ShiftZero.format(OutputFormat:ESC/Java) needs to be implemented: (orig(size(ts.wrapped[])) >> size(ts.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= orig(size(ts.wrapped[]))-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[])-1 <= orig(size(ts.wrapped[]))
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(ts.wrapped[])-1 == 0) ==> (orig(size(ts.wrapped[]))-1 == 0)
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 this.terms.wrapped[scalar.coeff.numer] this.terms.wrapped[scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.numer..] this.terms.wrapped[scalar.coeff.numer+1..] this.terms.wrapped[0..scalar.coeff.numer] this.terms.wrapped[0..scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.denom] this.terms.wrapped[scalar.coeff.denom-1] this.terms.wrapped[scalar.coeff.denom..] this.terms.wrapped[scalar.coeff.denom+1..] this.terms.wrapped[0..scalar.coeff.denom] this.terms.wrapped[0..scalar.coeff.denom-1] this.terms.wrapped[scalar.expt] this.terms.wrapped[scalar.expt-1] this.terms.wrapped[scalar.expt..] this.terms.wrapped[scalar.expt+1..] this.terms.wrapped[0..scalar.expt] this.terms.wrapped[0..scalar.expt-1]
scalar != null
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(scalar) orig(scalar.coeff) orig(scalar.coeff.numer) orig(scalar.coeff.denom) orig(scalar.expt) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 this.terms.wrapped[scalar.coeff.numer] this.terms.wrapped[scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.numer..] this.terms.wrapped[scalar.coeff.numer+1..] this.terms.wrapped[0..scalar.coeff.numer] this.terms.wrapped[0..scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.denom] this.terms.wrapped[scalar.coeff.denom-1] this.terms.wrapped[scalar.coeff.denom..] this.terms.wrapped[scalar.coeff.denom+1..] this.terms.wrapped[0..scalar.coeff.denom] this.terms.wrapped[0..scalar.coeff.denom-1] this.terms.wrapped[scalar.expt] this.terms.wrapped[scalar.expt-1] this.terms.wrapped[scalar.expt..] this.terms.wrapped[scalar.expt+1..] this.terms.wrapped[0..scalar.expt] this.terms.wrapped[0..scalar.expt-1] this.terms.wrapped[orig(scalar.coeff.numer)] this.terms.wrapped[orig(scalar.coeff.numer)-1] this.terms.wrapped[orig(scalar.coeff.numer)..] this.terms.wrapped[orig(scalar.coeff.numer)+1..] this.terms.wrapped[0..orig(scalar.coeff.numer)] this.terms.wrapped[0..orig(scalar.coeff.numer)-1] this.terms.wrapped[orig(scalar.coeff.denom)] this.terms.wrapped[orig(scalar.coeff.denom)-1] this.terms.wrapped[orig(scalar.coeff.denom)..] this.terms.wrapped[orig(scalar.coeff.denom)+1..] this.terms.wrapped[0..orig(scalar.coeff.denom)] this.terms.wrapped[0..orig(scalar.coeff.denom)-1] this.terms.wrapped[orig(scalar.expt)] this.terms.wrapped[orig(scalar.expt)-1] this.terms.wrapped[orig(scalar.expt)..] this.terms.wrapped[orig(scalar.expt)+1..] this.terms.wrapped[0..orig(scalar.expt)] this.terms.wrapped[0..orig(scalar.expt)-1] return.terms.wrapped[scalar.coeff.numer] return.terms.wrapped[scalar.coeff.numer-1] return.terms.wrapped[scalar.coeff.numer..] return.terms.wrapped[scalar.coeff.numer+1..] return.terms.wrapped[0..scalar.coeff.numer] return.terms.wrapped[0..scalar.coeff.numer-1] orig(this.terms.wrapped[post(scalar.coeff.numer)]) orig(this.terms.wrapped[post(scalar.coeff.numer)-1]) orig(this.terms.wrapped[post(scalar.coeff.numer)..]) orig(this.terms.wrapped[post(scalar.coeff.numer)+1..]) orig(this.terms.wrapped[0..post(scalar.coeff.numer)]) orig(this.terms.wrapped[0..post(scalar.coeff.numer)-1]) return.terms.wrapped[scalar.coeff.denom] return.terms.wrapped[scalar.coeff.denom-1] return.terms.wrapped[scalar.coeff.denom..] return.terms.wrapped[scalar.coeff.denom+1..] return.terms.wrapped[0..scalar.coeff.denom] return.terms.wrapped[0..scalar.coeff.denom-1] orig(this.terms.wrapped[post(scalar.coeff.denom)]) orig(this.terms.wrapped[post(scalar.coeff.denom)-1]) orig(this.terms.wrapped[post(scalar.coeff.denom)..]) orig(this.terms.wrapped[post(scalar.coeff.denom)+1..]) orig(this.terms.wrapped[0..post(scalar.coeff.denom)]) orig(this.terms.wrapped[0..post(scalar.coeff.denom)-1]) return.terms.wrapped[scalar.expt] return.terms.wrapped[scalar.expt-1] return.terms.wrapped[scalar.expt..] return.terms.wrapped[scalar.expt+1..] return.terms.wrapped[0..scalar.expt] return.terms.wrapped[0..scalar.expt-1] orig(this.terms.wrapped[post(scalar.expt)]) orig(this.terms.wrapped[post(scalar.expt)-1]) orig(this.terms.wrapped[post(scalar.expt)..]) orig(this.terms.wrapped[post(scalar.expt)+1..]) orig(this.terms.wrapped[0..post(scalar.expt)]) orig(this.terms.wrapped[0..post(scalar.expt)-1]) return.terms.wrapped[orig(scalar.coeff.numer)] return.terms.wrapped[orig(scalar.coeff.numer)-1] return.terms.wrapped[orig(scalar.coeff.numer)..] return.terms.wrapped[orig(scalar.coeff.numer)+1..] return.terms.wrapped[0..orig(scalar.coeff.numer)] return.terms.wrapped[0..orig(scalar.coeff.numer)-1] return.terms.wrapped[orig(scalar.coeff.denom)] return.terms.wrapped[orig(scalar.coeff.denom)-1] return.terms.wrapped[orig(scalar.coeff.denom)..] return.terms.wrapped[orig(scalar.coeff.denom)+1..] return.terms.wrapped[0..orig(scalar.coeff.denom)] return.terms.wrapped[0..orig(scalar.coeff.denom)-1] return.terms.wrapped[orig(scalar.expt)] return.terms.wrapped[orig(scalar.expt)-1] return.terms.wrapped[orig(scalar.expt)..] return.terms.wrapped[orig(scalar.expt)+1..] return.terms.wrapped[0..orig(scalar.expt)] return.terms.wrapped[0..orig(scalar.expt)-1] orig(this.terms.wrapped[scalar.coeff.numer]) orig(this.terms.wrapped[scalar.coeff.numer-1]) orig(this.terms.wrapped[scalar.coeff.numer..]) orig(this.terms.wrapped[scalar.coeff.numer+1..]) orig(this.terms.wrapped[0..scalar.coeff.numer]) orig(this.terms.wrapped[0..scalar.coeff.numer-1]) orig(this.terms.wrapped[scalar.coeff.denom]) orig(this.terms.wrapped[scalar.coeff.denom-1]) orig(this.terms.wrapped[scalar.coeff.denom..]) orig(this.terms.wrapped[scalar.coeff.denom+1..]) orig(this.terms.wrapped[0..scalar.coeff.denom]) orig(this.terms.wrapped[0..scalar.coeff.denom-1]) orig(this.terms.wrapped[scalar.expt]) orig(this.terms.wrapped[scalar.expt-1]) orig(this.terms.wrapped[scalar.expt..]) orig(this.terms.wrapped[scalar.expt+1..]) orig(this.terms.wrapped[0..scalar.expt]) orig(this.terms.wrapped[0..scalar.expt-1])
      Modified variables: this.terms.wrapped[scalar.coeff.numer] this.terms.wrapped[scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.numer..] this.terms.wrapped[scalar.coeff.numer+1..] this.terms.wrapped[0..scalar.coeff.numer] this.terms.wrapped[0..scalar.coeff.numer-1] this.terms.wrapped[scalar.coeff.denom] this.terms.wrapped[scalar.coeff.denom-1] this.terms.wrapped[scalar.coeff.denom..] this.terms.wrapped[scalar.coeff.denom+1..] this.terms.wrapped[0..scalar.coeff.denom] this.terms.wrapped[0..scalar.coeff.denom-1] this.terms.wrapped[scalar.expt] this.terms.wrapped[scalar.expt-1] this.terms.wrapped[scalar.expt..] this.terms.wrapped[scalar.expt+1..] this.terms.wrapped[0..scalar.expt] this.terms.wrapped[0..scalar.expt-1]
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt size(this.terms.wrapped[])
modifies this.terms.wrapped[scalar.coeff.numer], this.terms.wrapped[scalar.coeff.numer-1], this.terms.wrapped[scalar.coeff.numer..], this.terms.wrapped[scalar.coeff.numer+1..], this.terms.wrapped[0..scalar.coeff.numer], this.terms.wrapped[0..scalar.coeff.numer-1], this.terms.wrapped[scalar.coeff.denom], this.terms.wrapped[scalar.coeff.denom-1], this.terms.wrapped[scalar.coeff.denom..], this.terms.wrapped[scalar.coeff.denom+1..], this.terms.wrapped[0..scalar.coeff.denom], this.terms.wrapped[0..scalar.coeff.denom-1], this.terms.wrapped[scalar.expt], this.terms.wrapped[scalar.expt-1], this.terms.wrapped[scalar.expt..], this.terms.wrapped[scalar.expt+1..], this.terms.wrapped[0..scalar.expt], this.terms.wrapped[0..scalar.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == size(return.terms.wrapped[])
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom size(vec.wrapped[]) size(vec.wrapped[])-1 vec.wrapped[scalar.numer] vec.wrapped[scalar.numer-1] vec.wrapped[scalar.numer..] vec.wrapped[scalar.numer+1..] vec.wrapped[0..scalar.numer] vec.wrapped[0..scalar.numer-1] vec.wrapped[scalar.denom] vec.wrapped[scalar.denom-1] vec.wrapped[scalar.denom..] vec.wrapped[scalar.denom+1..] vec.wrapped[0..scalar.denom] vec.wrapped[0..scalar.denom-1]
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
scalar != null
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(scalar) orig(scalar.numer) orig(scalar.denom) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[scalar.numer] vec.wrapped[scalar.numer-1] vec.wrapped[scalar.numer..] vec.wrapped[scalar.numer+1..] vec.wrapped[0..scalar.numer] vec.wrapped[0..scalar.numer-1] vec.wrapped[scalar.denom] vec.wrapped[scalar.denom-1] vec.wrapped[scalar.denom..] vec.wrapped[scalar.denom+1..] vec.wrapped[0..scalar.denom] vec.wrapped[0..scalar.denom-1] vec.wrapped[orig(scalar.numer)] vec.wrapped[orig(scalar.numer)-1] vec.wrapped[orig(scalar.numer)..] vec.wrapped[orig(scalar.numer)+1..] vec.wrapped[0..orig(scalar.numer)] vec.wrapped[0..orig(scalar.numer)-1] vec.wrapped[orig(scalar.denom)] vec.wrapped[orig(scalar.denom)-1] vec.wrapped[orig(scalar.denom)..] vec.wrapped[orig(scalar.denom)+1..] vec.wrapped[0..orig(scalar.denom)] vec.wrapped[0..orig(scalar.denom)-1] orig(vec.wrapped[post(scalar.numer)]) orig(vec.wrapped[post(scalar.numer)-1]) orig(vec.wrapped[post(scalar.numer)..]) orig(vec.wrapped[post(scalar.numer)+1..]) orig(vec.wrapped[0..post(scalar.numer)]) orig(vec.wrapped[0..post(scalar.numer)-1]) orig(vec.wrapped[post(scalar.denom)]) orig(vec.wrapped[post(scalar.denom)-1]) orig(vec.wrapped[post(scalar.denom)..]) orig(vec.wrapped[post(scalar.denom)+1..]) orig(vec.wrapped[0..post(scalar.denom)]) orig(vec.wrapped[0..post(scalar.denom)-1]) orig(vec.wrapped[scalar.numer]) orig(vec.wrapped[scalar.numer-1]) orig(vec.wrapped[scalar.numer..]) orig(vec.wrapped[scalar.numer+1..]) orig(vec.wrapped[0..scalar.numer]) orig(vec.wrapped[0..scalar.numer-1]) orig(vec.wrapped[scalar.denom]) orig(vec.wrapped[scalar.denom-1]) orig(vec.wrapped[scalar.denom..]) orig(vec.wrapped[scalar.denom+1..]) orig(vec.wrapped[0..scalar.denom]) orig(vec.wrapped[0..scalar.denom-1])
      Modified variables: vec.wrapped[] vec.wrapped[scalar.numer] vec.wrapped[scalar.numer-1] vec.wrapped[scalar.numer..] vec.wrapped[scalar.numer+1..] vec.wrapped[0..scalar.numer] vec.wrapped[0..scalar.numer-1] vec.wrapped[scalar.denom] vec.wrapped[scalar.denom-1] vec.wrapped[scalar.denom..] vec.wrapped[scalar.denom+1..] vec.wrapped[0..scalar.denom] vec.wrapped[0..scalar.denom-1]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom size(vec.wrapped[])
modifies vec.wrapped[*], vec.wrapped[scalar.numer], vec.wrapped[scalar.numer-1], vec.wrapped[scalar.numer..], vec.wrapped[scalar.numer+1..], vec.wrapped[0..scalar.numer], vec.wrapped[0..scalar.numer-1], vec.wrapped[scalar.denom], vec.wrapped[scalar.denom-1], vec.wrapped[scalar.denom..], vec.wrapped[scalar.denom+1..], vec.wrapped[0..scalar.denom], vec.wrapped[0..scalar.denom-1]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt size(vec.wrapped[]) size(vec.wrapped[])-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm != null
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT308
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1] vec.wrapped[orig(newTerm.coeff.numer)] vec.wrapped[orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.numer)..] vec.wrapped[orig(newTerm.coeff.numer)+1..] vec.wrapped[0..orig(newTerm.coeff.numer)] vec.wrapped[0..orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.denom)] vec.wrapped[orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.coeff.denom)..] vec.wrapped[orig(newTerm.coeff.denom)+1..] vec.wrapped[0..orig(newTerm.coeff.denom)] vec.wrapped[0..orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.expt)] vec.wrapped[orig(newTerm.expt)-1] vec.wrapped[orig(newTerm.expt)..] vec.wrapped[orig(newTerm.expt)+1..] vec.wrapped[0..orig(newTerm.expt)] vec.wrapped[0..orig(newTerm.expt)-1] orig(vec.wrapped[post(newTerm.coeff.numer)]) orig(vec.wrapped[post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.numer)..]) orig(vec.wrapped[post(newTerm.coeff.numer)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.numer)]) orig(vec.wrapped[0..post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)]) orig(vec.wrapped[post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)..]) orig(vec.wrapped[post(newTerm.coeff.denom)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.denom)]) orig(vec.wrapped[0..post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.expt)]) orig(vec.wrapped[post(newTerm.expt)-1]) orig(vec.wrapped[post(newTerm.expt)..]) orig(vec.wrapped[post(newTerm.expt)+1..]) orig(vec.wrapped[0..post(newTerm.expt)]) orig(vec.wrapped[0..post(newTerm.expt)-1]) orig(vec.wrapped[newTerm.coeff.numer]) orig(vec.wrapped[newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.numer..]) orig(vec.wrapped[newTerm.coeff.numer+1..]) orig(vec.wrapped[0..newTerm.coeff.numer]) orig(vec.wrapped[0..newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.denom]) orig(vec.wrapped[newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.coeff.denom..]) orig(vec.wrapped[newTerm.coeff.denom+1..]) orig(vec.wrapped[0..newTerm.coeff.denom]) orig(vec.wrapped[0..newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.expt]) orig(vec.wrapped[newTerm.expt-1]) orig(vec.wrapped[newTerm.expt..]) orig(vec.wrapped[newTerm.expt+1..]) orig(vec.wrapped[0..newTerm.expt]) orig(vec.wrapped[0..newTerm.expt-1])
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[]) vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*], vec.wrapped[newTerm.coeff.numer], vec.wrapped[newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.numer..], vec.wrapped[newTerm.coeff.numer+1..], vec.wrapped[0..newTerm.coeff.numer], vec.wrapped[0..newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.denom], vec.wrapped[newTerm.coeff.denom-1], vec.wrapped[newTerm.coeff.denom..], vec.wrapped[newTerm.coeff.denom+1..], vec.wrapped[0..newTerm.coeff.denom], vec.wrapped[0..newTerm.coeff.denom-1], vec.wrapped[newTerm.expt], vec.wrapped[newTerm.expt-1], vec.wrapped[newTerm.expt..], vec.wrapped[newTerm.expt+1..], vec.wrapped[0..newTerm.expt], vec.wrapped[0..newTerm.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) == orig(size(vec.wrapped[]))-1
newTerm.coeff.denom == 1
warning: method daikon.inv.binary.twoSequence.SubSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a subset of orig(vec.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: newTerm.coeff.numer != size(vec.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: newTerm.coeff.numer != orig(size(vec.wrapped[]))
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: newTerm.coeff.denom <= orig(size(vec.wrapped[]))
warning: method daikon.inv.binary.sequenceScalar.SeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[0..newTerm.coeff.denom-1]) elements == orig(vec.wrapped[newTerm.coeff.denom-1])
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT312
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1] vec.wrapped[orig(newTerm.coeff.numer)] vec.wrapped[orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.numer)..] vec.wrapped[orig(newTerm.coeff.numer)+1..] vec.wrapped[0..orig(newTerm.coeff.numer)] vec.wrapped[0..orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.denom)] vec.wrapped[orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.coeff.denom)..] vec.wrapped[orig(newTerm.coeff.denom)+1..] vec.wrapped[0..orig(newTerm.coeff.denom)] vec.wrapped[0..orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.expt)] vec.wrapped[orig(newTerm.expt)-1] vec.wrapped[orig(newTerm.expt)..] vec.wrapped[orig(newTerm.expt)+1..] vec.wrapped[0..orig(newTerm.expt)] vec.wrapped[0..orig(newTerm.expt)-1] orig(vec.wrapped[post(newTerm.coeff.numer)]) orig(vec.wrapped[post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.numer)..]) orig(vec.wrapped[post(newTerm.coeff.numer)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.numer)]) orig(vec.wrapped[0..post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)]) orig(vec.wrapped[post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)..]) orig(vec.wrapped[post(newTerm.coeff.denom)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.denom)]) orig(vec.wrapped[0..post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.expt)]) orig(vec.wrapped[post(newTerm.expt)-1]) orig(vec.wrapped[post(newTerm.expt)..]) orig(vec.wrapped[post(newTerm.expt)+1..]) orig(vec.wrapped[0..post(newTerm.expt)]) orig(vec.wrapped[0..post(newTerm.expt)-1]) orig(vec.wrapped[newTerm.coeff.numer]) orig(vec.wrapped[newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.numer..]) orig(vec.wrapped[newTerm.coeff.numer+1..]) orig(vec.wrapped[0..newTerm.coeff.numer]) orig(vec.wrapped[0..newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.denom]) orig(vec.wrapped[newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.coeff.denom..]) orig(vec.wrapped[newTerm.coeff.denom+1..]) orig(vec.wrapped[0..newTerm.coeff.denom]) orig(vec.wrapped[0..newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.expt]) orig(vec.wrapped[newTerm.expt-1]) orig(vec.wrapped[newTerm.expt..]) orig(vec.wrapped[newTerm.expt+1..]) orig(vec.wrapped[0..newTerm.expt]) orig(vec.wrapped[0..newTerm.expt-1])
      Modified variables: vec.wrapped[] vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt size(vec.wrapped[])
modifies vec.wrapped[*], vec.wrapped[newTerm.coeff.numer], vec.wrapped[newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.numer..], vec.wrapped[newTerm.coeff.numer+1..], vec.wrapped[0..newTerm.coeff.numer], vec.wrapped[0..newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.denom], vec.wrapped[newTerm.coeff.denom-1], vec.wrapped[newTerm.coeff.denom..], vec.wrapped[newTerm.coeff.denom+1..], vec.wrapped[0..newTerm.coeff.denom], vec.wrapped[0..newTerm.coeff.denom-1], vec.wrapped[newTerm.expt], vec.wrapped[newTerm.expt-1], vec.wrapped[newTerm.expt..], vec.wrapped[newTerm.expt+1..], vec.wrapped[0..newTerm.expt], vec.wrapped[0..newTerm.expt-1]
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT319
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1] vec.wrapped[orig(newTerm.coeff.numer)] vec.wrapped[orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.numer)..] vec.wrapped[orig(newTerm.coeff.numer)+1..] vec.wrapped[0..orig(newTerm.coeff.numer)] vec.wrapped[0..orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.denom)] vec.wrapped[orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.coeff.denom)..] vec.wrapped[orig(newTerm.coeff.denom)+1..] vec.wrapped[0..orig(newTerm.coeff.denom)] vec.wrapped[0..orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.expt)] vec.wrapped[orig(newTerm.expt)-1] vec.wrapped[orig(newTerm.expt)..] vec.wrapped[orig(newTerm.expt)+1..] vec.wrapped[0..orig(newTerm.expt)] vec.wrapped[0..orig(newTerm.expt)-1] orig(vec.wrapped[post(newTerm.coeff.numer)]) orig(vec.wrapped[post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.numer)..]) orig(vec.wrapped[post(newTerm.coeff.numer)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.numer)]) orig(vec.wrapped[0..post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)]) orig(vec.wrapped[post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)..]) orig(vec.wrapped[post(newTerm.coeff.denom)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.denom)]) orig(vec.wrapped[0..post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.expt)]) orig(vec.wrapped[post(newTerm.expt)-1]) orig(vec.wrapped[post(newTerm.expt)..]) orig(vec.wrapped[post(newTerm.expt)+1..]) orig(vec.wrapped[0..post(newTerm.expt)]) orig(vec.wrapped[0..post(newTerm.expt)-1]) orig(vec.wrapped[newTerm.coeff.numer]) orig(vec.wrapped[newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.numer..]) orig(vec.wrapped[newTerm.coeff.numer+1..]) orig(vec.wrapped[0..newTerm.coeff.numer]) orig(vec.wrapped[0..newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.denom]) orig(vec.wrapped[newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.coeff.denom..]) orig(vec.wrapped[newTerm.coeff.denom+1..]) orig(vec.wrapped[0..newTerm.coeff.denom]) orig(vec.wrapped[0..newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.expt]) orig(vec.wrapped[newTerm.expt-1]) orig(vec.wrapped[newTerm.expt..]) orig(vec.wrapped[newTerm.expt+1..]) orig(vec.wrapped[0..newTerm.expt]) orig(vec.wrapped[0..newTerm.expt-1])
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[]) vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[0..newTerm.coeff.denom-1]
modifies vec.wrapped[*], vec.wrapped[newTerm.coeff.numer], vec.wrapped[newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.numer..], vec.wrapped[newTerm.coeff.numer+1..], vec.wrapped[0..newTerm.coeff.numer], vec.wrapped[0..newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.denom], vec.wrapped[newTerm.coeff.denom..], vec.wrapped[newTerm.coeff.denom+1..], vec.wrapped[0..newTerm.coeff.denom], vec.wrapped[newTerm.expt], vec.wrapped[newTerm.expt-1], vec.wrapped[newTerm.expt..], vec.wrapped[newTerm.expt+1..], vec.wrapped[0..newTerm.expt], vec.wrapped[0..newTerm.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 == orig(size(vec.wrapped[]))
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.numer-1] == vec.wrapped[newTerm.coeff.denom]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.denom] == vec.wrapped[orig(newTerm.coeff.numer)-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.denom-1] == orig(vec.wrapped[post(newTerm.coeff.denom)-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[0..newTerm.coeff.denom-1] == orig(vec.wrapped[0..post(newTerm.coeff.denom)-1])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[post(newTerm.coeff.numer)-1]) == orig(vec.wrapped[newTerm.coeff.denom])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer-1]) == orig(vec.wrapped[newTerm.coeff.denom])
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm.coeff.numer == 2
newTerm.coeff.denom == 1
newTerm.expt == 4 || newTerm.expt == 6
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[].getClass().getName()) one of { [PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm], [PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm] }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) one of { 5, 6 }
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a superset of orig(vec.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(newTerm) in vec.wrapped[]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.numer] in orig(vec.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(newTerm) in vec.wrapped[newTerm.coeff.denom..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.numer] in orig(vec.wrapped[0..newTerm.coeff.numer])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[newTerm.coeff.numer] in orig(vec.wrapped[newTerm.coeff.denom..])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer]) in vec.wrapped[newTerm.coeff.numer..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer+1..]) is a subsequence of vec.wrapped[newTerm.coeff.numer..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer+1..]) is a subsequence of vec.wrapped[newTerm.coeff.numer+1..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.denom]) in vec.wrapped[0..newTerm.coeff.numer]
warning: method daikon.inv.binary.sequenceScalar.SeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[0..newTerm.coeff.denom-1] elements == vec.wrapped[newTerm.coeff.denom-1]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer]) in vec.wrapped[newTerm.coeff.denom..]
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.numer+1..]) is a subsequence of vec.wrapped[newTerm.coeff.denom..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[newTerm.coeff.denom]) in vec.wrapped[newTerm.coeff.denom..]
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT328
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1] vec.wrapped[orig(newTerm.coeff.numer)] vec.wrapped[orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.numer)..] vec.wrapped[orig(newTerm.coeff.numer)+1..] vec.wrapped[0..orig(newTerm.coeff.numer)] vec.wrapped[0..orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.denom)] vec.wrapped[orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.coeff.denom)..] vec.wrapped[orig(newTerm.coeff.denom)+1..] vec.wrapped[0..orig(newTerm.coeff.denom)] vec.wrapped[0..orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.expt)] vec.wrapped[orig(newTerm.expt)-1] vec.wrapped[orig(newTerm.expt)..] vec.wrapped[orig(newTerm.expt)+1..] vec.wrapped[0..orig(newTerm.expt)] vec.wrapped[0..orig(newTerm.expt)-1] orig(vec.wrapped[post(newTerm.coeff.numer)]) orig(vec.wrapped[post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.numer)..]) orig(vec.wrapped[post(newTerm.coeff.numer)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.numer)]) orig(vec.wrapped[0..post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)]) orig(vec.wrapped[post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)..]) orig(vec.wrapped[post(newTerm.coeff.denom)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.denom)]) orig(vec.wrapped[0..post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.expt)]) orig(vec.wrapped[post(newTerm.expt)-1]) orig(vec.wrapped[post(newTerm.expt)..]) orig(vec.wrapped[post(newTerm.expt)+1..]) orig(vec.wrapped[0..post(newTerm.expt)]) orig(vec.wrapped[0..post(newTerm.expt)-1]) orig(vec.wrapped[newTerm.coeff.numer]) orig(vec.wrapped[newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.numer..]) orig(vec.wrapped[newTerm.coeff.numer+1..]) orig(vec.wrapped[0..newTerm.coeff.numer]) orig(vec.wrapped[0..newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.denom]) orig(vec.wrapped[newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.coeff.denom..]) orig(vec.wrapped[newTerm.coeff.denom+1..]) orig(vec.wrapped[0..newTerm.coeff.denom]) orig(vec.wrapped[0..newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.expt]) orig(vec.wrapped[newTerm.expt-1]) orig(vec.wrapped[newTerm.expt..]) orig(vec.wrapped[newTerm.expt+1..]) orig(vec.wrapped[0..newTerm.expt]) orig(vec.wrapped[0..newTerm.expt-1])
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[]) vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*], vec.wrapped[newTerm.coeff.numer], vec.wrapped[newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.numer..], vec.wrapped[newTerm.coeff.numer+1..], vec.wrapped[0..newTerm.coeff.numer], vec.wrapped[0..newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.denom], vec.wrapped[newTerm.coeff.denom-1], vec.wrapped[newTerm.coeff.denom..], vec.wrapped[newTerm.coeff.denom+1..], vec.wrapped[0..newTerm.coeff.denom], vec.wrapped[0..newTerm.coeff.denom-1], vec.wrapped[newTerm.expt], vec.wrapped[newTerm.expt-1], vec.wrapped[newTerm.expt..], vec.wrapped[newTerm.expt+1..], vec.wrapped[0..newTerm.expt], vec.wrapped[0..newTerm.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 == orig(size(vec.wrapped[]))
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[]) is a subsequence of vec.wrapped[]
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a superset of orig(vec.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(newTerm) in vec.wrapped[]
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1 vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1] vec.wrapped[orig(newTerm.coeff.numer)] vec.wrapped[orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.numer)..] vec.wrapped[orig(newTerm.coeff.numer)+1..] vec.wrapped[0..orig(newTerm.coeff.numer)] vec.wrapped[0..orig(newTerm.coeff.numer)-1] vec.wrapped[orig(newTerm.coeff.denom)] vec.wrapped[orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.coeff.denom)..] vec.wrapped[orig(newTerm.coeff.denom)+1..] vec.wrapped[0..orig(newTerm.coeff.denom)] vec.wrapped[0..orig(newTerm.coeff.denom)-1] vec.wrapped[orig(newTerm.expt)] vec.wrapped[orig(newTerm.expt)-1] vec.wrapped[orig(newTerm.expt)..] vec.wrapped[orig(newTerm.expt)+1..] vec.wrapped[0..orig(newTerm.expt)] vec.wrapped[0..orig(newTerm.expt)-1] orig(vec.wrapped[post(newTerm.coeff.numer)]) orig(vec.wrapped[post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.numer)..]) orig(vec.wrapped[post(newTerm.coeff.numer)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.numer)]) orig(vec.wrapped[0..post(newTerm.coeff.numer)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)]) orig(vec.wrapped[post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.coeff.denom)..]) orig(vec.wrapped[post(newTerm.coeff.denom)+1..]) orig(vec.wrapped[0..post(newTerm.coeff.denom)]) orig(vec.wrapped[0..post(newTerm.coeff.denom)-1]) orig(vec.wrapped[post(newTerm.expt)]) orig(vec.wrapped[post(newTerm.expt)-1]) orig(vec.wrapped[post(newTerm.expt)..]) orig(vec.wrapped[post(newTerm.expt)+1..]) orig(vec.wrapped[0..post(newTerm.expt)]) orig(vec.wrapped[0..post(newTerm.expt)-1]) orig(vec.wrapped[newTerm.coeff.numer]) orig(vec.wrapped[newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.numer..]) orig(vec.wrapped[newTerm.coeff.numer+1..]) orig(vec.wrapped[0..newTerm.coeff.numer]) orig(vec.wrapped[0..newTerm.coeff.numer-1]) orig(vec.wrapped[newTerm.coeff.denom]) orig(vec.wrapped[newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.coeff.denom..]) orig(vec.wrapped[newTerm.coeff.denom+1..]) orig(vec.wrapped[0..newTerm.coeff.denom]) orig(vec.wrapped[0..newTerm.coeff.denom-1]) orig(vec.wrapped[newTerm.expt]) orig(vec.wrapped[newTerm.expt-1]) orig(vec.wrapped[newTerm.expt..]) orig(vec.wrapped[newTerm.expt+1..]) orig(vec.wrapped[0..newTerm.expt]) orig(vec.wrapped[0..newTerm.expt-1])
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[]) vec.wrapped[newTerm.coeff.numer] vec.wrapped[newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.numer..] vec.wrapped[newTerm.coeff.numer+1..] vec.wrapped[0..newTerm.coeff.numer] vec.wrapped[0..newTerm.coeff.numer-1] vec.wrapped[newTerm.coeff.denom] vec.wrapped[newTerm.coeff.denom-1] vec.wrapped[newTerm.coeff.denom..] vec.wrapped[newTerm.coeff.denom+1..] vec.wrapped[0..newTerm.coeff.denom] vec.wrapped[0..newTerm.coeff.denom-1] vec.wrapped[newTerm.expt] vec.wrapped[newTerm.expt-1] vec.wrapped[newTerm.expt..] vec.wrapped[newTerm.expt+1..] vec.wrapped[0..newTerm.expt] vec.wrapped[0..newTerm.expt-1]
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*], vec.wrapped[newTerm.coeff.numer], vec.wrapped[newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.numer..], vec.wrapped[newTerm.coeff.numer+1..], vec.wrapped[0..newTerm.coeff.numer], vec.wrapped[0..newTerm.coeff.numer-1], vec.wrapped[newTerm.coeff.denom], vec.wrapped[newTerm.coeff.denom-1], vec.wrapped[newTerm.coeff.denom..], vec.wrapped[newTerm.coeff.denom+1..], vec.wrapped[0..newTerm.coeff.denom], vec.wrapped[0..newTerm.coeff.denom-1], vec.wrapped[newTerm.expt], vec.wrapped[newTerm.expt-1], vec.wrapped[newTerm.expt..], vec.wrapped[newTerm.expt+1..], vec.wrapped[0..newTerm.expt], vec.wrapped[0..newTerm.expt-1]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(vec.wrapped[]) == 0) ==> (newTerm.expt == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(vec.wrapped[]) == 0) ==> (orig(size(vec.wrapped[]))-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= orig(size(vec.wrapped[]))-1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (orig(size(vec.wrapped[])) == 0) ==> (size(vec.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 <= orig(size(vec.wrapped[]))
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p != null
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT372
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == return.terms.wrapped[]
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 >= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT376
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] == return.terms.wrapped[]
\result == \old(p)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT379
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 >= size(p.terms.wrapped[])-1
warning: method daikon.inv.ternary.threeScalar.FunctionBinary$GcdLong_xyz.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == (plume.MathMDE.gcd(size(p.terms.wrapped[]), size(return.terms.wrapped[])))
warning: method daikon.inv.ternary.threeScalar.FunctionBinary$MultiplyLong_xyz.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 == (size(p.terms.wrapped[])-1 * size(return.terms.wrapped[])-1)
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(p.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(p.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) == 0) ==> (size(this.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[])-1 <= size(return.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[])-1 & size(return.terms.wrapped[])-1) == 0
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[]) == 0) ==> (size(return.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= size(return.terms.wrapped[])-1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) == 0) ==> (size(p.terms.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[])-1 <= size(return.terms.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(p.terms.wrapped[])-1 & size(return.terms.wrapped[])-1) == 0
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) & size(return.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.toString():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.toString():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly.unparse():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT165
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
\result != null
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString == "0"
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT196
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return has only one value)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return.toString == "0")
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (size(this.terms.wrapped[]) is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[].getClass().getName() == [])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTerm:::OBJECT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
this.coeff != null
this.coeff.denom >= 0
this.expt >= 0
(this.coeff.denom == 0) ==> (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::ENTER
    Variables: c c.numer c.denom e
c != null
c.denom >= 0
e >= 0
(c.denom == 0) ==> (e == 0)
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt c c.numer c.denom e orig(c) orig(c.numer) orig(c.denom) orig(e)
      Unmodified variables: c c.numer c.denom e
this.coeff == \old(c)
this.coeff.numer == c.numer
this.coeff.denom == c.denom
this.expt == \old(e)
c.denom >= 0
(c.denom == 0) ==> (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.debugPrint():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
===========================================================================
PolyCalc.RatTerm.debugPrint():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
      Unmodified variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTerm.toString():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
===========================================================================
PolyCalc.RatTerm.toString():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
      Unmodified variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec:::OBJECT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
this.wrapped != null
this.wrapped.containsNull == false
this.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatTermVec.RatTermVec():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[].getClass().getName() == []
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt size(this.wrapped[]) size(this.wrapped[])-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1]
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t != null
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
(t.coeff.denom == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (t.coeff.denom == 0) ==> (size(this.wrapped[]) == 0)
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1] this.wrapped[orig(t.coeff.numer)] this.wrapped[orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.numer)..] this.wrapped[orig(t.coeff.numer)+1..] this.wrapped[0..orig(t.coeff.numer)] this.wrapped[0..orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.denom)] this.wrapped[orig(t.coeff.denom)-1] this.wrapped[orig(t.coeff.denom)..] this.wrapped[orig(t.coeff.denom)+1..] this.wrapped[0..orig(t.coeff.denom)] this.wrapped[0..orig(t.coeff.denom)-1] this.wrapped[orig(t.expt)] this.wrapped[orig(t.expt)-1] this.wrapped[orig(t.expt)..] this.wrapped[orig(t.expt)+1..] this.wrapped[0..orig(t.expt)] this.wrapped[0..orig(t.expt)-1] orig(this.wrapped[post(t.coeff.numer)]) orig(this.wrapped[post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.numer)..]) orig(this.wrapped[post(t.coeff.numer)+1..]) orig(this.wrapped[0..post(t.coeff.numer)]) orig(this.wrapped[0..post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.denom)]) orig(this.wrapped[post(t.coeff.denom)-1]) orig(this.wrapped[post(t.coeff.denom)..]) orig(this.wrapped[post(t.coeff.denom)+1..]) orig(this.wrapped[0..post(t.coeff.denom)]) orig(this.wrapped[0..post(t.coeff.denom)-1]) orig(this.wrapped[post(t.expt)]) orig(this.wrapped[post(t.expt)-1]) orig(this.wrapped[post(t.expt)..]) orig(this.wrapped[post(t.expt)+1..]) orig(this.wrapped[0..post(t.expt)]) orig(this.wrapped[0..post(t.expt)-1]) orig(this.wrapped[t.coeff.numer]) orig(this.wrapped[t.coeff.numer-1]) orig(this.wrapped[t.coeff.numer..]) orig(this.wrapped[t.coeff.numer+1..]) orig(this.wrapped[0..t.coeff.numer]) orig(this.wrapped[0..t.coeff.numer-1]) orig(this.wrapped[t.coeff.denom]) orig(this.wrapped[t.coeff.denom-1]) orig(this.wrapped[t.coeff.denom..]) orig(this.wrapped[t.coeff.denom+1..]) orig(this.wrapped[0..t.coeff.denom]) orig(this.wrapped[0..t.coeff.denom-1]) orig(this.wrapped[t.expt]) orig(this.wrapped[t.expt-1]) orig(this.wrapped[t.expt..]) orig(this.wrapped[t.expt+1..]) orig(this.wrapped[0..t.expt]) orig(this.wrapped[0..t.expt-1])
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1]
      Unmodified variables: this this.wrapped t t.coeff t.coeff.numer t.coeff.denom t.expt
modifies this.wrapped[*], this.wrapped[t.coeff.numer], this.wrapped[t.coeff.numer-1], this.wrapped[t.coeff.numer..], this.wrapped[t.coeff.numer+1..], this.wrapped[0..t.coeff.numer], this.wrapped[0..t.coeff.numer-1], this.wrapped[t.coeff.denom], this.wrapped[t.coeff.denom-1], this.wrapped[t.coeff.denom..], this.wrapped[t.coeff.denom+1..], this.wrapped[0..t.coeff.denom], this.wrapped[0..t.coeff.denom-1], this.wrapped[t.expt], this.wrapped[t.expt-1], this.wrapped[t.expt..], this.wrapped[t.expt+1..], this.wrapped[0..t.expt], this.wrapped[0..t.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[])-1 == orig(size(this.wrapped[]))
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(this.wrapped[]) is a subsequence of this.wrapped[]
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a superset of orig(this.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[]
(t.coeff.denom == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (t.coeff.denom == 0) ==> (size(this.wrapped[])-1 == 0)
===========================================================================
PolyCalc.RatTermVec.copy():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
===========================================================================
PolyCalc.RatTermVec.copy():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.wrapped return.wrapped[] return.wrapped[].getClass().getName() orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 size(return.wrapped[]) size(return.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] == return.wrapped[]
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
\result != null
\result.wrapped != null
===========================================================================
PolyCalc.RatTermVec.get(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1 this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1]
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[index+1..] contains no duplicates
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..index] contains no duplicates
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (index == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: index <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.get(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index return return.coeff return.coeff.numer return.coeff.denom return.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1] this.wrapped[return.coeff.numer] this.wrapped[return.coeff.numer-1] this.wrapped[return.coeff.numer..] this.wrapped[return.coeff.numer+1..] this.wrapped[0..return.coeff.numer] this.wrapped[0..return.coeff.numer-1] this.wrapped[return.coeff.denom] this.wrapped[return.coeff.denom-1] this.wrapped[return.coeff.denom..] this.wrapped[return.coeff.denom+1..] this.wrapped[0..return.coeff.denom] this.wrapped[0..return.coeff.denom-1] this.wrapped[return.expt] this.wrapped[return.expt-1] this.wrapped[return.expt..] this.wrapped[return.expt+1..] this.wrapped[0..return.expt] this.wrapped[0..return.expt-1] this.wrapped[orig(index)] this.wrapped[orig(index)-1] this.wrapped[orig(index)..] this.wrapped[orig(index)+1..] this.wrapped[0..orig(index)] this.wrapped[0..orig(index)-1] orig(this.wrapped[post(index)]) orig(this.wrapped[post(index)-1]) orig(this.wrapped[post(index)..]) orig(this.wrapped[post(index)+1..]) orig(this.wrapped[0..post(index)]) orig(this.wrapped[0..post(index)-1]) orig(this.wrapped[post(return.coeff.numer)]) orig(this.wrapped[post(return.coeff.numer)-1]) orig(this.wrapped[post(return.coeff.numer)..]) orig(this.wrapped[post(return.coeff.numer)+1..]) orig(this.wrapped[0..post(return.coeff.numer)]) orig(this.wrapped[0..post(return.coeff.numer)-1]) orig(this.wrapped[post(return.coeff.denom)]) orig(this.wrapped[post(return.coeff.denom)-1]) orig(this.wrapped[post(return.coeff.denom)..]) orig(this.wrapped[post(return.coeff.denom)+1..]) orig(this.wrapped[0..post(return.coeff.denom)]) orig(this.wrapped[0..post(return.coeff.denom)-1]) orig(this.wrapped[post(return.expt)]) orig(this.wrapped[post(return.expt)-1]) orig(this.wrapped[post(return.expt)..]) orig(this.wrapped[post(return.expt)+1..]) orig(this.wrapped[0..post(return.expt)]) orig(this.wrapped[0..post(return.expt)-1]) orig(this.wrapped[index]) orig(this.wrapped[index-1]) orig(this.wrapped[index..]) orig(this.wrapped[index+1..]) orig(this.wrapped[0..index]) orig(this.wrapped[0..index-1])
      Modified primitive arguments: this.wrapped[index-1]
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) this.wrapped[index] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == this.wrapped[orig(index)]
\result != null
\result.coeff != null
\result.coeff.denom >= 0
\result.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)+1..] contains no duplicates
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)] contains no duplicates
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in this.wrapped[]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in this.wrapped[orig(index)..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: return in this.wrapped[0..orig(index)]
(\result.coeff.numer == 0) ==> (\result.expt == 0)
(\result.coeff.numer == 0) ==> (\old(index) == 0)
(\result.coeff.denom == 0) ==> (\result.expt == 0)
(\result.coeff.denom == 0) ==> (\old(index) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (return.coeff.denom == 0) ==> (size(this.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (orig(index) == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(index) <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1] this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1]
t != null
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
index >= 0
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..index-1] contains no duplicates
(index == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[]) == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[]) == 0) ==> (index == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: index <= size(this.wrapped[])
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1] this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1] this.wrapped[orig(t.coeff.numer)] this.wrapped[orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.numer)..] this.wrapped[orig(t.coeff.numer)+1..] this.wrapped[0..orig(t.coeff.numer)] this.wrapped[0..orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.denom)] this.wrapped[orig(t.coeff.denom)-1] this.wrapped[orig(t.coeff.denom)..] this.wrapped[orig(t.coeff.denom)+1..] this.wrapped[0..orig(t.coeff.denom)] this.wrapped[0..orig(t.coeff.denom)-1] this.wrapped[orig(t.expt)] this.wrapped[orig(t.expt)-1] this.wrapped[orig(t.expt)..] this.wrapped[orig(t.expt)+1..] this.wrapped[0..orig(t.expt)] this.wrapped[0..orig(t.expt)-1] this.wrapped[orig(index)] this.wrapped[orig(index)-1] this.wrapped[orig(index)..] this.wrapped[orig(index)+1..] this.wrapped[0..orig(index)] this.wrapped[0..orig(index)-1] orig(this.wrapped[post(t.coeff.numer)]) orig(this.wrapped[post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.numer)..]) orig(this.wrapped[post(t.coeff.numer)+1..]) orig(this.wrapped[0..post(t.coeff.numer)]) orig(this.wrapped[0..post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.denom)]) orig(this.wrapped[post(t.coeff.denom)-1]) orig(this.wrapped[post(t.coeff.denom)..]) orig(this.wrapped[post(t.coeff.denom)+1..]) orig(this.wrapped[0..post(t.coeff.denom)]) orig(this.wrapped[0..post(t.coeff.denom)-1]) orig(this.wrapped[post(t.expt)]) orig(this.wrapped[post(t.expt)-1]) orig(this.wrapped[post(t.expt)..]) orig(this.wrapped[post(t.expt)+1..]) orig(this.wrapped[0..post(t.expt)]) orig(this.wrapped[0..post(t.expt)-1]) orig(this.wrapped[post(index)]) orig(this.wrapped[post(index)-1]) orig(this.wrapped[post(index)..]) orig(this.wrapped[post(index)+1..]) orig(this.wrapped[0..post(index)]) orig(this.wrapped[0..post(index)-1]) orig(this.wrapped[t.coeff.numer]) orig(this.wrapped[t.coeff.numer-1]) orig(this.wrapped[t.coeff.numer..]) orig(this.wrapped[t.coeff.numer+1..]) orig(this.wrapped[0..t.coeff.numer]) orig(this.wrapped[0..t.coeff.numer-1]) orig(this.wrapped[t.coeff.denom]) orig(this.wrapped[t.coeff.denom-1]) orig(this.wrapped[t.coeff.denom..]) orig(this.wrapped[t.coeff.denom+1..]) orig(this.wrapped[0..t.coeff.denom]) orig(this.wrapped[0..t.coeff.denom-1]) orig(this.wrapped[t.expt]) orig(this.wrapped[t.expt-1]) orig(this.wrapped[t.expt..]) orig(this.wrapped[t.expt+1..]) orig(this.wrapped[0..t.expt]) orig(this.wrapped[0..t.expt-1]) orig(this.wrapped[index]) orig(this.wrapped[index-1]) orig(this.wrapped[index..]) orig(this.wrapped[index+1..]) orig(this.wrapped[0..index]) orig(this.wrapped[0..index-1])
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1]
      Modified primitive arguments: this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index]
      Unmodified variables: this this.wrapped t t.coeff t.coeff.numer t.coeff.denom t.expt index this.wrapped[0..index-1]
modifies this.wrapped[*], this.wrapped[t.coeff.numer], this.wrapped[t.coeff.numer-1], this.wrapped[t.coeff.numer..], this.wrapped[t.coeff.numer+1..], this.wrapped[0..t.coeff.numer], this.wrapped[0..t.coeff.numer-1], this.wrapped[t.coeff.denom], this.wrapped[t.coeff.denom-1], this.wrapped[t.coeff.denom..], this.wrapped[t.coeff.denom+1..], this.wrapped[0..t.coeff.denom], this.wrapped[0..t.coeff.denom-1], this.wrapped[t.expt], this.wrapped[t.expt-1], this.wrapped[t.expt..], this.wrapped[t.expt+1..], this.wrapped[0..t.expt], this.wrapped[0..t.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) == this.wrapped[orig(index)]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[])-1 == orig(size(this.wrapped[]))
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)+1..] == orig(this.wrapped[index..])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..post(index)-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..index-1])
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] contains no duplicates
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a superset of orig(this.wrapped[])
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[]
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: t.coeff.numer <= size(this.wrapped[])
(\old(index) == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.twoScalar.IntNonEqual.format(OutputFormat:ESC/Java) needs to be implemented: t.expt != size(this.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (t.expt == 0)
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[orig(index)..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[0..orig(index)]
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (orig(index) == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(index) <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.printDebug():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.printDebug():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec.remove(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1 this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1]
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (index == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: index <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.remove(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1] this.wrapped[orig(index)] this.wrapped[orig(index)-1] this.wrapped[orig(index)..] this.wrapped[orig(index)+1..] this.wrapped[0..orig(index)] this.wrapped[0..orig(index)-1] orig(this.wrapped[post(index)]) orig(this.wrapped[post(index)-1]) orig(this.wrapped[post(index)..]) orig(this.wrapped[post(index)+1..]) orig(this.wrapped[0..post(index)]) orig(this.wrapped[0..post(index)-1]) orig(this.wrapped[index]) orig(this.wrapped[index-1]) orig(this.wrapped[index..]) orig(this.wrapped[index+1..]) orig(this.wrapped[0..index]) orig(this.wrapped[0..index-1])
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
      Modified primitive arguments: this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index]
      Unmodified variables: this this.wrapped index this.wrapped[0..index-1]
modifies this.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) == orig(size(this.wrapped[]))-1
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)..] == orig(this.wrapped[post(index)+1..])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)..] == orig(this.wrapped[index+1..])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..post(index)-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..index-1])
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
warning: method daikon.inv.binary.twoSequence.SubSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a subset of orig(this.wrapped[])
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[]) == 0) ==> (orig(index) == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(index) <= size(this.wrapped[])
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1] this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1]
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t != null
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
(t.coeff.denom == 0) ==> (t.expt == 0)
(t.coeff.denom == 0) ==> (index == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (t.coeff.denom == 0) ==> (size(this.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (index == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: index <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1] this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[index+1..] this.wrapped[0..index] this.wrapped[0..index-1] this.wrapped[orig(t.coeff.numer)] this.wrapped[orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.numer)..] this.wrapped[orig(t.coeff.numer)+1..] this.wrapped[0..orig(t.coeff.numer)] this.wrapped[0..orig(t.coeff.numer)-1] this.wrapped[orig(t.coeff.denom)] this.wrapped[orig(t.coeff.denom)-1] this.wrapped[orig(t.coeff.denom)..] this.wrapped[orig(t.coeff.denom)+1..] this.wrapped[0..orig(t.coeff.denom)] this.wrapped[0..orig(t.coeff.denom)-1] this.wrapped[orig(t.expt)] this.wrapped[orig(t.expt)-1] this.wrapped[orig(t.expt)..] this.wrapped[orig(t.expt)+1..] this.wrapped[0..orig(t.expt)] this.wrapped[0..orig(t.expt)-1] this.wrapped[orig(index)] this.wrapped[orig(index)-1] this.wrapped[orig(index)..] this.wrapped[orig(index)+1..] this.wrapped[0..orig(index)] this.wrapped[0..orig(index)-1] orig(this.wrapped[post(t.coeff.numer)]) orig(this.wrapped[post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.numer)..]) orig(this.wrapped[post(t.coeff.numer)+1..]) orig(this.wrapped[0..post(t.coeff.numer)]) orig(this.wrapped[0..post(t.coeff.numer)-1]) orig(this.wrapped[post(t.coeff.denom)]) orig(this.wrapped[post(t.coeff.denom)-1]) orig(this.wrapped[post(t.coeff.denom)..]) orig(this.wrapped[post(t.coeff.denom)+1..]) orig(this.wrapped[0..post(t.coeff.denom)]) orig(this.wrapped[0..post(t.coeff.denom)-1]) orig(this.wrapped[post(t.expt)]) orig(this.wrapped[post(t.expt)-1]) orig(this.wrapped[post(t.expt)..]) orig(this.wrapped[post(t.expt)+1..]) orig(this.wrapped[0..post(t.expt)]) orig(this.wrapped[0..post(t.expt)-1]) orig(this.wrapped[post(index)]) orig(this.wrapped[post(index)-1]) orig(this.wrapped[post(index)..]) orig(this.wrapped[post(index)+1..]) orig(this.wrapped[0..post(index)]) orig(this.wrapped[0..post(index)-1]) orig(this.wrapped[t.coeff.numer]) orig(this.wrapped[t.coeff.numer-1]) orig(this.wrapped[t.coeff.numer..]) orig(this.wrapped[t.coeff.numer+1..]) orig(this.wrapped[0..t.coeff.numer]) orig(this.wrapped[0..t.coeff.numer-1]) orig(this.wrapped[t.coeff.denom]) orig(this.wrapped[t.coeff.denom-1]) orig(this.wrapped[t.coeff.denom..]) orig(this.wrapped[t.coeff.denom+1..]) orig(this.wrapped[0..t.coeff.denom]) orig(this.wrapped[0..t.coeff.denom-1]) orig(this.wrapped[t.expt]) orig(this.wrapped[t.expt-1]) orig(this.wrapped[t.expt..]) orig(this.wrapped[t.expt+1..]) orig(this.wrapped[0..t.expt]) orig(this.wrapped[0..t.expt-1]) orig(this.wrapped[index]) orig(this.wrapped[index-1]) orig(this.wrapped[index..]) orig(this.wrapped[index+1..]) orig(this.wrapped[0..index]) orig(this.wrapped[0..index-1])
      Modified variables: this.wrapped[] this.wrapped[t.coeff.numer] this.wrapped[t.coeff.numer-1] this.wrapped[t.coeff.numer..] this.wrapped[t.coeff.numer+1..] this.wrapped[0..t.coeff.numer] this.wrapped[0..t.coeff.numer-1] this.wrapped[t.coeff.denom] this.wrapped[t.coeff.denom-1] this.wrapped[t.coeff.denom..] this.wrapped[t.coeff.denom+1..] this.wrapped[0..t.coeff.denom] this.wrapped[0..t.coeff.denom-1] this.wrapped[t.expt] this.wrapped[t.expt-1] this.wrapped[t.expt..] this.wrapped[t.expt+1..] this.wrapped[0..t.expt] this.wrapped[0..t.expt-1]
      Modified primitive arguments: this.wrapped[index] this.wrapped[index-1] this.wrapped[index..] this.wrapped[0..index]
      Unmodified variables: this this.wrapped this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) this.wrapped[index+1..] this.wrapped[0..index-1]
modifies this.wrapped[*], this.wrapped[t.coeff.numer], this.wrapped[t.coeff.numer-1], this.wrapped[t.coeff.numer..], this.wrapped[t.coeff.numer+1..], this.wrapped[0..t.coeff.numer], this.wrapped[0..t.coeff.numer-1], this.wrapped[t.coeff.denom], this.wrapped[t.coeff.denom-1], this.wrapped[t.coeff.denom..], this.wrapped[t.coeff.denom+1..], this.wrapped[0..t.coeff.denom], this.wrapped[0..t.coeff.denom-1], this.wrapped[t.expt], this.wrapped[t.expt-1], this.wrapped[t.expt..], this.wrapped[t.expt+1..], this.wrapped[0..t.expt], this.wrapped[0..t.expt-1]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) == this.wrapped[orig(index)]
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)+1..] == orig(this.wrapped[post(index)+1..])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[orig(index)+1..] == orig(this.wrapped[index+1..])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..post(index)-1])
warning: method daikon.inv.binary.twoSequence.SeqSeqIntEqual.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[0..orig(index)-1] == orig(this.wrapped[0..index-1])
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[]
(t.coeff.denom == 0) ==> (t.expt == 0)
(t.coeff.denom == 0) ==> (\old(index) == 0)
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (t.coeff.denom == 0) ==> (size(this.wrapped[])-1 == 0)
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[orig(index)..]
warning: method daikon.inv.binary.sequenceScalar.Member.format(OutputFormat:ESC/Java) needs to be implemented: orig(t) in this.wrapped[0..orig(index)]
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.wrapped[])-1 == 0) ==> (orig(index) == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: orig(index) <= size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.size():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
===========================================================================
PolyCalc.RatTermVec.size():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1 this.wrapped[return] this.wrapped[return-1] this.wrapped[return..] this.wrapped[return+1..] this.wrapped[0..return] this.wrapped[0..return-1] orig(this.wrapped[post(return)]) orig(this.wrapped[post(return)-1]) orig(this.wrapped[post(return)..]) orig(this.wrapped[post(return)+1..]) orig(this.wrapped[0..post(return)]) orig(this.wrapped[0..post(return)-1])
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == size(this.wrapped[])
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: return == orig(size(this.wrapped[]))
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[return..] == []
===========================================================================
PolyCalc.RatTermVec.toString():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.toString():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
