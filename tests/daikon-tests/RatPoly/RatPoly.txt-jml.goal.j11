===========================================================================
PolyCalc.RatNum:::OBJECT
    Variables: this this.numer this.denom
this.denom >= 0
===========================================================================
PolyCalc.RatNum.RatNum(int):::ENTER
    Variables: n
===========================================================================
PolyCalc.RatNum.RatNum(int):::EXIT
    Variables: this this.numer this.denom n orig(n)
this.numer == \old(n)
this.denom == 1
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::ENTER
    Variables: n d
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT55
    Variables: this this.numer this.denom n d orig(n) orig(d)
this.numer == \old(n)
this.denom == \old(d)
this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT67
    Variables: this this.numer this.denom n d orig(n) orig(d)
this.denom >= 1
\old(d) != 0
\old(d) % this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT
    Variables: this this.numer this.denom n d orig(n) orig(d)
(this.denom == 0)  <==>  (\old(d) == 0)
(this.denom == 0)  ==>  (\old(d) is a pointer)
(this.denom == 0)  ==>  (this.denom == \old(d))
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer == \old(n))
(!(\old(n) == 0)) || (this.numer == 0)
(!(this.numer == 0)) || (\old(n) == 0)
(!(\old(d) == 0)) || (this.denom == 0)
(!(this.denom == 0)) || (\old(d) == 0)
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
arg.numer == \old(arg.numer)
arg.denom == \old(arg.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(!(this.denom == 0)) || (\result.denom == 0)
(!(arg.denom == 0)) || (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.approx():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT117
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.denom == 0
daikon.Quant.fuzzy.eq(\result, Double.NaN)
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT120
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.denom >= 1
===========================================================================
PolyCalc.RatNum.approx():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
(this.denom == 0)  ==>  (daikon.Quant.fuzzy.eq(\result, Double.NaN))
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer != this.denom)
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom rn rn.numer rn.denom
rn != null
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT101
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
this.denom >= 1
rn.denom >= 1
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT94
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
this.denom == \result
rn.denom == \result
\result == \old(this.denom)
\result == \old(rn.denom)
\result == 0
this.numer != \result
rn.numer != \result
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT96
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
this.denom == 0
rn.numer >= -1
rn.denom >= 1
\result == 1
this.numer != this.denom
this.denom < rn.denom
rn.denom >= \result
\result == (org.plumelib.util.MathPlume.gcd(rn.numer, rn.denom))
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT98
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
this.denom >= 1
rn.numer != 0
rn.denom == 0
\result == -1
this.denom > rn.denom
this.denom > \result
rn.numer != rn.denom
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
rn.numer == \old(rn.numer)
rn.denom == \old(rn.denom)
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.debugPrint():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.debugPrint():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT187
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
arg.numer == \result.numer
arg.denom == \result.denom
\result == \old(arg)
arg.denom == 0
(!(arg.numer == 0)) || (this.numer == 0)
this.denom >= arg.denom
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT189
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
arg.denom >= 1
(!(this.numer == 0)) || (\result.numer == 0)
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
arg.numer == \old(arg.numer)
arg.denom == \old(arg.denom)
(arg.denom == 0)  ==>  ((!(arg.numer == 0)) || (this.numer == 0))
(arg.denom == 0)  ==>  (arg.denom == \result.denom)
(arg.denom == 0)  ==>  (arg.denom is a pointer)
(arg.denom == 0)  ==>  (arg.numer == \result.numer)
(arg.denom == 0)  ==>  (\result == \old(arg))
(arg.denom == 0)  ==>  (\result.denom == 0)
(arg.denom == 0)  ==>  (\result.denom is a pointer)
(arg.denom == 0)  ==>  (this.denom >= arg.denom)
(arg.denom == 0)  ==>  (this.denom >= \result.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(!(\result.numer == 0)) || (this.numer == 0)
(!(this.denom == 0)) || (\result.denom == 0)
(!(arg.numer == 0)) || (\result.denom == 0)
(!(arg.denom == 0)) || (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::ENTER
    Variables: this this.numer this.denom obj obj.getClass().getName()
obj != null
obj.getClass().getName() == PolyCalc.RatNum.class.getName()
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT230
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
this.denom == 0
\result == true
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT232
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
(\result == true)  ==>  (this.denom >= 1)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
this.numer == \old(this.numer)
this.denom == \old(this.denom)
===========================================================================
PolyCalc.RatNum.gcd(int, int):::ENTER
    Variables: _a _b
_b != 0
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT209
    Variables: _a _b return orig(_a) orig(_b)
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT
    Variables: _a _b return orig(_a) orig(_b)
\result != 0
\old(_a) % \result == 0
\old(_b) % \result == 0
===========================================================================
PolyCalc.RatNum.isNaN():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNaN():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
(this.denom == 0)  <==>  (\result == true)
(this.denom == 0)  ==>  (this.denom is a pointer)
===========================================================================
PolyCalc.RatNum.isNegative():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNegative():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
(\result == true)  ==>  (this.denom >= 1)
(\result == true)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer <= -1)
===========================================================================
PolyCalc.RatNum.isPositive():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isPositive():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
(\result == false)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer != 0)
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
arg.numer == \old(arg.numer)
arg.denom == \old(arg.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(!(this.numer == 0)) || (\result.numer == 0)
(!(this.denom == 0)) || (\result.denom == 0)
(!(arg.numer == 0)) || (\result.numer == 0)
(!(arg.denom == 0)) || (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.negate():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.negate():::EXIT
    Variables: this this.numer this.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \result.denom
this.denom == \old(this.denom)
\result != null
(!(\result.numer == 0)) || (this.numer == 0)
(!(this.numer == 0)) || (\result.numer == 0)
this.numer + \result.numer == 0
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::ENTER
    Variables: ratStr ratStr.toString
ratStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ratStr.toString is printable
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT264
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
ratStr.toString().equals("NaN")
\result.numer == 1
\result.denom == 0
\old(ratStr) != null
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT267
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
\result.denom == 1
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT273
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
ratStr.toString().equals(\old(ratStr.toString()))
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: ratStr.toString is printable
\result != null
\result.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
arg.numer == \old(arg.numer)
arg.denom == \old(arg.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(!(this.denom == 0)) || (\result.denom == 0)
(!(arg.denom == 0)) || (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.toString():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.toString():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.unparse():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT133
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.denom == 0
\result != null
\result.toString().equals("NaN")
===========================================================================
PolyCalc.RatNum.unparse():::EXIT135
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.numer != 0
this.denom >= 2
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT137
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.denom == 1
===========================================================================
PolyCalc.RatNum.unparse():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
this.numer == \old(this.numer)
this.denom == \old(this.denom)
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly:::OBJECT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
this.terms != null
this.terms.wrapped != null
daikon.Quant.noDups(this.terms.wrapped)
daikon.Quant.eltsNotEqual(this.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.RatPoly():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  })
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::ENTER
    Variables: rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() size(rt.wrapped[]) size(rt.wrapped[])-1
rt != null
rt.wrapped != null
daikon.Quant.noDups(rt.wrapped)
daikon.Quant.eltsNotEqual(rt.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(rt.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() orig(rt) orig(rt.wrapped) orig(rt.wrapped[]) orig(rt.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(rt.wrapped[]) size(rt.wrapped[])-1 orig(size(rt.wrapped[])) orig(size(rt.wrapped[]))-1
this.terms == \old(rt)
this.terms.wrapped == rt.wrapped
rt.wrapped == \old(rt.wrapped)
daikon.Quant.pairwiseEqual(rt.wrapped, \old(rt.wrapped))
rt.wrapped != null
daikon.Quant.noDups(rt.wrapped)
daikon.Quant.eltsNotEqual(rt.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(rt.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::ENTER
    Variables: c e
e >= 0
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() c e orig(c) orig(e) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT350
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT354
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT363
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
p.terms == \old(p.terms)
p.terms.wrapped == \old(p.terms.wrapped)
daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped))
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.noDups(\result.terms.wrapped)
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::ENTER
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
sb != null
rt != null
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(!(rt.coeff.denom == 0)) || (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT229
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
rt.coeff == \old(rt.coeff)
rt.coeff.numer == \old(rt.coeff.numer)
rt.coeff.denom == \old(rt.coeff.denom)
rt.expt == \old(rt.expt)
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(!(rt.coeff.denom == 0)) || (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::ENTER
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() size(v.wrapped[]) size(v.wrapped[])-1
v != null
v.wrapped != null
daikon.Quant.noDups(v.wrapped)
daikon.Quant.eltsNotEqual(v.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(v.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::EXIT
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() orig(v) orig(v.wrapped) orig(v.wrapped[]) orig(v.wrapped[].getClass().getName()) size(v.wrapped[]) size(v.wrapped[])-1 orig(size(v.wrapped[])) orig(size(v.wrapped[]))-1
v.wrapped == \old(v.wrapped)
daikon.Quant.pairwiseEqual(v.wrapped, \old(v.wrapped))
v.wrapped != null
daikon.Quant.noDups(v.wrapped)
daikon.Quant.eltsNotEqual(v.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(v.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.checkRep():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.checkRep():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
===========================================================================
PolyCalc.RatPoly.coeff(int):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT120
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
\result.numer != 0
\old(deg) >= 0
daikon.Quant.size(this.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT124
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
\result.numer == 0
\result.denom == 1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
(\result.numer != 0)  ==>  (\old(deg) >= 0)
(\result.numer != 0)  ==>  (daikon.Quant.size(this.terms.wrapped) >= 1)
(\result.numer == 0)  ==>  (\result.denom == 1)
(\result.numer == 0)  ==>  (\result.numer < \result.denom)
(\result.numer == 0)  ==>  (\result.numer is a pointer)
\result != null
(!(\result.denom == 0)) || (\old(deg) == 0)
===========================================================================
PolyCalc.RatPoly.degree():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.degree():::EXIT102
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
daikon.Quant.size(this.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.degree():::EXIT105
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  })
\result == 0
===========================================================================
PolyCalc.RatPoly.degree():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result == 0)
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result is a pointer)
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.size(this.terms.wrapped) is a pointer)
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }))
\result >= 0
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT435
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT438
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
daikon.Quant.size(p.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
p.terms == \old(p.terms)
p.terms.wrapped == \old(p.terms.wrapped)
daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped))
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.noDups(\result.terms.wrapped)
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.size(p.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.getClass().getName() return[] return[].terms return[].terms.wrapped orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return[]) size(return[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
p.terms == \old(p.terms)
p.terms.wrapped == \old(p.terms.wrapped)
daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped))
p.terms != null
p.terms.wrapped != null
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
\result != null
\result.getClass().getName() == PolyCalc.RatPoly[].class.getName()
daikon.Quant.eltsNotEqual(\result, null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(\result, "terms"), null)
daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(\result, "terms.wrapped"), null)
daikon.Quant.size(p.terms.wrapped) >= 1
daikon.Quant.size(\result) == 2
===========================================================================
PolyCalc.RatPoly.eval(double):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
d >= 0.0
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1 || daikon.Quant.size(this.terms.wrapped) == 2
(daikon.Quant.size(this.terms.wrapped) & daikon.Quant.size(this.terms.wrapped)-1) == 0
===========================================================================
PolyCalc.RatPoly.eval(double):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(d) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1 || daikon.Quant.size(this.terms.wrapped) == 2
(daikon.Quant.size(this.terms.wrapped) & daikon.Quant.size(this.terms.wrapped)-1) == 0
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[]) size(ts.wrapped[])-1
ts != null
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
expt >= 0
daikon.Quant.size(ts.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT521
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT523
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT526
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
\result >= 1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
ts.wrapped == \old(ts.wrapped)
daikon.Quant.pairwiseEqual(ts.wrapped, \old(ts.wrapped))
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
\result >= 0
daikon.Quant.size(ts.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) size(ts.wrapped[])-1
ts != null
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
i >= 0
expt >= 0
daikon.Quant.size(ts.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT534
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT537
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
\result.coeff.numer == 0
\result.coeff.denom == 1
\old(i) >= 1
\result.coeff.numer <= \result.expt
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
ts.wrapped == \old(ts.wrapped)
daikon.Quant.pairwiseEqual(ts.wrapped, \old(ts.wrapped))
\result.expt == \old(expt)
(\result.coeff.numer == 0)  ==>  (\old(i) >= 1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.denom == 1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer < \result.coeff.denom)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer <= \result.expt)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer is a pointer)
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
\result != null
\result.coeff != null
\result.coeff.denom >= 1
\result.expt >= 0
daikon.Quant.size(ts.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
degree >= 0
daikon.Quant.size(vec.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(degree) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
vec.wrapped == \old(vec.wrapped)
daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped))
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
daikon.Quant.size(vec.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.isNaN():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT86
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
\result == true
daikon.Quant.size(this.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT90
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
\result == false
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
(\result == true)  ==>  (daikon.Quant.size(this.terms.wrapped) == 1)
(\result == true)  ==>  (daikon.Quant.size(this.terms.wrapped)-1 is a pointer)
(\result == true)  ==>  (daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" }))
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT390
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT394
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT404
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
p.terms == \old(p.terms)
p.terms.wrapped == \old(p.terms.wrapped)
daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped))
p.terms != null
p.terms.wrapped != null
daikon.Quant.noDups(p.terms.wrapped)
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.noDups(\result.terms.wrapped)
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.negate():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.negate():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 0 || daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::ENTER
    Variables: polyStr polyStr.toString
polyStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: polyStr.toString is printable
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::EXIT
    Variables: polyStr polyStr.toString return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(polyStr) orig(polyStr.toString) size(return.terms.wrapped[]) size(return.terms.wrapped[])-1
polyStr.toString().equals(\old(polyStr.toString()))
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: polyStr.toString is printable
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.noDups(\result.terms.wrapped)
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::ENTER
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index size(ts.wrapped[]) size(ts.wrapped[])-1
term != null
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts != null
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
index >= 1
daikon.Quant.size(ts.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::EXIT
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index orig(term) orig(term.coeff) orig(term.coeff.numer) orig(term.coeff.denom) orig(term.expt) orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(index) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
assignable ts.wrapped[*]
term.coeff == \old(term.coeff)
term.coeff.numer == \old(term.coeff.numer)
term.coeff.denom == \old(term.coeff.denom)
term.expt == \old(term.expt)
ts.wrapped == \old(ts.wrapped)
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts.wrapped != null
daikon.Quant.noDups(ts.wrapped)
daikon.Quant.eltsNotEqual(ts.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(ts.wrapped), "PolyCalc.RatTerm")
daikon.Quant.size(ts.wrapped) >= 1
(\old(daikon.Quant.size(ts.wrapped)) >> daikon.Quant.size(ts.wrapped) == 0)
daikon.Quant.size(ts.wrapped) >= \old(daikon.Quant.size(ts.wrapped))-1
daikon.Quant.size(ts.wrapped)-1 <= \old(daikon.Quant.size(ts.wrapped))
(!(daikon.Quant.size(ts.wrapped)-1 == 0)) || (\old(daikon.Quant.size(ts.wrapped))-1 == 0)
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
scalar != null
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
daikon.Quant.size(this.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(scalar) orig(scalar.coeff) orig(scalar.coeff.numer) orig(scalar.coeff.denom) orig(scalar.expt) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
scalar.coeff == \old(scalar.coeff)
scalar.coeff.numer == \old(scalar.coeff.numer)
scalar.coeff.denom == \old(scalar.coeff.denom)
scalar.expt == \old(scalar.expt)
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.noDups(\result.terms.wrapped)
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.size(this.terms.wrapped) >= 1
daikon.Quant.size(\result.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
scalar != null
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(scalar) orig(scalar.numer) orig(scalar.denom) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
vec.wrapped == \old(vec.wrapped)
scalar.numer == \old(scalar.numer)
scalar.denom == \old(scalar.denom)
daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped))
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
newTerm != null
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT308
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped))-1
newTerm.coeff.denom == 1
daikon.Quant.subsetOf(vec.wrapped, \old(vec.wrapped))
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT312
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped))
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT319
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
daikon.Quant.size(vec.wrapped)-1 == \old(daikon.Quant.size(vec.wrapped))
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(vec.wrapped), new String[] { "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm" }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(vec.wrapped), new String[] { "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm" })
newTerm.coeff.numer == 2
newTerm.coeff.denom == 1
newTerm.expt == 4 || newTerm.expt == 6
daikon.Quant.pairwiseEqual(\old(daikon.Quant.typeArray(vec.wrapped)), new String[] { "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm" }) || daikon.Quant.pairwiseEqual(\old(daikon.Quant.typeArray(vec.wrapped)), new String[] { "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm", "PolyCalc.RatTerm" })
daikon.Quant.size(vec.wrapped) == 5 || daikon.Quant.size(vec.wrapped) == 6
daikon.Quant.subsetOf(\old(vec.wrapped), vec.wrapped)
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT328
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
daikon.Quant.size(vec.wrapped)-1 == \old(daikon.Quant.size(vec.wrapped))
daikon.Quant.size(vec.wrapped) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: orig(vec.wrapped[]) is a subsequence of vec.wrapped[]
daikon.Quant.subsetOf(\old(vec.wrapped), vec.wrapped)
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
assignable vec.wrapped[*]
vec.wrapped == \old(vec.wrapped)
newTerm.coeff == \old(newTerm.coeff)
newTerm.coeff.numer == \old(newTerm.coeff.numer)
newTerm.coeff.denom == \old(newTerm.coeff.denom)
newTerm.expt == \old(newTerm.expt)
vec.wrapped != null
daikon.Quant.noDups(vec.wrapped)
daikon.Quant.eltsNotEqual(vec.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(vec.wrapped), "PolyCalc.RatTerm")
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
(!(daikon.Quant.size(vec.wrapped) == 0)) || (\old(daikon.Quant.size(vec.wrapped))-1 == 0)
daikon.Quant.size(vec.wrapped) >= \old(daikon.Quant.size(vec.wrapped))-1
(!(\old(daikon.Quant.size(vec.wrapped)) == 0)) || (daikon.Quant.size(vec.wrapped)-1 == 0)
daikon.Quant.size(vec.wrapped)-1 <= \old(daikon.Quant.size(vec.wrapped))
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
p != null
p.terms != null
p.terms.wrapped != null
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT372
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT376
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(\result.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT379
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
daikon.Quant.size(this.terms.wrapped) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
p.terms == \old(p.terms)
p.terms.wrapped == \old(p.terms.wrapped)
daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped))
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
p.terms != null
p.terms.wrapped != null
daikon.Quant.eltsNotEqual(p.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(p.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] {  }) || daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(p.terms.wrapped), new String[] { "PolyCalc.RatTerm" })
\result != null
\result.terms != null
\result.terms.wrapped != null
daikon.Quant.eltsNotEqual(\result.terms.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.terms.wrapped), "PolyCalc.RatTerm")
daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1
daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1
daikon.Quant.size(\result.terms.wrapped) == 0 || daikon.Quant.size(\result.terms.wrapped) == 1 || daikon.Quant.size(\result.terms.wrapped) == 2
(daikon.Quant.size(\result.terms.wrapped) & daikon.Quant.size(\result.terms.wrapped)-1) == 0
===========================================================================
PolyCalc.RatPoly.toString():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.toString():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly.unparse():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT165
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  })
\result != null
\result.toString().equals("0")
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT196
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
daikon.Quant.size(this.terms.wrapped) >= 1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
this.terms == \old(this.terms)
this.terms.wrapped == \old(this.terms.wrapped)
daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped))
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result != null)
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result.toString().equals("0"))
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.size(this.terms.wrapped) is a pointer)
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.terms.wrapped), new String[] {  }))
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTerm:::OBJECT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
this.coeff != null
this.coeff.denom >= 0
this.expt >= 0
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::ENTER
    Variables: c c.numer c.denom e
c != null
c.denom >= 0
e >= 0
(!(c.denom == 0)) || (e == 0)
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt c c.numer c.denom e orig(c) orig(c.numer) orig(c.denom) orig(e)
this.coeff == \old(c)
this.coeff.numer == c.numer
this.coeff.denom == c.denom
this.expt == \old(e)
c.numer == \old(c.numer)
c.denom == \old(c.denom)
c.denom >= 0
(!(c.denom == 0)) || (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.debugPrint():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
(!(this.coeff.denom == 0)) || (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.debugPrint():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
this.coeff == \old(this.coeff)
this.coeff.numer == \old(this.coeff.numer)
this.coeff.denom == \old(this.coeff.denom)
this.expt == \old(this.expt)
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
(!(this.coeff.denom == 0)) || (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.toString():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
===========================================================================
PolyCalc.RatTerm.toString():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
this.coeff == \old(this.coeff)
this.coeff.numer == \old(this.coeff.numer)
this.coeff.denom == \old(this.coeff.denom)
this.expt == \old(this.expt)
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec:::OBJECT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
this.wrapped != null
daikon.Quant.eltsNotEqual(this.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatTermVec.RatTermVec():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.pairwiseEqual(daikon.Quant.typeArray(this.wrapped), new String[] {  })
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt size(this.wrapped[]) size(this.wrapped[])-1
daikon.Quant.noDups(this.wrapped)
t != null
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
(!(t.coeff.denom == 0)) || (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
assignable this.wrapped[*]
this.wrapped == \old(this.wrapped)
t.coeff == \old(t.coeff)
t.coeff.numer == \old(t.coeff.numer)
t.coeff.denom == \old(t.coeff.denom)
t.expt == \old(t.expt)
daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped))
daikon.Quant.noDups(this.wrapped)
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
daikon.Quant.size(this.wrapped) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:JML) needs to be implemented: orig(this.wrapped[]) is a subsequence of this.wrapped[]
daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped)
(!(t.coeff.denom == 0)) || (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.copy():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
daikon.Quant.noDups(this.wrapped)
===========================================================================
PolyCalc.RatTermVec.copy():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.wrapped return.wrapped[] return.wrapped[].getClass().getName() orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 size(return.wrapped[]) size(return.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
this.wrapped == \old(this.wrapped)
daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped))
daikon.Quant.noDups(this.wrapped)
\result != null
\result.wrapped != null
daikon.Quant.noDups(\result.wrapped)
daikon.Quant.eltsNotEqual(\result.wrapped, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(\result.wrapped), "PolyCalc.RatTerm")
===========================================================================
PolyCalc.RatTermVec.get(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1
index >= 0
daikon.Quant.size(this.wrapped) >= 1
===========================================================================
PolyCalc.RatTermVec.get(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index return return.coeff return.coeff.numer return.coeff.denom return.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
this.wrapped == \old(this.wrapped)
daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped))
\result != null
\result.coeff != null
\result.coeff.denom >= 0
\result.expt >= 0
daikon.Quant.size(this.wrapped) >= 1
(!(\result.coeff.numer == 0)) || (\result.expt == 0)
(!(\result.coeff.denom == 0)) || (\result.expt == 0)
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1
t != null
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
index >= 0
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
assignable this.wrapped[*]
this.wrapped == \old(this.wrapped)
t.coeff == \old(t.coeff)
t.coeff.numer == \old(t.coeff.numer)
t.coeff.denom == \old(t.coeff.denom)
t.expt == \old(t.expt)
daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped))
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
daikon.Quant.size(this.wrapped) >= 1
daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped)
===========================================================================
PolyCalc.RatTermVec.printDebug():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.printDebug():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
this.wrapped == \old(this.wrapped)
daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped))
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec.remove(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1
daikon.Quant.noDups(this.wrapped)
index >= 0
daikon.Quant.size(this.wrapped) >= 1
===========================================================================
PolyCalc.RatTermVec.remove(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
assignable this.wrapped[*]
this.wrapped == \old(this.wrapped)
daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped))-1
daikon.Quant.noDups(this.wrapped)
daikon.Quant.subsetOf(this.wrapped, \old(this.wrapped))
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1
daikon.Quant.noDups(this.wrapped)
t != null
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
index >= 0
daikon.Quant.size(this.wrapped) >= 1
(!(t.coeff.denom == 0)) || (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
assignable this.wrapped[*]
this.wrapped == \old(this.wrapped)
t.coeff == \old(t.coeff)
t.coeff.numer == \old(t.coeff.numer)
t.coeff.denom == \old(t.coeff.denom)
t.expt == \old(t.expt)
daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped))
daikon.Quant.noDups(this.wrapped)
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
daikon.Quant.size(this.wrapped) >= 1
(!(t.coeff.denom == 0)) || (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.size():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
daikon.Quant.noDups(this.wrapped)
===========================================================================
PolyCalc.RatTermVec.size():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
this.wrapped == \old(this.wrapped)
daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped))
daikon.Quant.noDups(this.wrapped)
\result >= 0
===========================================================================
PolyCalc.RatTermVec.toString():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.toString():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
this.wrapped == \old(this.wrapped)
daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped))
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.toString is printable
