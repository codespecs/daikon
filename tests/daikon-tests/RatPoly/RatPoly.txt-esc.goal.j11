===========================================================================
PolyCalc.RatNum:::OBJECT
    Variables: this this.numer this.denom
this.denom >= 0
===========================================================================
PolyCalc.RatNum.RatNum(int):::ENTER
    Variables: n
===========================================================================
PolyCalc.RatNum.RatNum(int):::EXIT
    Variables: this this.numer this.denom n orig(n)
      Unmodified variables: n
this.numer == \old(n)
this.denom == 1
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::ENTER
    Variables: n d
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT55
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
this.numer == \old(n)
this.denom == \old(d)
this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT67
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
this.denom >= 1
\old(d) != 0
\old(d) % this.denom == 0
===========================================================================
PolyCalc.RatNum.RatNum(int, int):::EXIT
    Variables: this this.numer this.denom n d orig(n) orig(d)
      Unmodified variables: n d
(this.denom == 0)  ==  (\old(d) == 0)
(this.denom == 0)  ==>  (\old(d) is a pointer)
(this.denom == 0)  ==>  (this.denom == \old(d))
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer == \old(n))
(\old(n) == 0) ==> (this.numer == 0)
(this.numer == 0) ==> (\old(n) == 0)
(\old(d) == 0) ==> (this.denom == 0)
(this.denom == 0) ==> (\old(d) == 0)
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.add(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.denom == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.approx():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT117
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 0
\result == Double.NaN
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.approx():::EXIT120
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom >= 1
===========================================================================
PolyCalc.RatNum.approx():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(this.denom == 0)  ==>  (\result == Double.NaN)
(this.denom == 0)  ==>  (this.denom is a pointer)
(this.denom == 0)  ==>  (this.numer != this.denom)
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom rn rn.numer rn.denom
rn != null
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT101
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom >= 1
rn.denom >= 1
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT94
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom == \result
rn.denom == \result
\result == \old(this.denom)
\result == \old(rn.denom)
\result == 0
this.numer != \result
rn.numer != \result
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT96
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom == 0
rn.numer >= -1
rn.denom >= 1
\result == 1
this.numer != this.denom
this.denom < rn.denom
rn.denom >= \result
warning: method daikon.inv.ternary.threeScalar.FunctionBinary$GcdLong_zxy.format(OutputFormat:ESC/Java) needs to be implemented: return == (org.plumelib.util.MathPlume.gcd(rn.numer, rn.denom))
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT98
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
this.denom >= 1
rn.numer != 0
rn.denom == 0
\result == -1
this.denom > rn.denom
this.denom > \result
rn.numer != rn.denom
===========================================================================
PolyCalc.RatNum.compareTo(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom rn rn.numer rn.denom return orig(this) orig(this.numer) orig(this.denom) orig(rn) orig(rn.numer) orig(rn.denom)
      Unmodified variables: this this.numer this.denom rn rn.numer rn.denom
rn.denom >= 0
===========================================================================
PolyCalc.RatNum.debugPrint():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.debugPrint():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT187
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.numer == \result.numer
arg.denom == \result.denom
\result == \old(arg)
arg.denom == 0
(arg.numer == 0) ==> (this.numer == 0)
this.denom >= arg.denom
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT189
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 1
(this.numer == 0) ==> (\result.numer == 0)
===========================================================================
PolyCalc.RatNum.div(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
(arg.denom == 0)  ==>  ((arg.numer == 0) ==> (this.numer == 0))
(arg.denom == 0)  ==>  (arg.denom == \result.denom)
(arg.denom == 0)  ==>  (arg.denom is a pointer)
(arg.denom == 0)  ==>  (arg.numer == \result.numer)
(arg.denom == 0)  ==>  (\result == \old(arg))
(arg.denom == 0)  ==>  (\result.denom == 0)
(arg.denom == 0)  ==>  (\result.denom is a pointer)
(arg.denom == 0)  ==>  (this.denom >= arg.denom)
(arg.denom == 0)  ==>  (this.denom >= \result.denom)
arg.denom >= 0
\result != null
\result.denom >= 0
(\result.numer == 0) ==> (this.numer == 0)
(this.denom == 0) ==> (\result.denom == 0)
(arg.numer == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::ENTER
    Variables: this this.numer this.denom obj obj.getClass().getName()
obj != null
\typeof(obj) == \type(PolyCalc.RatNum)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT230
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
this.denom == 0
\result == true
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT232
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
(\result == true)  ==>  (this.denom >= 1)
===========================================================================
PolyCalc.RatNum.equals(java.lang.Object):::EXIT
    Variables: this this.numer this.denom obj obj.getClass().getName() return orig(this) orig(this.numer) orig(this.denom) orig(obj) orig(obj.getClass().getName())
      Unmodified variables: this this.numer this.denom obj obj.getClass().getName()
===========================================================================
PolyCalc.RatNum.gcd(int, int):::ENTER
    Variables: _a _b
_b != 0
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT209
    Variables: _a _b return orig(_a) orig(_b)
      Unmodified variables: _a _b
===========================================================================
PolyCalc.RatNum.gcd(int, int):::EXIT
    Variables: _a _b return orig(_a) orig(_b)
      Unmodified variables: _a _b
\result != 0
\old(_a) % \result == 0
\old(_b) % \result == 0
===========================================================================
PolyCalc.RatNum.isNaN():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNaN():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(this.denom == 0)  ==  (\result == true)
(this.denom == 0)  ==>  (this.denom is a pointer)
===========================================================================
PolyCalc.RatNum.isNegative():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isNegative():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(\result == true)  ==>  (this.denom >= 1)
(\result == true)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer <= -1)
===========================================================================
PolyCalc.RatNum.isPositive():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.isPositive():::EXIT
    Variables: this this.numer this.denom return orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
(\result == false)  ==>  (this.numer < this.denom)
(\result == true)  ==>  (this.numer != 0)
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.mul(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.numer == 0) ==> (\result.numer == 0)
(this.denom == 0) ==> (\result.denom == 0)
(arg.numer == 0) ==> (\result.numer == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.negate():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.negate():::EXIT
    Variables: this this.numer this.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == \result.denom
\result != null
(\result.numer == 0) ==> (this.numer == 0)
(this.numer == 0) ==> (\result.numer == 0)
this.numer + \result.numer == 0
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::ENTER
    Variables: ratStr ratStr.toString
ratStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString is printable
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT264
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString == "NaN"
\result.numer == 1
\result.denom == 0
\old(ratStr) != null
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT267
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
\result.denom == 1
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT273
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
===========================================================================
PolyCalc.RatNum.parse(java.lang.String):::EXIT
    Variables: ratStr ratStr.toString return return.numer return.denom orig(ratStr) orig(ratStr.toString)
      Unmodified variables: ratStr ratStr.toString
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: ratStr.toString is printable
\result != null
\result.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::ENTER
    Variables: this this.numer this.denom arg arg.numer arg.denom
arg != null
arg.denom >= 0
===========================================================================
PolyCalc.RatNum.sub(PolyCalc.RatNum):::EXIT
    Variables: this this.numer this.denom arg arg.numer arg.denom return return.numer return.denom orig(this) orig(this.numer) orig(this.denom) orig(arg) orig(arg.numer) orig(arg.denom)
      Unmodified variables: this this.numer this.denom arg arg.numer arg.denom
arg.denom >= 0
\result != null
\result.denom >= 0
(this.denom == 0) ==> (\result.denom == 0)
(arg.denom == 0) ==> (\result.denom == 0)
===========================================================================
PolyCalc.RatNum.toString():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.toString():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatNum.unparse():::ENTER
    Variables: this this.numer this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT133
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 0
\result != null
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString == "NaN"
===========================================================================
PolyCalc.RatNum.unparse():::EXIT135
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.numer != 0
this.denom >= 2
this.numer != this.denom
===========================================================================
PolyCalc.RatNum.unparse():::EXIT137
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
this.denom == 1
===========================================================================
PolyCalc.RatNum.unparse():::EXIT
    Variables: this this.numer this.denom return return.toString orig(this) orig(this.numer) orig(this.denom)
      Unmodified variables: this this.numer this.denom
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly:::OBJECT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
this.terms != null
this.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] contains no duplicates
this.terms.wrapped.containsNull == false
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::ENTER
    Variables: rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() size(rt.wrapped[]) size(rt.wrapped[])-1
rt != null
rt.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: rt.wrapped[] contains no duplicates
rt.wrapped.containsNull == false
rt.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly(PolyCalc.RatTermVec):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() orig(rt) orig(rt.wrapped) orig(rt.wrapped[]) orig(rt.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(rt.wrapped[]) size(rt.wrapped[])-1 orig(size(rt.wrapped[])) orig(size(rt.wrapped[]))-1
      Unmodified variables: rt rt.wrapped rt.wrapped[] rt.wrapped[].getClass().getName() size(rt.wrapped[])
this.terms == \old(rt)
this.terms.wrapped == rt.wrapped
rt.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: rt.wrapped[] contains no duplicates
rt.wrapped.containsNull == false
rt.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::ENTER
    Variables: c e
e >= 0
===========================================================================
PolyCalc.RatPoly.RatPoly(int, int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() c e orig(c) orig(e) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
      Unmodified variables: c e
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT350
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT354
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT363
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.add(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::ENTER
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
sb != null
rt != null
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(rt.coeff.denom == 0) ==> (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT229
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
      Unmodified variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
===========================================================================
PolyCalc.RatPoly.appendTerm(java.lang.StringBuffer, PolyCalc.RatTerm):::EXIT
    Variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt orig(sb) orig(rt) orig(rt.coeff) orig(rt.coeff.numer) orig(rt.coeff.denom) orig(rt.expt)
      Unmodified variables: sb rt rt.coeff rt.coeff.numer rt.coeff.denom rt.expt
rt.coeff != null
rt.coeff.numer >= 1
rt.coeff.denom >= 0
rt.expt >= 0
(rt.coeff.denom == 0) ==> (rt.expt == 0)
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::ENTER
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() size(v.wrapped[]) size(v.wrapped[])-1
v != null
v.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: v.wrapped[] contains no duplicates
v.wrapped.containsNull == false
v.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.assertSorted(PolyCalc.RatTermVec):::EXIT
    Variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() orig(v) orig(v.wrapped) orig(v.wrapped[]) orig(v.wrapped[].getClass().getName()) size(v.wrapped[]) size(v.wrapped[])-1 orig(size(v.wrapped[])) orig(size(v.wrapped[]))-1
      Unmodified variables: v v.wrapped v.wrapped[] v.wrapped[].getClass().getName() size(v.wrapped[])
v.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: v.wrapped[] contains no duplicates
v.wrapped.containsNull == false
v.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.checkRep():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.checkRep():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.coeff(int):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT120
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
\result.numer != 0
\old(deg) >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT124
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
\result.numer == 0
\result.denom == 1
===========================================================================
PolyCalc.RatPoly.coeff(int):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg return return.numer return.denom orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(deg) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() deg size(this.terms.wrapped[])
(\result.numer != 0)  ==>  (\old(deg) >= 0)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return.numer != 0)  ==>  (size(this.terms.wrapped[]) >= 1)
(\result.numer == 0)  ==>  (\result.denom == 1)
(\result.numer == 0)  ==>  (\result.numer < \result.denom)
(\result.numer == 0)  ==>  (\result.numer is a pointer)
\result != null
(\result.denom == 0) ==> (\old(deg) == 0)
===========================================================================
PolyCalc.RatPoly.degree():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.degree():::EXIT102
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.degree():::EXIT105
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
\result == 0
===========================================================================
PolyCalc.RatPoly.degree():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return == 0)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (size(this.terms.wrapped[]) is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[].getClass().getName() == [])
\result >= 0
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT435
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT438
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.div(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.divAndRem(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.getClass().getName() return[] return[].terms return[].terms.wrapped orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return[]) size(return[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\typeof(\result) == \type(PolyCalc.RatPoly[])
\nonnullelements(\result)
(\forall int i; (0 <= i && i <= \result.length-1) ==> (\result[i].terms != null))
(\forall int i; (0 <= i && i <= \result.length-1) ==> (\result[i].terms.wrapped != null))
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) >= 1
\result.length == 2
===========================================================================
PolyCalc.RatPoly.eval(double):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
d >= 0.0
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) & size(this.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.eval(double):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(d) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() d size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) & size(this.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[]) size(ts.wrapped[])-1
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT521
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT523
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT526
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
\result >= 1
===========================================================================
PolyCalc.RatPoly.findTermIndex(PolyCalc.RatTermVec, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt return orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() expt size(ts.wrapped[])
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
\result >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::ENTER
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[]) size(ts.wrapped[])-1
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
i >= 0
expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT534
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[])
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT537
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[])
\result.coeff.numer == 0
\result.coeff.denom == 1
\old(i) >= 1
\result.coeff.numer <= \result.expt
===========================================================================
PolyCalc.RatPoly.hintedGet(PolyCalc.RatTermVec, int, int):::EXIT
    Variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt return return.coeff return.coeff.numer return.coeff.denom return.expt orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(i) orig(expt) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Unmodified variables: ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() i expt size(ts.wrapped[])
\result.expt == \old(expt)
(\result.coeff.numer == 0)  ==>  (\old(i) >= 1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.denom == 1)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer < \result.coeff.denom)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer <= \result.expt)
(\result.coeff.numer == 0)  ==>  (\result.coeff.numer is a pointer)
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.coeff != null
\result.coeff.denom >= 1
\result.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
degree >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.incremExpt(PolyCalc.RatTermVec, int):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() degree orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(degree) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() degree size(vec.wrapped[])
modifies vec.wrapped[*]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.isNaN():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT86
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result == true
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT90
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
\result == false
===========================================================================
PolyCalc.RatPoly.isNaN():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return == true)  ==>  (size(this.terms.wrapped[]) == 1)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (return == true)  ==>  (size(this.terms.wrapped[])-1 is a pointer)
(\result == true)  ==>  (this.terms.wrapped.elementType == \type(PolyCalc.RatTerm))
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
p != null
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT390
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT394
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT404
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
===========================================================================
PolyCalc.RatPoly.mul(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms != null
p.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: p.terms.wrapped[] contains no duplicates
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.negate():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.negate():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::ENTER
    Variables: polyStr polyStr.toString
polyStr != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: polyStr.toString is printable
===========================================================================
PolyCalc.RatPoly.parse(java.lang.String):::EXIT
    Variables: polyStr polyStr.toString return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(polyStr) orig(polyStr.toString) size(return.terms.wrapped[]) size(return.terms.wrapped[])-1
      Unmodified variables: polyStr polyStr.toString
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: polyStr.toString is printable
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::ENTER
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index size(ts.wrapped[]) size(ts.wrapped[])-1
term != null
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts != null
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
index >= 1
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.replaceExpt(PolyCalc.RatTerm, PolyCalc.RatTermVec, int):::EXIT
    Variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped ts.wrapped[] ts.wrapped[].getClass().getName() index orig(term) orig(term.coeff) orig(term.coeff.numer) orig(term.coeff.denom) orig(term.expt) orig(ts) orig(ts.wrapped) orig(ts.wrapped[]) orig(ts.wrapped[].getClass().getName()) orig(index) size(ts.wrapped[]) size(ts.wrapped[])-1 orig(size(ts.wrapped[])) orig(size(ts.wrapped[]))-1
      Modified variables: ts.wrapped[] ts.wrapped[].getClass().getName() size(ts.wrapped[])
      Unmodified variables: term term.coeff term.coeff.numer term.coeff.denom term.expt ts ts.wrapped index
modifies ts.wrapped[*]
term.coeff != null
term.coeff.denom >= 1
term.expt >= 0
ts.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: ts.wrapped[] contains no duplicates
ts.wrapped.containsNull == false
ts.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= 1
warning: method daikon.inv.binary.twoScalar.NumericInt$ShiftZero.format(OutputFormat:ESC/Java) needs to be implemented: (orig(size(ts.wrapped[])) >> size(ts.wrapped[]) == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[]) >= orig(size(ts.wrapped[]))-1
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(ts.wrapped[])-1 <= orig(size(ts.wrapped[]))
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(ts.wrapped[])-1 == 0) ==> (orig(size(ts.wrapped[]))-1 == 0)
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
scalar != null
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.scaleBy(PolyCalc.RatTerm):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(scalar) orig(scalar.coeff) orig(scalar.coeff.numer) orig(scalar.coeff.denom) orig(scalar.expt) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() scalar scalar.coeff scalar.coeff.numer scalar.coeff.denom scalar.expt size(this.terms.wrapped[])
scalar.coeff != null
scalar.coeff.denom >= 1
scalar.expt >= 0
\result != null
\result.terms != null
\result.terms.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.terms.wrapped[] contains no duplicates
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
scalar != null
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.scaleCoeff(PolyCalc.RatTermVec, PolyCalc.RatNum):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(scalar) orig(scalar.numer) orig(scalar.denom) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() scalar scalar.numer scalar.denom size(vec.wrapped[])
modifies vec.wrapped[*]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
scalar.denom >= 1
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::ENTER
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt size(vec.wrapped[]) size(vec.wrapped[])-1
vec != null
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm != null
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT308
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[])
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) == orig(size(vec.wrapped[]))-1
newTerm.coeff.denom == 1
warning: method daikon.inv.binary.twoSequence.SubSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a subset of orig(vec.wrapped[])
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT312
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[]
      Unmodified variables: vec vec.wrapped vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt size(vec.wrapped[])
modifies vec.wrapped[*]
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT319
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[])
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 == orig(size(vec.wrapped[]))
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm.coeff.numer == 2
newTerm.coeff.denom == 1
newTerm.expt == 4 || newTerm.expt == 6
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[].getClass().getName()) one of { [PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm], [PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm, PolyCalc.RatTerm] }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) one of { 5, 6 }
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a superset of orig(vec.wrapped[])
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT328
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[])
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 == orig(size(vec.wrapped[]))
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(vec.wrapped[]) is a subsequence of vec.wrapped[]
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] is a superset of orig(vec.wrapped[])
===========================================================================
PolyCalc.RatPoly.sortedAdd(PolyCalc.RatTermVec, PolyCalc.RatTerm):::EXIT
    Variables: vec vec.wrapped vec.wrapped[] vec.wrapped[].getClass().getName() newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt orig(vec) orig(vec.wrapped) orig(vec.wrapped[]) orig(vec.wrapped[].getClass().getName()) orig(newTerm) orig(newTerm.coeff) orig(newTerm.coeff.numer) orig(newTerm.coeff.denom) orig(newTerm.expt) size(vec.wrapped[]) size(vec.wrapped[])-1 orig(size(vec.wrapped[])) orig(size(vec.wrapped[]))-1
      Modified variables: vec.wrapped[] vec.wrapped[].getClass().getName() size(vec.wrapped[])
      Unmodified variables: vec vec.wrapped newTerm newTerm.coeff newTerm.coeff.numer newTerm.coeff.denom newTerm.expt
modifies vec.wrapped[*]
vec.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: vec.wrapped[] contains no duplicates
vec.wrapped.containsNull == false
vec.wrapped.elementType == \type(PolyCalc.RatTerm)
newTerm.coeff != null
newTerm.coeff.numer != 0
newTerm.coeff.denom >= 1
newTerm.expt >= 0
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (size(vec.wrapped[]) == 0) ==> (orig(size(vec.wrapped[]))-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntGreaterEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[]) >= orig(size(vec.wrapped[]))-1
warning: method daikon.inv.binary.twoScalar.NumericInt$ZeroTrack.format(OutputFormat:ESC/Java) needs to be implemented: (orig(size(vec.wrapped[])) == 0) ==> (size(vec.wrapped[])-1 == 0)
warning: method daikon.inv.binary.twoScalar.IntLessEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(vec.wrapped[])-1 <= orig(size(vec.wrapped[]))
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p != null
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT372
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms == \result.terms
this.terms.wrapped == \result.terms.wrapped
\result == \old(this)
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT376
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
p.terms == \result.terms
p.terms.wrapped == \result.terms.wrapped
\result == \old(p)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) == 1
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT379
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) == 1
===========================================================================
PolyCalc.RatPoly.sub(PolyCalc.RatPoly):::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() return return.terms return.terms.wrapped return.terms.wrapped[] return.terms.wrapped[].getClass().getName() orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) orig(p) orig(p.terms) orig(p.terms.wrapped) orig(p.terms.wrapped[]) orig(p.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 size(p.terms.wrapped[]) size(p.terms.wrapped[])-1 size(return.terms.wrapped[]) size(return.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1 orig(size(p.terms.wrapped[])) orig(size(p.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() p p.terms p.terms.wrapped p.terms.wrapped[] p.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(p.terms.wrapped[])
this.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms != null
p.terms.wrapped != null
p.terms.wrapped.containsNull == false
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
p.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
\result != null
\result.terms != null
\result.terms.wrapped != null
\result.terms.wrapped.containsNull == false
\result.terms.wrapped.elementType == \type(PolyCalc.RatTerm)
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(p.terms.wrapped[]) one of { 0, 1 }
warning: method daikon.inv.unary.scalar.OneOfScalar.format(OutputFormat:ESC/Java) needs to be implemented: size(return.terms.wrapped[]) one of { 0, 1, 2 }
warning: method daikon.inv.binary.twoScalar.NumericInt$BitwiseAndZero.format(OutputFormat:ESC/Java) needs to be implemented: (size(return.terms.wrapped[]) & size(return.terms.wrapped[])-1) == 0
===========================================================================
PolyCalc.RatPoly.toString():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.toString():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatPoly.unparse():::ENTER
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[]) size(this.terms.wrapped[])-1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT165
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.terms.wrapped[].getClass().getName() == []
\result != null
warning: method daikon.inv.unary.string.OneOfString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString == "0"
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT196
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.terms.wrapped[]) >= 1
===========================================================================
PolyCalc.RatPoly.unparse():::EXIT
    Variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() return return.toString orig(this) orig(this.terms) orig(this.terms.wrapped) orig(this.terms.wrapped[]) orig(this.terms.wrapped[].getClass().getName()) size(this.terms.wrapped[]) size(this.terms.wrapped[])-1 orig(size(this.terms.wrapped[])) orig(size(this.terms.wrapped[]))-1
      Unmodified variables: this this.terms this.terms.wrapped this.terms.wrapped[] this.terms.wrapped[].getClass().getName() size(this.terms.wrapped[])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return has only one value)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (return.toString == "0")
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (size(this.terms.wrapped[]) is a pointer)
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[] == [])
warning: method daikon.inv.Implication.format(OutputFormat:ESC/Java) needs to be implemented: (size(this.terms.wrapped[]) == 0)  ==>  (this.terms.wrapped[].getClass().getName() == [])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTerm:::OBJECT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
this.coeff != null
this.coeff.denom >= 0
this.expt >= 0
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::ENTER
    Variables: c c.numer c.denom e
c != null
c.denom >= 0
e >= 0
(c.denom == 0) ==> (e == 0)
===========================================================================
PolyCalc.RatTerm.RatTerm(PolyCalc.RatNum, int):::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt c c.numer c.denom e orig(c) orig(c.numer) orig(c.denom) orig(e)
      Unmodified variables: c c.numer c.denom e
this.coeff == \old(c)
this.coeff.numer == c.numer
this.coeff.denom == c.denom
this.expt == \old(e)
c.denom >= 0
(c.denom == 0) ==> (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.debugPrint():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
(this.coeff.denom == 0) ==> (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.debugPrint():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
      Unmodified variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
(this.coeff.denom == 0) ==> (this.expt == 0)
===========================================================================
PolyCalc.RatTerm.toString():::ENTER
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
===========================================================================
PolyCalc.RatTerm.toString():::EXIT
    Variables: this this.coeff this.coeff.numer this.coeff.denom this.expt return return.toString orig(this) orig(this.coeff) orig(this.coeff.numer) orig(this.coeff.denom) orig(this.expt)
      Unmodified variables: this this.coeff this.coeff.numer this.coeff.denom this.expt
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec:::OBJECT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
this.wrapped != null
this.wrapped.containsNull == false
this.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatTermVec.RatTermVec():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.OneOfSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] == []
warning: method daikon.inv.unary.stringsequence.OneOfStringSequence.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[].getClass().getName() == []
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t != null
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
(t.coeff.denom == 0) ==> (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.addElement(PolyCalc.RatTerm):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
      Unmodified variables: this this.wrapped t t.coeff t.coeff.numer t.coeff.denom t.expt
modifies this.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[])-1 == orig(size(this.wrapped[]))
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t.coeff != null
t.coeff.numer != 0
t.coeff.denom >= 0
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSequence.format(OutputFormat:ESC/Java) needs to be implemented: orig(this.wrapped[]) is a subsequence of this.wrapped[]
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a superset of orig(this.wrapped[])
(t.coeff.denom == 0) ==> (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.copy():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
===========================================================================
PolyCalc.RatTermVec.copy():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.wrapped return.wrapped[] return.wrapped[].getClass().getName() orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 size(return.wrapped[]) size(return.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
\result != null
\result.wrapped != null
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: return.wrapped[] contains no duplicates
\result.wrapped.containsNull == false
\result.wrapped.elementType == \type(PolyCalc.RatTerm)
===========================================================================
PolyCalc.RatTermVec.get(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
===========================================================================
PolyCalc.RatTermVec.get(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index return return.coeff return.coeff.numer return.coeff.denom return.expt orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[])
\result != null
\result.coeff != null
\result.coeff.denom >= 0
\result.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
(\result.coeff.numer == 0) ==> (\result.expt == 0)
(\result.coeff.denom == 0) ==> (\result.expt == 0)
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1
t != null
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
index >= 0
===========================================================================
PolyCalc.RatTermVec.insert(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
      Unmodified variables: this this.wrapped t t.coeff t.coeff.numer t.coeff.denom t.expt index
modifies this.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[])-1 == orig(size(this.wrapped[]))
t.coeff != null
t.coeff.denom >= 1
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
warning: method daikon.inv.binary.twoSequence.SuperSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a superset of orig(this.wrapped[])
===========================================================================
PolyCalc.RatTermVec.printDebug():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.printDebug():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
===========================================================================
PolyCalc.RatTermVec.remove(int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
===========================================================================
PolyCalc.RatTermVec.remove(int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Modified variables: this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
      Unmodified variables: this this.wrapped index
modifies this.wrapped[*]
warning: method daikon.inv.binary.twoScalar.IntEqual.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) == orig(size(this.wrapped[]))-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
warning: method daikon.inv.binary.twoSequence.SubSet.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] is a subset of orig(this.wrapped[])
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t != null
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
index >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
(t.coeff.denom == 0) ==> (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.set(PolyCalc.RatTerm, int):::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) orig(t) orig(t.coeff) orig(t.coeff.numer) orig(t.coeff.denom) orig(t.expt) orig(index) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Modified variables: this.wrapped[]
      Unmodified variables: this this.wrapped this.wrapped[].getClass().getName() t t.coeff t.coeff.numer t.coeff.denom t.expt index size(this.wrapped[])
modifies this.wrapped[*]
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
t.coeff != null
t.coeff.numer != 0
t.expt >= 0
warning: method daikon.inv.unary.scalar.LowerBound.format(OutputFormat:ESC/Java) needs to be implemented: size(this.wrapped[]) >= 1
(t.coeff.denom == 0) ==> (t.expt == 0)
===========================================================================
PolyCalc.RatTermVec.size():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
===========================================================================
PolyCalc.RatTermVec.size():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
warning: method daikon.inv.unary.sequence.NoDuplicates.format(OutputFormat:ESC/Java) needs to be implemented: this.wrapped[] contains no duplicates
\result >= 0
===========================================================================
PolyCalc.RatTermVec.toString():::ENTER
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[]) size(this.wrapped[])-1
===========================================================================
PolyCalc.RatTermVec.toString():::EXIT
    Variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() return return.toString orig(this) orig(this.wrapped) orig(this.wrapped[]) orig(this.wrapped[].getClass().getName()) size(this.wrapped[]) size(this.wrapped[])-1 orig(size(this.wrapped[])) orig(size(this.wrapped[]))-1
      Unmodified variables: this this.wrapped this.wrapped[] this.wrapped[].getClass().getName() size(this.wrapped[])
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:ESC/Java) needs to be implemented: return.toString is printable
