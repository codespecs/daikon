package PolyCalc;

import java.util.StringTokenizer;

import junit.framework.Assert;

/** RatPoly represents an immutable single-variate polynomial
    expression.  RatPolys have rational coefficients and integer
    exponents.  Examples of RatPolys include "x^3-1/2*x^2+5/3*x+3",
    "x-10", and "0".  RatPolys may also have NaN as a coefficient.
*/
public class RatPoly {

    /*@ invariant this.terms != null; */
    /*@ invariant this.terms.wrapped != null; */
    /*@ invariant daikon.Quant.noDups(this.terms.wrapped); */
    /*@ invariant daikon.Quant.eltsNotEqual(this.terms.wrapped, null); */
    // holds terms of this
    /*@ spec_public */ private RatTermVec terms;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    // Definitions:
    // For a RatPoly p, let C(p,i) be "p.terms.get(i).coeff" and
    //                      E(p,i) be "p.terms.get(i).expt"
    //                      length(p) be "p.terms.size()"

    // (( These are helper functions that will make it easier for us
    // to write the remainder of the specifications.  They are not
    // executable code; they just represent complex expressions in a
    // concise manner, so that we can stress the important parts of
    // other expressions in the spec rather than get bogged down in
    // the details of how we extract the coefficient for the 2nd term
    // or the exponent for the 5th term.  So when you see C(p,i),
    // think "coefficient for the ith term in p" ))

    // Abstraction Function:
    // A RatPoly p is the Sum, from i=0 to length(p), of C(p,i)*x^E(p,i)

    // (( This explains what the state of the fields in a RatPoly
    // represents: it is the sum of a series of terms, forming an
    // expression like "C_0 + C_1*x^1 + C_2*x^2 + ..." If there are no
    // terms, then the RatPoly represents the zero polynomial ))

    // Rep. Invariant for every RatPoly p:
    // terms != null &&
    // forall i such that (0 <= i < length(p), C(p,i) != 0 &&
    // forall i such that (0 <= i < length(p), E(p,i) >= 0 &&
    // forall i such that (0 <= i < length(p) - 1), E(p,i) > E(p, i+1)

    // (( This tells us three important facts about every RatPoly: the
    // terms field always points to some usable object, no term in a
    // RatPoly has a negative exponent or a zero coefficient, and the
    // terms in a RatPoly are sorted according to descending exponent
    // order.

    /** @effects: Constructs a new Poly, "0".
     */
    public RatPoly() {
        // IMPL IS STAFF ONLY
        terms = new RatTermVec();
        checkRep();
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires e >= 0;
    @ ensures daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1;
    @*/
    /** @requires: e >= 0
        @effects: Constructs a new Poly, "c * x^e".
     */
    public RatPoly(int c, int e) {
        // IMPL IS STAFF ONLY
        terms = new RatTermVec();
        if (c != 0)
            terms.addElement( new RatTerm(new RatNum(c), e) );
        checkRep();
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires rt != null;
    @ requires rt.wrapped != null;
    @ requires daikon.Quant.noDups(rt.wrapped);
    @ requires daikon.Quant.eltsNotEqual(rt.wrapped, null);
    @ ensures this.terms == \old(rt);
    @ ensures this.terms.wrapped == rt.wrapped;
    @ ensures rt.wrapped == \old(rt.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(rt.wrapped, \old(rt.wrapped));
    @ ensures rt.wrapped != null;
    @ ensures daikon.Quant.noDups(rt.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(rt.wrapped, null);
    @*/
    /** @requires: 'rt' satisfies clauses given in rep. invariant
        @effects: Constructs a new Poly using 'rt' (does not make a copy)
    */
    private RatPoly(RatTermVec rt) {
        // IMPL IS STAFF ONLY
        terms = rt;
        checkRep();
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures (\result == true)  ==>  (daikon.Quant.size(this.terms.wrapped) == 1);
    @ ensures (\result == true)  ==>  (daikon.Quant.size(this.terms.wrapped)-1 is a pointer);
    @*/
    /** @return true if and only if this has some coefficient = "NaN".
     */
    public boolean isNaN() {
        checkRep();
        for(int i=0; i<terms.size(); i++) {
            if (terms.get(i).coeff.isNaN()) {
                checkRep();
                return true;
            }
        }
        checkRep();
        return false;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result == 0);
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result is a pointer);
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.size(this.terms.wrapped) is a pointer);
    @ ensures \result >= 0;
    @*/
    /** Returns the degree of this.
        @return the largest exponent with a non-zero coefficient, or 0
                if this = "0".
     */
    public int degree() {
        // IMPL IS STAFF ONLY
        checkRep();
        if (terms.size() > 0) {
            checkRep();
            return terms.get(0).expt;
        } else {
            checkRep();
            return 0;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures (\result.numer != 0)  ==>  (\old(deg) >= 0);
    @ ensures (\result.numer != 0)  ==>  (daikon.Quant.size(this.terms.wrapped) >= 1);
    @ ensures (\result.numer == 0)  ==>  (\result.denom == 1);
    @ ensures (\result.numer == 0)  ==>  (\result.numer < \result.denom);
    @ ensures (\result.numer == 0)  ==>  (\result.numer is a pointer);
    @ ensures \result != null;
    @ ensures (!(\result.denom == 0)) || (\old(deg) == 0);
    @*/
    /** @return the coefficient associated with term of degree 'deg'.
        If there is no term of degree 'deg' in this poly, then returns
        zero.
    */
    public RatNum coeff(int deg) {
        // IMPL IS STAFF ONLY
        checkRep();
        for(int i=0; i<terms.size(); i++) {
            RatTerm t = terms.get(i);
            if (t.expt == deg) {
                checkRep();
                return t.coeff;
            }
        }
        checkRep();
        return new RatNum(0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result != null);
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (\result.toString().equals("0"));
    @ ensures (daikon.Quant.size(this.terms.wrapped) == 0)  ==>  (daikon.Quant.size(this.terms.wrapped) is a pointer);
    @ ensures \result != null;
    @*/
    /** @return a String representation of the expression represented
        by this, with the terms sorted in order of degree from highest
        to lowest.

        Terms with zero coefficients do not appear in the returned
        string, unless the polynomial is itself zero, in which case
        the returned string will just be "0."

        The string is in the form "(-)T(+|-)T(+|-)...",where for each
        term, T takes the form "C*x^E" or "C*x", UNLESS: (1) the
        exponent E is zero, in which case T takes the form "C", or (2)
        the coefficient C is one, in which case T takes the form "x^E"
        or "x"

        Note that this format allows only the first term to be output
        as a negative expression.

        Valid example outputs include "x^17-3/2*x^2+1", "-x+1", "-1/2",
        and "0".

        (FSK: formal BNF grammar below, not intended for students, but
        rather for the enterprising TA who wants to make the above
        description clearer)

        P ::= 0 | S | - S
        S ::= T + S | T - S | T
        T ::= K | L * x E | x E
        K ::= 1 | L
        L ::= K | K / N
        N ::= 2 | 3 | 4 | ...
        E ::= ^L | <empty>

    */
    public String unparse() {
        // IMPL IS STAFF ONLY
        checkRep();
        if (terms.size() == 0) {
            checkRep();
            return "0";
        }

        StringBuffer sb = new StringBuffer();

        // first term, special case to omit initial '+'
        RatTerm term = terms.get(0);
        if (term.coeff.isNegative()) {
            sb.append("-");
            term = new RatTerm( term.coeff.negate(), term.expt );
        }
        appendTerm(sb, term);

        for(int i=1; i<terms.size(); i++) {
            RatTerm rt = terms.get(i);
            RatNum num = rt.coeff;
            if (num.equals(new RatNum(0))) {
                continue; // do nothing;
            } else if (num.isNegative()) {
                sb.append("-");
                num = num.negate();
            } else {
                sb.append("+");
            }
            appendTerm(sb, new RatTerm( num, rt.expt ));
        }

        if (sb.length() == 0)
            sb.append('0');

        checkRep();
        return sb.toString();
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires sb != null;
    @ requires rt != null;
    @ requires rt.coeff != null;
    @ requires rt.coeff.numer >= 1;
    @ requires rt.coeff.denom >= 0;
    @ requires rt.expt >= 0;
    @ requires (!(rt.coeff.denom == 0)) || (rt.expt == 0);
    @ ensures rt.coeff == \old(rt.coeff);
    @ ensures rt.coeff.numer == \old(rt.coeff.numer);
    @ ensures rt.coeff.denom == \old(rt.coeff.denom);
    @ ensures rt.expt == \old(rt.expt);
    @ ensures rt.coeff != null;
    @ ensures rt.coeff.numer >= 1;
    @ ensures rt.coeff.denom >= 0;
    @ ensures rt.expt >= 0;
    @ ensures (!(rt.coeff.denom == 0)) || (rt.expt == 0);
    @*/
    // METHOD IS STAFF ONLY
    // appendTerm is a helper method, not given in spec
    // Let c = rt.coeff and e = rt.expt
    // If c is zero then does nothing.
    // Else, does the following in series:
    //    1) if c != 1 or e = 0 then appends c to sb else does nothing
    //    2) if c != 1 and e != 0 then appends "*" to sb
    //    3) if e > 1 then appends ("x^"+e) to sb.
    //    4) if e == 1 then appends ("x") to sb.
    private static void appendTerm(StringBuffer sb, RatTerm rt) {
        RatNum c = rt.coeff;
        int e = rt.expt;
        if (c.equals( new RatNum(0) ) ) {
            return;
        }

        if (e == 0 || !c.equals( new RatNum(1) ) ) {
            sb.append(c.unparse());
        }

        if (e != 0) {
            if (!c.equals( new RatNum(1) )) {
                sb.append('*');
            }
            sb.append('x');
            if (e != 1) {
                sb.append('^');
                sb.append(e);
            }
        }
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires scalar != null;
    @ requires scalar.coeff != null;
    @ requires scalar.coeff.denom >= 1;
    @ requires scalar.expt >= 0;
    @ requires daikon.Quant.size(this.terms.wrapped) >= 1;
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures scalar.coeff == \old(scalar.coeff);
    @ ensures scalar.coeff.numer == \old(scalar.coeff.numer);
    @ ensures scalar.coeff.denom == \old(scalar.coeff.denom);
    @ ensures scalar.expt == \old(scalar.expt);
    @ ensures scalar.coeff != null;
    @ ensures scalar.coeff.denom >= 1;
    @ ensures scalar.expt >= 0;
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @ ensures daikon.Quant.size(this.terms.wrapped) >= 1;
    @ ensures daikon.Quant.size(\result.terms.wrapped) >= 1;
    @*/
    // METHOD IS STAFF ONLY
    private RatPoly scaleBy(RatTerm scalar) {
        checkRep();
        RatTermVec vec = this.terms.copy();
        scaleCoeff(vec, scalar.coeff);
        incremExpt(vec, scalar.expt );
        checkRep();
        return new RatPoly(vec);
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires vec != null;
    @ requires vec.wrapped != null;
    @ requires daikon.Quant.noDups(vec.wrapped);
    @ requires daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ requires scalar != null;
    @ requires scalar.denom >= 1;
    @ ensures vec.wrapped == \old(vec.wrapped);
    @ ensures scalar.numer == \old(scalar.numer);
    @ ensures scalar.denom == \old(scalar.denom);
    @ ensures daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped));
    @ ensures vec.wrapped != null;
    @ ensures daikon.Quant.noDups(vec.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ ensures scalar.denom >= 1;
    @*/
    /** Scales coefficients within 'vec' by 'scalar' (helper procedure).
        @requires: vec, scalar != null
        @modifies: vec
        @effects: forall i s.t. 0 <= i < vec.size(),
                     if (C . E) = vec.get(i)
                     then vec_post.get(i) = (C*scalar . E)
    */
    private static void scaleCoeff(RatTermVec vec, RatNum scalar) {
        // IMPL IS STAFF ONLY
        for(int i=0; i<vec.size(); i++) {
            RatTerm rt = vec.get(i);
            RatTerm replace = new RatTerm( rt.coeff.mul(scalar), rt.expt );
            vec.set( replace, i );
        }
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires vec != null;
    @ requires vec.wrapped != null;
    @ requires daikon.Quant.noDups(vec.wrapped);
    @ requires daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ requires degree >= 0;
    @ requires daikon.Quant.size(vec.wrapped) >= 1;
    @ ensures vec.wrapped == \old(vec.wrapped);
    @ ensures daikon.Quant.size(vec.wrapped) == \old(daikon.Quant.size(vec.wrapped));
    @ ensures vec.wrapped != null;
    @ ensures daikon.Quant.noDups(vec.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ ensures daikon.Quant.size(vec.wrapped) >= 1;
    @*/
    /** Increments exponents within 'vec' by 'degree' (helper procedure).
        @requires: vec != null
        @modifies: vec
        @effects: forall i s.t. 0 <= i < vec.size(),
                     if (C . E) = vec.get(i)
                     then vec_post.get(i) = (C . E*degree)
     */
    private static void incremExpt(RatTermVec vec, int degree) {
        // IMPL IS STAFF ONLY
        for(int i=0; i<vec.size(); i++) {
            RatTerm rt = vec.get(i);
            RatTerm replace = new RatTerm( rt.coeff, rt.expt+degree );
            vec.set( replace, i );
        }
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires vec != null;
    @ requires vec.wrapped != null;
    @ requires daikon.Quant.noDups(vec.wrapped);
    @ requires daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ requires newTerm != null;
    @ requires newTerm.coeff != null;
    @ requires newTerm.coeff.numer != 0;
    @ requires newTerm.coeff.denom >= 1;
    @ requires newTerm.expt >= 0;
    @ ensures vec.wrapped == \old(vec.wrapped);
    @ ensures newTerm.coeff == \old(newTerm.coeff);
    @ ensures newTerm.coeff.numer == \old(newTerm.coeff.numer);
    @ ensures newTerm.coeff.denom == \old(newTerm.coeff.denom);
    @ ensures newTerm.expt == \old(newTerm.expt);
    @ ensures vec.wrapped != null;
    @ ensures daikon.Quant.noDups(vec.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(vec.wrapped, null);
    @ ensures newTerm.coeff != null;
    @ ensures newTerm.coeff.numer != 0;
    @ ensures newTerm.coeff.denom >= 1;
    @ ensures newTerm.expt >= 0;
    @ ensures (!(daikon.Quant.size(vec.wrapped) == 0)) || (\old(daikon.Quant.size(vec.wrapped))-1 == 0);
    @ ensures daikon.Quant.size(vec.wrapped) >= \old(daikon.Quant.size(vec.wrapped))-1;
    @ ensures (!(\old(daikon.Quant.size(vec.wrapped)) == 0)) || (daikon.Quant.size(vec.wrapped)-1 == 0);
    @ ensures daikon.Quant.size(vec.wrapped)-1 <= \old(daikon.Quant.size(vec.wrapped));
    @*/
    /** Merges a term into a sequence of terms, preserving the
        sorted nature of the sequence (helper procedure).

        Definitions:
        Let a "Sorted RatTermVec" be a RatTermVec V such that
        [1] V is sorted in descending exponent order &&
        [2] there are no two RatTerms with the same exponent in V &&
        [3] there is no RatTerm in V with a coefficient equal to zero

        For a Sorted(RatTermVec) V and integer e, let cofind(V, e)
        be either the coefficient for a RatTerm rt in V whose
        exponent is e, or zero if there does not exist any such
        RatTerm in V.

        @requires: sorted(vec)
        @modifies: vec
        @effects: sorted(vec_post) &&
                  cofind(vec_post,e) = cofind(vec,e) + newTerm.coeff
    */
    private static void sortedAdd(RatTermVec vec, RatTerm newTerm) {
        // IMPL IS STAFF ONLY
        assertSorted(vec);

        // FSK: impl could be faster [use binary instead of linear
        // search, not to mention get rid of the expensive "sorted"
        // assertions C:) ] but this works...

        for(int i=0; i<vec.size(); i++) {
            RatTerm rt = vec.get(i);
            if (rt.expt == newTerm.expt) {
                // MATCH!
                RatNum newCoeffValue = rt.coeff.add(newTerm.coeff);
                if (newCoeffValue.equals( new RatNum(0) )) {
                    vec.remove(i);
                    assertSorted(vec);
                    return;
                } else {
                    vec.set(new RatTerm( newCoeffValue , rt.expt ), i);
                    assertSorted(vec);
                    return;
                }
            } else if (rt.expt < newTerm.expt) {
                // we've hit a lower exponent w/o seeing a match; insert term here
                if (!newTerm.coeff.equals(new RatNum(0)))
                    vec.insert(newTerm, i);
                assertSorted(vec);
                return;
            }
        }

        // if we get here, we didn't hit a lower exponent OR find a
        // match; append onto the end of vec
        if (!newTerm.coeff.equals(new RatNum(0)))
            vec.addElement(newTerm);
        assertSorted(vec);
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires v != null;
    @ requires v.wrapped != null;
    @ requires daikon.Quant.noDups(v.wrapped);
    @ requires daikon.Quant.eltsNotEqual(v.wrapped, null);
    @ ensures v.wrapped == \old(v.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(v.wrapped, \old(v.wrapped));
    @ ensures v.wrapped != null;
    @ ensures daikon.Quant.noDups(v.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(v.wrapped, null);
    @*/
    // METHOD IS STAFF ONLY
    private static void assertSorted(RatTermVec v) {
        // ( verifies Sorted property defined above in spec for sortedAdd )
        int lastExp = Integer.MAX_VALUE;
        for(int i=0; i<v.size(); i++) {
            RatTerm rt = v.get(i);

            Assert.assertTrue(!(rt.expt >= lastExp)); // "unsorted vec generated! "+v.printDebug());
            Assert.assertTrue(!rt.coeff.equals( new RatNum(0) )); // "vec w/ zero coeff generated! "+v.printDebug());

            lastExp = rt.expt;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires p != null;
    @ requires p.terms != null;
    @ requires p.terms.wrapped != null;
    @ requires daikon.Quant.noDups(p.terms.wrapped);
    @ requires daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures p.terms == \old(p.terms);
    @ ensures p.terms.wrapped == \old(p.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped));
    @ ensures p.terms != null;
    @ ensures p.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(p.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @*/
    /** @return a new RatPoly, r, such that r = "this + p". */
    public RatPoly add(RatPoly p) {
        // IMPL IS STAFF ONLY
        checkRep();
        if (this.isNaN()) {
            checkRep();
            return this;
        }
        if (p.isNaN()) {
            checkRep();
            return p;
        }

        RatTermVec r = this.terms.copy();
        for(int i=0; i<p.terms.size(); i++) {
            sortedAdd( r, p.terms.get(i) );
        }

        checkRep();
        return new RatPoly(r);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires p != null;
    @ requires p.terms != null;
    @ requires p.terms.wrapped != null;
    @ requires daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ requires daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1;
    @ requires daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1;
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures p.terms == \old(p.terms);
    @ ensures p.terms.wrapped == \old(p.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped));
    @ ensures p.terms != null;
    @ ensures p.terms.wrapped != null;
    @ ensures daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @ ensures daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1;
    @ ensures daikon.Quant.size(p.terms.wrapped) == 0 || daikon.Quant.size(p.terms.wrapped) == 1;
    @ ensures daikon.Quant.size(\result.terms.wrapped) == 0 || daikon.Quant.size(\result.terms.wrapped) == 1 || daikon.Quant.size(\result.terms.wrapped) == 2;
    @ ensures (daikon.Quant.size(\result.terms.wrapped) & daikon.Quant.size(\result.terms.wrapped)-1) == 0;
    @*/
    /** @return a new RatPoly, r, such that r = "this - p". */
    public RatPoly sub(RatPoly p) {
        // IMPL IS STAFF ONLY
        checkRep();
        if (this.isNaN()) {
            checkRep();
            return this;
        }
        if (p.isNaN()) {
            checkRep();
            return p;
        }
        checkRep();
        return this.add(p.negate());
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires p != null;
    @ requires p.terms != null;
    @ requires p.terms.wrapped != null;
    @ requires daikon.Quant.noDups(p.terms.wrapped);
    @ requires daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures p.terms == \old(p.terms);
    @ ensures p.terms.wrapped == \old(p.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped));
    @ ensures p.terms != null;
    @ ensures p.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(p.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @*/
    /** @return a new RatPoly, r, such that r = "this * p";
                if this.isNaN() or p.isNaN(), returns "NaN * x^0".
     */
    public RatPoly mul(RatPoly p) {
        // IMPL IS STAFF ONLY
        checkRep();
        if (this.isNaN()) {
            checkRep();
            return this;
        }
        if (p.isNaN()) {
            checkRep();
            return p;
        }

        RatPoly accum = new RatPoly();
        for(int i=0; i<this.terms.size(); i++) {
            RatTerm rt = this.terms.get(i);
            RatPoly augend = p.scaleBy( rt );
            accum = accum.add(augend);
        }
        checkRep();
        return accum;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires p != null;
    @ requires p.terms != null;
    @ requires p.terms.wrapped != null;
    @ requires daikon.Quant.noDups(p.terms.wrapped);
    @ requires daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures p.terms == \old(p.terms);
    @ ensures p.terms.wrapped == \old(p.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped));
    @ ensures p.terms != null;
    @ ensures p.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(p.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @*/
    /** Division operation (truncating).
        @return a new RatPoly, q, such that q = "this / p";
                if p = 0 or
                   p.isNaN() or
                   this.isNaN(), returns "NaN * x^0".

        Division of polynomials is defined as follows:
        Given two polynomials u and v, with v != "0", we can divide u by
        v to obtain a quotient polynomial q and a remainder polynomial
        r satisfying the condition u = "q * v + r" where the degree of
        r is strictly less than the degree of v.

        For the purposes of this class, the operation "u / v" returns
        q as defined above.

        Thus, "x^3-2*x+3" / "3*x^2" = "1/3*x" (with the corresponding
        r = "2*x+3"), and "x^2+2*x+15 / 2*x^3" = "0" (with the
        corresponding r = "x^2+2*x+15").

        Note that this truncating behavior is similar to the behavior
        of integer division on computers.
    */
    public RatPoly div(RatPoly p) {
        // IMPL IS STAFF ONLY
        checkRep();
        if (this.isNaN() || p.isNaN() ||
            p.unparse().equals((new RatPoly()).unparse())) {
            checkRep();
            return RatPoly.parse("NaN");
        } else {
            checkRep();
            return divAndRem(p)[0];
        }
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires p != null;
    @ requires p.terms != null;
    @ requires p.terms.wrapped != null;
    @ requires daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ requires daikon.Quant.size(p.terms.wrapped) >= 1;
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures p.terms == \old(p.terms);
    @ ensures p.terms.wrapped == \old(p.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(p.terms.wrapped, \old(p.terms.wrapped));
    @ ensures p.terms != null;
    @ ensures p.terms.wrapped != null;
    @ ensures daikon.Quant.eltsNotEqual(p.terms.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.getClass().getName() == PolyCalc.RatPoly[].class.getName();
    @ ensures daikon.Quant.eltsNotEqual(\result, null);
    @ ensures daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(\result, "terms"), null);
    @ ensures daikon.Quant.eltsNotEqual(daikon.Quant.collectObject(\result, "terms.wrapped"), null);
    @ ensures daikon.Quant.size(p.terms.wrapped) >= 1;
    @ ensures daikon.Quant.size(\result) == 2;
    @*/
    // METHOD IS STAFF ONLY
    /** @returns a RatPoly[] ps = { "this/p", "this mod p" }
     */
    private RatPoly[] divAndRem(RatPoly p) {
        // Taken from Knuth, "The Art of Computer Programming"
        // sec. 4.6.1, Algorithm D
        checkRep();
        RatPoly u = this, v = p;
        final int m = u.degree();
        final int n = v.degree();
        RatTermVec q_Terms = new RatTermVec();
        RatTermVec r_Terms = u.terms.copy();

        // D1: do step D2 for k = m-n, m-n-1, ..., 0; then terminate
        // with (r[n-1], ..., r[0]) = (u[n-1], ..., u[0])
        for(int k=m - n; k >= 0; k--) {
            // D2: Set q[k] := u[n+k]/v[n] ...
            RatTerm u_nk = hintedGet(r_Terms, findTermIndex(r_Terms, n+k), n+k);
            RatNum q_k = u_nk.coeff.div(v.coeff(n));
            if (!q_k.equals(new RatNum(0))) {
                q_Terms.addElement(new RatTerm( q_k, k ));
            }

            //     Then set u[j] := u[j] - q[k]*v[j-k]
            //                      for j=n+k-l, n+k-2, ... k
            for(int j=n+k-1; j>=k; j--) {
                int u_j_ind = findTermIndex(r_Terms, j);
                RatTerm u_j = hintedGet(r_Terms, u_j_ind, j);
                RatNum v_jk = v.coeff(j-k);

                RatNum new_u_j = u_j.coeff.sub( q_k.mul( v_jk ));

                u_j = new RatTerm(new_u_j, j);
                replaceExpt(u_j, r_Terms, u_j_ind);
            }
        }

        // Repeat:
        // with (r[n-1], ..., r[0]) = (u[n-1], ..., u[0])
        // (need to fixup r_Terms so that it has no terms from n and up
        while(r_Terms.size() > 0) { // not the only condition; see below
            RatTerm t = r_Terms.get(0);
            if (t.expt >= n) {
                r_Terms.remove(0);
            } else {
                break;
            }
        }

        RatPoly quotient = new RatPoly(q_Terms);
        RatPoly remainder = new RatPoly(r_Terms);

        if (!quotient.mul(p).add(remainder).unparse().equals(this.unparse())) {

            // check for NaN before we throw a spurious exception...
            Assert.assertTrue(!(containsNaN(q_Terms) || containsNaN(r_Terms)));
        }
        Assert.assertTrue(!(remainder.degree() >= p.degree() && p.degree() > 0)); // "invalid remainder "+remainder.unparse()
        Assert.assertTrue(!quotient.isNaN()); // "has nan...dunno how..."

        checkRep();
        return new RatPoly[] { quotient, remainder };
    }
    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    // METHOD IS STAFF ONLY
    private static boolean containsNaN(RatTermVec vec) {
        for(int i=0; i<vec.size(); i++) {
            RatTerm term = vec.get(i);
            if (term.coeff.equals(RatNum.parse("NaN"))) {
                return true;
            }
        }
        return false;
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires ts != null;
    @ requires ts.wrapped != null;
    @ requires daikon.Quant.noDups(ts.wrapped);
    @ requires daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ requires expt >= 0;
    @ requires daikon.Quant.size(ts.wrapped) >= 1;
    @ ensures ts.wrapped == \old(ts.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(ts.wrapped, \old(ts.wrapped));
    @ ensures ts.wrapped != null;
    @ ensures daikon.Quant.noDups(ts.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ ensures \result >= 0;
    @ ensures daikon.Quant.size(ts.wrapped) >= 1;
    @*/
    // METHOD IS STAFF ONLY
    private static int findTermIndex(RatTermVec ts, int expt) {
        for(int i=0; i<ts.size(); i++) {
            RatTerm t = ts.get(i);
            if (t.expt == expt) {
                return i;
            } else if (t.expt < expt) {
                return i;
            }
        }
        return ts.size();
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires ts != null;
    @ requires ts.wrapped != null;
    @ requires daikon.Quant.noDups(ts.wrapped);
    @ requires daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ requires i >= 0;
    @ requires expt >= 0;
    @ requires daikon.Quant.size(ts.wrapped) >= 1;
    @ ensures ts.wrapped == \old(ts.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(ts.wrapped, \old(ts.wrapped));
    @ ensures \result.expt == \old(expt);
    @ ensures (\result.coeff.numer == 0)  ==>  (\old(i) >= 1);
    @ ensures (\result.coeff.numer == 0)  ==>  (\result.coeff.denom == 1);
    @ ensures (\result.coeff.numer == 0)  ==>  (\result.coeff.numer < \result.coeff.denom);
    @ ensures (\result.coeff.numer == 0)  ==>  (\result.coeff.numer <= \result.expt);
    @ ensures (\result.coeff.numer == 0)  ==>  (\result.coeff.numer is a pointer);
    @ ensures ts.wrapped != null;
    @ ensures daikon.Quant.noDups(ts.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ ensures \result != null;
    @ ensures \result.coeff != null;
    @ ensures \result.coeff.denom >= 1;
    @ ensures \result.expt >= 0;
    @ ensures daikon.Quant.size(ts.wrapped) >= 1;
    @*/
    // METHOD IS STAFF ONLY
    private static RatTerm hintedGet(RatTermVec ts, int i, int expt) {
        if (i < ts.size()) {
            RatTerm ith = ts.get(i);
            if (ith.expt == expt) {
                return ith;
            }
        }
        return new RatTerm(new RatNum(0), expt);
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires term != null;
    @ requires term.coeff != null;
    @ requires term.coeff.denom >= 1;
    @ requires term.expt >= 0;
    @ requires ts != null;
    @ requires ts.wrapped != null;
    @ requires daikon.Quant.noDups(ts.wrapped);
    @ requires daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ requires index >= 1;
    @ requires daikon.Quant.size(ts.wrapped) >= 1;
    @ ensures term.coeff == \old(term.coeff);
    @ ensures term.coeff.numer == \old(term.coeff.numer);
    @ ensures term.coeff.denom == \old(term.coeff.denom);
    @ ensures term.expt == \old(term.expt);
    @ ensures ts.wrapped == \old(ts.wrapped);
    @ ensures term.coeff != null;
    @ ensures term.coeff.denom >= 1;
    @ ensures term.expt >= 0;
    @ ensures ts.wrapped != null;
    @ ensures daikon.Quant.noDups(ts.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(ts.wrapped, null);
    @ ensures daikon.Quant.size(ts.wrapped) >= 1;
    @ ensures daikon.Quant.size(ts.wrapped) >= \old(daikon.Quant.size(ts.wrapped))-1;
    @ ensures daikon.Quant.size(ts.wrapped)-1 <= \old(daikon.Quant.size(ts.wrapped));
    @ ensures (!(daikon.Quant.size(ts.wrapped)-1 == 0)) || (\old(daikon.Quant.size(ts.wrapped))-1 == 0);
    @*/
    // METHOD IS STAFF ONLY
    private static void replaceExpt(RatTerm term, RatTermVec ts, int index) {
        if (index < ts.size()) {
            RatTerm t = ts.get(index);
            if (t.expt == term.expt) {
                if (!term.coeff.equals(new RatNum(0))) {
                    ts.set(term, index);
                } else {
                    ts.remove(index);
                }
            } else {
                if (!term.coeff.equals(new RatNum(0)))
                    ts.insert(term, index);
            }
        } else {
            if (!term.coeff.equals(new RatNum(0)))
                ts.addElement(term);
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1;
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @ ensures daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1;
    @ ensures daikon.Quant.size(\result.terms.wrapped) == 0 || daikon.Quant.size(\result.terms.wrapped) == 1;
    @*/
    /** @return a new Poly equal to "0 - this". */
    public RatPoly negate() {
        // IMPL IS STAFF ONLY
        checkRep();
        RatTermVec r = this.terms.copy();
        scaleCoeff( r, new RatNum(-1) );
        checkRep();
        return new RatPoly(r);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires d >= 0.0;
    @ requires daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1 || daikon.Quant.size(this.terms.wrapped) == 2;
    @ requires (daikon.Quant.size(this.terms.wrapped) & daikon.Quant.size(this.terms.wrapped)-1) == 0;
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures daikon.Quant.size(this.terms.wrapped) == 0 || daikon.Quant.size(this.terms.wrapped) == 1 || daikon.Quant.size(this.terms.wrapped) == 2;
    @ ensures (daikon.Quant.size(this.terms.wrapped) & daikon.Quant.size(this.terms.wrapped)-1) == 0;
    @*/
    /** @return value of this expression when evaluated at 'd'.
     */
    public double eval(double d) {
        // IMPL IS STAFF ONLY
        checkRep();
        double tot = 0;
        for(int i=0; i<terms.size(); i++) {
            RatTerm rt = terms.get(i);
            tot += rt.coeff.approx() * Math.pow(d, (double) rt.expt);
        }
        checkRep();
        return tot;
    }


    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires polyStr != null;
    @ ensures polyStr.toString().equals(\old(polyStr.toString()));
    @ ensures \result != null;
    @ ensures \result.terms != null;
    @ ensures \result.terms.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.terms.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.terms.wrapped, null);
    @*/
    /** @requires: 'polyStr' is an instance of a string with no spaces
                   that expresses a poly in the form defined in the
                   unparse() method.
        @return a RatPoly p such that p.unparse() = polyStr
    */
    public static RatPoly parse(String polyStr) {
        RatPoly result = new RatPoly();

        // First we decompose the polyStr into its component terms;
        // third arg orders "+" and "-" to be returned as tokens.
        StringTokenizer termStrings =
            new StringTokenizer(polyStr, "+-", true);

        boolean nextTermIsNegative = false;
        while (termStrings.hasMoreTokens()) {
            String termToken = termStrings.nextToken();

            if (termToken.equals("-")) {
                nextTermIsNegative = true;
            } else if (termToken.equals("+")) {
                nextTermIsNegative = false;
            } else {
                // Not "+" or "-"; must be a term

                // Term is: "R" or "R*x" or "R*x^N" or "x^N" or "x",
                // where R is a rational num and N is a natural num.

                // Decompose the term into its component parts.
                // third arg orders '*' and '^' to act purely as delimiters.
                StringTokenizer numberStrings =
                    new StringTokenizer(termToken, "*^", false);

                RatNum coeff;
                int expt;

                String c1 = numberStrings.nextToken();
                if (c1.equals("x")) {
                    // ==> "x" or "x^N"
                    coeff = new RatNum(1);

                    if (numberStrings.hasMoreTokens()) {
                        // ==> "x^N"
                        String N = numberStrings.nextToken();
                        expt = Integer.parseInt(N);

                    } else {
                        // ==> "x"
                        expt = 1;
                    }
                } else {
                    // ==> "R" or "R*x" or "R*x^N"
                    String R = c1;
                    coeff = RatNum.parse(R);

                    if (numberStrings.hasMoreTokens()) {
                        // ==> "R*x" or "R*x^N"
                        String x = numberStrings.nextToken();

                        if (numberStrings.hasMoreTokens()) {
                            // ==> "R*x^N"
                            String N = numberStrings.nextToken();
                            expt = Integer.parseInt(N);
                        } else {
                            // ==> "R*x"
                            expt = 1;
                        }

                    } else {
                        // ==> "R"
                        expt = 0;
                    }
                }

                // at this point, coeff and expt are initialized.
                // Need to fix coeff if it was preceeded by a '-'
                if (nextTermIsNegative) {
                    coeff = coeff.negate();
                }


                // accumulate terms of polynomial in 'result'
                if (!coeff.equals(new RatNum(0))) {
                    RatPoly termPoly = new RatPoly();
                    termPoly.terms.addElement(new RatTerm(coeff, expt));
                    result = result.add(termPoly);
                }
            }
        }
        return result;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @ ensures \result != null;
    @*/
    public String toString() {
        checkRep();
        return this.unparse();
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ ensures this.terms == \old(this.terms);
    @ ensures this.terms.wrapped == \old(this.terms.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.terms.wrapped, \old(this.terms.wrapped));
    @*/
    // METHOD IS STAFF ONLY
    private void checkRep() {
      Assert.assertTrue(terms != null); // "terms == null!"
        for (int i=0; i < terms.size(); i++) {
            Assert.assertTrue(!terms.get(i).coeff.equals(new RatNum(0))); // "zero coefficient!"
            Assert.assertTrue(!(terms.get(i).expt < 0)); // "negative exponent!"
            Assert.assertTrue(!((i < terms.size() - 1) && (terms.get(i+1).expt >= terms.get(i).expt))); // "terms out of order!"
        }
    }
}
package PolyCalc;

import java.util.ArrayList;

/** RatTermVec is a mutable, growable array of RatTerms.  Such arrays
    are commonly referred to as <i>vectors</i>.  One can access
    RatTerms in a RatTermVec using an integer index (starting at
    zero).  The size of a RatTermVec grows (or shrinks) as needed to
    accommodate the addition and removal of RatTerms.
    <p>
    The current state of a RatTermVec can be notated as a sequence:
    [Ta, Tb, ...].  Examples of RatTermVecs include [] (an empty
    vector), [Ta], [Ta, Tb], and [Ta, Tb, Ta], where Ta and Tb are
    RatTerm objects.
*/
public class RatTermVec {
    /*@ invariant this.wrapped != null; */
    /*@ invariant daikon.Quant.eltsNotEqual(this.wrapped, null); */
    // Definitions:
    // For a RatTermVec r, let T(r,i) be "r.wrapped.get(i)"

    // AF(r) = forall i=0 to r.wrapped.size()-1, [T(r,0), T(r,1), ..., T(r,i), ...]

    // RI(r) = r.wrapped != null && forall i=0 to r.wrapped.size()-1, T(r,i) is-a Term

    /*@ spec_public */ private ArrayList<RatTerm> wrapped;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /** @effects: constructs a new empty RatTermVec, []. */
    public RatTermVec() { wrapped = new ArrayList<RatTerm>(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures \result >= 0;
    @*/
    /** @return the size of this RatTermVec. */
    public int size() { return wrapped.size(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result != null;
    @ ensures \result.coeff != null;
    @ ensures \result.coeff.denom >= 0;
    @ ensures \result.expt >= 0;
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures (!(\result.coeff.numer == 0)) || (\result.expt == 0);
    @ ensures (!(\result.coeff.denom == 0)) || (\result.expt == 0);
    @*/
    /** Indexing operation.
	@requires: 0 <= index < this.size()
	@return the RatTerm at the specified index.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the expression
	"v.get(1)" will return the RatTerm t3.
     */
    public RatTerm get(int index) { return wrapped.get(index); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires t != null;
    @ requires t.coeff != null;
    @ requires t.coeff.numer != 0;
    @ requires t.coeff.denom >= 0;
    @ requires t.expt >= 0;
    @ requires (!(t.coeff.denom == 0)) || (t.expt == 0);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures t.coeff == \old(t.coeff);
    @ ensures t.coeff.numer == \old(t.coeff.numer);
    @ ensures t.coeff.denom == \old(t.coeff.denom);
    @ ensures t.expt == \old(t.expt);
    @ ensures daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures t.coeff != null;
    @ ensures t.coeff.numer != 0;
    @ ensures t.coeff.denom >= 0;
    @ ensures t.expt >= 0;
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped);
    @ ensures (!(t.coeff.denom == 0)) || (t.expt == 0);
    @*/
    /** Appending operation.
	@requires: t != null
	@modifies: this
	@effects: Adds the specified RatTerm, 't', to the end of this
	vector, increasing the vector's size by one.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.addElement(t3);" will make v_post = [t2, t3, t4, t3].
    */
    public void addElement(RatTerm t) { wrapped.add(t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires t != null;
    @ requires t.coeff != null;
    @ requires t.coeff.denom >= 1;
    @ requires t.expt >= 0;
    @ requires index >= 0;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures t.coeff == \old(t.coeff);
    @ ensures t.coeff.numer == \old(t.coeff.numer);
    @ ensures t.coeff.denom == \old(t.coeff.denom);
    @ ensures t.expt == \old(t.expt);
    @ ensures daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped));
    @ ensures t.coeff != null;
    @ ensures t.coeff.denom >= 1;
    @ ensures t.expt >= 0;
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped);
    @*/
    /** Insertion operation.
	@requires: t != null && 0 <= index <= this.size()
	@modifies: this
	@effects: Inserts 't' as a component in this RatTermVec at the
	specified index. Each component in this vector with an index
	greater or equal to the specified index is shifted upward to
	have an index one greater than the value it had previously.
	The size of this vector is increased by 1.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.insert(t5, 1);" will make v_post = [t2, t5, t3, t4].
    */
    public void insert(RatTerm t, int index) { wrapped.add(index, t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped))-1;
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures daikon.Quant.subsetOf(this.wrapped, \old(this.wrapped));
    @*/
    /** Deletion operation.
	@requires: 0 <= index < this.size()
	@modifies: this
	@effects: Deletes the RatTerm at the specified index. Each
	RatTerm in this vector with an index greater or equal to the
	specified index is shifted downward to have an index one
	smaller than the value it had previously. The size of this
	vector is decreased by 1.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.remove(1);" will make v_post = [t2, t4].
    */
    public void remove(int index) { wrapped.remove(index); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires t != null;
    @ requires t.coeff != null;
    @ requires t.coeff.numer != 0;
    @ requires t.expt >= 0;
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ requires (!(t.coeff.denom == 0)) || (t.expt == 0);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures t.coeff == \old(t.coeff);
    @ ensures t.coeff.numer == \old(t.coeff.numer);
    @ ensures t.coeff.denom == \old(t.coeff.denom);
    @ ensures t.expt == \old(t.expt);
    @ ensures daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures t.coeff != null;
    @ ensures t.coeff.numer != 0;
    @ ensures t.expt >= 0;
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures (!(t.coeff.denom == 0)) || (t.expt == 0);
    @*/
    /** Replacement operation.
	@requires: t != null && 0 < index < this.size()
	@modifies: this
	@effects: Sets the RatTerm at the 'index' of this vector to be
	          't'. The previous RatTerm at 'index' is discarded.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.set(t5, 1);" will make v_post = [t2, t5, t4].
    */
    public void set(RatTerm t, int index) { wrapped.set(index, t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures \result != null;
    @ ensures \result.wrapped != null;
    @ ensures daikon.Quant.noDups(\result.wrapped);
    @ ensures daikon.Quant.eltsNotEqual(\result.wrapped, null);
    @*/
    /** Copy operation.
	@return a new RatTermVec whose initial state matches that of
	this RatTermVec.  Changes made to the state of the returned vector
	will NOT be reflected in this vector, and vice versa.  (Also recall
	that RatTerm objects are immutable.)
    */
    @SuppressWarnings("unchecked")
    public RatTermVec copy() {
	RatTermVec tv = new RatTermVec();
	tv.wrapped = (ArrayList<RatTerm>) this.wrapped.clone();
	return tv;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result != null;
    @*/
    /** @return implementation specific debugging string. */
    public String printDebug() {
	return "RatTermVec<wrapped:"+this.wrapped+">";
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result != null;
    @*/
    public String toString() { return printDebug(); }
}
package PolyCalc;

/** RatTerm is an immutable record type representing a term in a
    polynomial expression.  The term has the form coeff * x^expt.
    <p>

    A RatTerm can be notated by the pair (C . E),
    where C is the string representation of t.coeff, and E is t.expt.
    <p>

    For a given RatTerm r, "coefficient of r" is synonymous with
    r.coeff, and likewise "exponent of r" is synonymous with r.expt.
    <p>

    (1 . 3), (3/4 . 17), (7/2 . -1), and (NaN . 74) are all valid
    RatTerms, corresponding to the polynomial terms "x^3", "3/4*x^17",
    "7/2*x^-1" and "NaN*x^74", respectively.
*/
public class RatTerm {
    /*@ invariant this.coeff != null; */
    /*@ invariant this.coeff.denom >= 0; */
    /*@ invariant this.expt >= 0; */
    /** coefficient of this term. */
    public final RatNum coeff;

    /** exponent of this term. */
    public final int expt;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires c != null;
    @ requires c.denom >= 0;
    @ requires e >= 0;
    @ requires (!(c.denom == 0)) || (e == 0);
    @ ensures this.coeff == \old(c);
    @ ensures this.coeff.numer == c.numer;
    @ ensures this.coeff.denom == c.denom;
    @ ensures this.expt == \old(e);
    @ ensures c.numer == \old(c.numer);
    @ ensures c.denom == \old(c.denom);
    @ ensures c.denom >= 0;
    @ ensures (!(c.denom == 0)) || (this.expt == 0);
    @*/
    /** @requires: c != null
        @effects:
        constructs a new RatTerm, t, with t.coeff = c and t.expt = e.
    */
    public RatTerm(RatNum c, int e) {
        coeff = c;
        expt = e;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /** Standard equality operation.
        @return true iff 'obj' is an instance of a RatTerm and 'this' = 'obj'
    */
    public boolean equals(Object obj) {
        if (obj instanceof RatTerm) {
            RatTerm rt = (RatTerm) obj;
            return this.expt == rt.expt && this.coeff.equals(rt.coeff);
        } else {
            return false;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires (!(this.coeff.denom == 0)) || (this.expt == 0);
    @ ensures this.coeff == \old(this.coeff);
    @ ensures this.coeff.numer == \old(this.coeff.numer);
    @ ensures this.coeff.denom == \old(this.coeff.denom);
    @ ensures this.expt == \old(this.expt);
    @ ensures \result != null;
    @ ensures (!(this.coeff.denom == 0)) || (this.expt == 0);
    @*/
    /** @return implementation specific debugging string. */
    public String debugPrint() {
        return "Term<coeff:"+this.coeff.unparse()+" expt:"+this.expt+">";
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.coeff == \old(this.coeff);
    @ ensures this.coeff.numer == \old(this.coeff.numer);
    @ ensures this.coeff.denom == \old(this.coeff.denom);
    @ ensures this.expt == \old(this.expt);
    @ ensures \result != null;
    @*/
    public String toString() { return debugPrint(); }
}
package PolyCalc;

import java.lang.Double;

/** RatNum represents an immutable rational number.

    It includes all of the elements of the set of rationals, as well
    as the special "NaN" (not-a-number) element that results from
    division by zero.
    <p>
    The "NaN" element is special in many ways.  Any arithmetic
    operation (such as addition) involving "NaN" will return "NaN".
    With respect to comparison operations, such as less-than, "NaN" is
    considered equal to itself, and larger than all other rationals.
    <p>

    Examples of RatNums include "-1/13", "53/7", "4", "NaN", and "0".
*/
public class RatNum {

    /*@ invariant this.denom >= 0; */
    /*@ spec_public */ private int numer;
    /*@ spec_public */ private int denom;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(n);
    @ ensures this.denom == 1;
    @*/
    // Abstraction Function:
    //   a RatNum r is NaN if r.denom = 0, ( r.numer / r.denom ) otherwise.
    // (An abstraction function explains what the state of the fields in a
    // RatNum represents.  In this case, a rational number can be
    // understood as the result of dividing two integers, or not-a-number
    // if we would be dividing by zero.)

    // Representation invariant for every RatNum r:
    //   ( r.denom >= 0 ) &&
    //   ( r.denom > 0 ==> there does not exist integer i > 1 such that
    //                     r.numer mod i = 0 and r.denom mod i = 0 )
    // (A representation invariant tells us something that is true for all
    // instances of a RatNum; in this case, that the denominator is always
    // greater than zero and that if the denominator is non-zero, the
    // fraction represented is in reduced form.)


    /** @effects: Constructs a new RatNum = n. */
    public RatNum(int n) {
        numer = n;
        denom = 1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures (this.denom == 0)  <==>  (\old(d) == 0);
    @ ensures (this.denom == 0)  ==>  (\old(d) is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.denom == \old(d));
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.numer == \old(n));
    @ ensures (!(\old(n) == 0)) || (this.numer == 0);
    @ ensures (!(this.numer == 0)) || (\old(n) == 0);
    @ ensures (!(\old(d) == 0)) || (this.denom == 0);
    @ ensures (!(this.denom == 0)) || (\old(d) == 0);
    @*/
    /** @effects: If d = 0, constructs a new RatNum = NaN.  Else
                  constructs a new RatNum = (n / d).
    */
    public RatNum(int n, int d) {
        // special case for zero denominator; gcd(n,d) requires d != 0
        if (d == 0) {
            numer = n;
            denom = 0;
            return;
        }

        // reduce ratio to lowest terms
        int g = gcd(n,d);
        numer = n / g;
        denom = d / g;

        if (denom < 0) {
            numer = -numer;
            denom = -denom;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (this.denom == 0)  <==>  (\result == true);
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @*/
    /** @return true iff this is NaN (not-a-number) */
    public boolean isNaN() {
        return (denom == 0);
    }


    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (\result == true)  ==>  (this.denom >= 1);
    @ ensures (\result == true)  ==>  (this.numer < this.denom);
    @ ensures (\result == true)  ==>  (this.numer <= -1);
    @*/
    /** @return true iff this < 0. */
    public boolean isNegative() {
        return (this.denom != 0) && (this.numer < 0);
        // return (compareTo( new RatNum(0) ) < 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (\result == false)  ==>  (this.numer < this.denom);
    @ ensures (\result == true)  ==>  (this.numer != 0);
    @*/
    /** @return true iff this > 0. */
    public boolean isPositive() {
        return (this.denom == 0) || (this.numer > 0);
        // return (compareTo( new RatNum(0) ) > 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires rn != null;
    @ requires rn.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures rn.numer == \old(rn.numer);
    @ ensures rn.denom == \old(rn.denom);
    @ ensures rn.denom >= 0;
    @*/
    /** @requires: rn != null
        @return a negative number if this < rn,
                0 if this = rn,
                a positive number if this > rn.
    */
    public int compareTo(RatNum rn) {
        if (this.isNaN() && rn.isNaN()) {
            return 0;
        } else if (this.isNaN()) {
            return 1;
        } else if (rn.isNaN()) {
            return -1;
        } else {
            RatNum diff = this.sub(rn);
            return diff.numer;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures (this.denom == 0)  ==>  (daikon.Quant.fuzzy.eq(\result, Double.NaN));
    @ ensures (this.denom == 0)  ==>  (this.denom is a pointer);
    @ ensures (this.denom == 0)  ==>  (this.numer != this.denom);
    @*/
    /** Approximates the value of this rational.

        @return a double approximation for this.  Note that "NaN" is
        mapped to {@link Double#NaN}, and the {@link Double#NaN} value
        is treated in a
        special manner by several arithmetic operations, such as the
        comparison and equality operators.  See the
        <a href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9208">
        Java Language Specification, section 4.2.3</a>, for more details.
    */
    public double approx() {
        if (isNaN()) {
            return Double.NaN;
        } else {
            // convert int values to doubles before dividing.
            return ((double)numer) / ((double)denom);
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    /** @return a String representing this, in reduced terms.
        The returned string will either be "NaN", or it will take on
        either of the forms "N" or "N/M", where N and M are both
        integers in decimal notation and M != 0.
     */
    public String unparse() {
        // using '+' as String concatenation operator in this method

        if (isNaN()) {
            return "NaN";
        } else if (denom != 1) {
            return numer + "/" + denom;
        } else {
            return Integer.toString( numer );
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \result.denom;
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @ ensures (!(\result.numer == 0)) || (this.numer == 0);
    @ ensures (!(this.numer == 0)) || (\result.numer == 0);
    @ ensures this.numer + \result.numer == 0;
    @*/
    // in the implementation comments for the following methods, <this>
    // is notated as "a/b" and <arg> likewise as "x/y"


    /** @return a new Rational equal to (0 - this). */
    public RatNum negate() {
        return new RatNum( - this.numer , this.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this + arg).
        If either argument is NaN, then returns NaN.
     */
    public RatNum add(RatNum arg) {
        // a/b + x/y = ay/by + bx/by = (ay + bx)/by
        return new RatNum( this.numer*arg.denom + arg.numer*this.denom,
                           this.denom*arg.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this - arg).
        If either argument is NaN, then returns NaN.
    */
    public RatNum sub(RatNum arg) {
        // a/b - x/y = a/b + -x/y
        return this.add( arg.negate() );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(this.numer == 0)) || (\result.numer == 0);
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.numer == 0)) || (\result.numer == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this * arg).
        If either argument is NaN, then returns NaN.
     */
    public RatNum mul(RatNum arg) {
        // (a/b) * (x/y) = ax/by
        return new RatNum( this.numer*arg.numer,
                           this.denom*arg.denom );
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires arg != null;
    @ requires arg.denom >= 0;
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures arg.numer == \old(arg.numer);
    @ ensures arg.denom == \old(arg.denom);
    @ ensures (arg.denom == 0)  ==>  ((!(arg.numer == 0)) || (this.numer == 0));
    @ ensures (arg.denom == 0)  ==>  (arg.denom == \result.denom);
    @ ensures (arg.denom == 0)  ==>  (arg.denom is a pointer);
    @ ensures (arg.denom == 0)  ==>  (arg.numer == \result.numer);
    @ ensures (arg.denom == 0)  ==>  (\result == \old(arg));
    @ ensures (arg.denom == 0)  ==>  (\result.denom == 0);
    @ ensures (arg.denom == 0)  ==>  (\result.denom is a pointer);
    @ ensures (arg.denom == 0)  ==>  (this.denom >= arg.denom);
    @ ensures (arg.denom == 0)  ==>  (this.denom >= \result.denom);
    @ ensures arg.denom >= 0;
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @ ensures (!(\result.numer == 0)) || (this.numer == 0);
    @ ensures (!(this.denom == 0)) || (\result.denom == 0);
    @ ensures (!(arg.numer == 0)) || (\result.denom == 0);
    @ ensures (!(arg.denom == 0)) || (\result.denom == 0);
    @*/
    /** @requires: arg != null
        @return a new RatNum equal to (this / arg).
        If arg is zero, or if either argument is NaN, then returns NaN.
    */
    public RatNum div(RatNum arg) {
        // (a/b) / (x/y) = ay/bx

        if (arg.isNaN()) {
            return arg;
        } else {
            return new RatNum( this.numer*arg.denom,
                               this.denom*arg.numer );
        }
    }


    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires _b != 0;
    @ ensures \result != 0;
    @ ensures \old(_a) % \result == 0;
    @ ensures \old(_b) % \result == 0;
    @*/
    /** Returns the greatest common divisor of 'a' and 'b'.
        @requires: b != 0
        @return d such that a % d = 0 and b % d = 0
     */
    private static int gcd(int _a, int _b) {
        int a = _a, b = _b; // ESC doesn't handle modified primitive args
        // Euclid's method
        if (b == 0)
            return 0;
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /** Standard hashCode function.
        @return an int that all objects equal to this will also
                return.
    */
    public int hashCode() {
        return this.numer*2 + this.denom*3;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ requires obj != null;
    @ requires obj.getClass().getName() == PolyCalc.RatNum.class.getName();
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @*/
    /** Standard equality operation.
        @return true if and only if 'obj' is an instance of a RatNum
        and 'this' = 'obj'.  Note that NaN = NaN for RatNums.
    */
    public boolean equals(Object obj) {
        if (obj instanceof RatNum) {
            RatNum rn = (RatNum) obj;

            // special case: check if both are NaN
            if (this.isNaN() && rn.isNaN()) {
                return true;
            } else {
                return this.numer == rn.numer && this.denom == rn.denom;
            }
        } else {
            return false;
        }
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    /** @return implementation specific debugging string. */
    public String debugPrint() {
        return "RatNum<numer:"+this.numer+" denom:"+this.denom+">";
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.numer == \old(this.numer);
    @ ensures this.denom == \old(this.denom);
    @ ensures \result != null;
    @*/
    // When debugging, or when interfacing with other programs that have
    // specific I/O requirements, you might change this.
    public String toString() { return debugPrint(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires ratStr != null;
    @ ensures ratStr.toString().equals(\old(ratStr.toString()));
    @ ensures \result != null;
    @ ensures \result.denom >= 0;
    @*/
    /** Makes a RatNum from a string describing it.
        @requires: 'ratStr' is an instance of a string, with no spaces,
                   of the form: <UL>
           <LI> "NaN"
           <LI> "N/M", where N and M are both integers in
                decimal notation, and M != 0, or
           <LI> "N", where N is an integer in decimal
                notation.
        </UL>
        @returns NaN if ratStr = "NaN".  Else returns a
                  RatNum r = ( N / M ), letting M be 1 in the case
                  where only "N" is passed in.
    */
    public static RatNum parse(String ratStr) throws NumberFormatException {
        int slashLoc = ratStr.indexOf('/');
        if (ratStr.equals("NaN")) {
            return new RatNum(1,0);
        } else if (slashLoc == -1) {
            // not NaN, and no slash, must be an Integer
            return new RatNum( Integer.parseInt( ratStr ) );
        } else {
            // slash, need to parse the two parts seperately
            int n = Integer.parseInt( ratStr.substring(0, slashLoc) );
            int d = Integer.parseInt( ratStr.substring(slashLoc+1,
                                                       ratStr.length()));
            return new RatNum( n , d );
        }
    }
}
