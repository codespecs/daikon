package six170;

// Towers of Hanoi -- Text based animation
//
// Author:	  Matt Deeds
// Created:	  Sat Feb  3 14:55
// Last Modified: Sat Feb 6 21:50

/**
   @author Matt Deeds

   Hanoi represents a towers of Hanoi puzzle.  It has the ability to
   solve itself and print out the animation of the process.  */

public class Hanoi {

  /*@ invariant this.height == daikon.Quant.size(this.diskLocation); */
  /*@ invariant this.diskLocation != null; */
  /*@ invariant daikon.Quant.subsetOf(this.diskLocation, new long[] { 0, 1, 2 }); */
  // Abstraction function: each disk of size j is located on peg
  // diskLocation[j].  Disks range in size from 0 to height-1.
  /*@ spec_public */ private int diskLocation[];
  /*@ spec_public */ private int height;

  /*@ spec_public */ private boolean noOutput;

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.height == \old(height);
  @ ensures daikon.Quant.eltsEqual(this.diskLocation, 0);
  @ ensures this.noOutput == false;
  @ ensures daikon.Quant.eltsEqual(this.diskLocation, daikon.Quant.getElement_int(this.diskLocation, this.height-1));
  @*/
  // Representation invariant: Every disk is on peg 0, 1, or 2.	 */

  /**
     @requires: height > 0
     @modifies: this
     @effects: Creates a new tower of Hanoi puzzle with all disks on
     peg 0.  There are height pegs.
  */
  public Hanoi(int height) {
    diskLocation = new int[height];
    for (int i=0; i<height; i++) {
      diskLocation[i] = 0;
    }
    this.height = height;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires noOutput == true;
  @ ensures this.height == \old(height);
  @ ensures this.noOutput == \old(noOutput);
  @ ensures daikon.Quant.eltsEqual(this.diskLocation, 0);
  @ ensures this.noOutput == true;
  @ ensures daikon.Quant.eltsEqual(this.diskLocation, daikon.Quant.getElement_int(this.diskLocation, this.height-1));
  @*/
  public Hanoi(int height, boolean noOutput) {
    this(height);
    this.noOutput = noOutput;
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires this.noOutput == true;
  @ requires fromPeg == 0 || fromPeg == 1 || fromPeg == 2;
  @ requires toPeg == 0 || toPeg == 1 || toPeg == 2;
  @ requires daikon.Quant.memberOf(fromPeg , this.diskLocation );
  @ requires (fromPeg & toPeg) == 0;
  @ requires fromPeg != toPeg;
  @ ensures this.diskLocation == \old(this.diskLocation);
  @ ensures this.height == \old(this.height);
  @ ensures this.height == \old(daikon.Quant.size(this.diskLocation));
  @ ensures this.noOutput == \old(this.noOutput);
  @ ensures this.noOutput == true;
  @ ensures daikon.Quant.memberOf(\old(toPeg) , this.diskLocation );
  @*/
  /**
     @requires: fromPeg and toPeg are each 0, 1, or 2.
     @modifies: this
     @effects: moves the smallest disk on peg fromPeg to toPeg.
  */
  private void moveDisk(int fromPeg, int toPeg) {
    for (int i=0; i<height; i++) {
      if (diskLocation[i] == fromPeg) {
        diskLocation[i] = toPeg;
        break;
      }
    }
  }

  /*@
  @ private normal_behavior // Generated by Daikon
  @ requires pegA == 0 || pegA == 1 || pegA == 2;
  @ requires pegB == 0 || pegB == 1 || pegB == 2;
  @ ensures \result == 0 || \result == 1 || \result == 2;
  @*/
  /**
     @requires: pegA and pegB are each 0, 1, or 2. pegA != pegB.
     @modifies: nothing
     @effects: returns the peg (0, 1, or 2) which is not pegA or pegB.
  */
  private static int otherPeg(int pegA, int pegB) {
    if ((pegA == 0) && (pegB == 1)) return 2;
    if ((pegA == 1) && (pegB == 0)) return 2;
    if ((pegA == 0) && (pegB == 2)) return 1;
    if ((pegA == 2) && (pegB == 0)) return 1;
    if ((pegA == 1) && (pegB == 2)) return 0;
    if ((pegA == 2) && (pegB == 1)) return 0;
    return -1;

    // Cool but obfuscated: this function may be implemented as:
    // return 3-(pegA+pegB);

  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires fromPeg == daikon.Quant.getElement_int(this.diskLocation, towerHeight-1);
  @ requires this.noOutput == true;
  @ requires fromPeg == 0 || fromPeg == 1 || fromPeg == 2;
  @ requires toPeg == 0 || toPeg == 1 || toPeg == 2;
  @ requires towerHeight >= 1;
  @ requires daikon.Quant.eltwiseEqual(daikon.Quant.slice(this.diskLocation, 0, towerHeight-1));
  @ requires this.height >= towerHeight;
  @ requires (fromPeg & toPeg) == 0;
  @ requires fromPeg != toPeg;
  @ requires daikon.Quant.eltsEqual(daikon.Quant.slice(this.diskLocation, 0, towerHeight-1), fromPeg);
  @ ensures this.diskLocation == \old(this.diskLocation);
  @ ensures this.height == \old(this.height);
  @ ensures this.height == \old(daikon.Quant.size(this.diskLocation));
  @ ensures this.noOutput == \old(this.noOutput);
  @ ensures \old(toPeg) == daikon.Quant.getElement_int(this.diskLocation, \old(towerHeight)-1);
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.diskLocation, \old(towerHeight), daikon.Quant.size(this.diskLocation)), \old(daikon.Quant.slice(this.diskLocation, towerHeight, daikon.Quant.size(this.diskLocation))));
  @ ensures this.noOutput == true;
  @ ensures daikon.Quant.eltwiseEqual(daikon.Quant.slice(this.diskLocation, 0, \old(towerHeight)-1));
  @ ensures this.height >= \old(towerHeight);
  @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.diskLocation, 0, \old(towerHeight)-1), \old(toPeg));
  @*/
  /**
     @requires: fromPeg and toPeg are each 0, 1, or 2.	 There is a
                tower of height towerHeight on peg fromPeg, and it is legal
                to move it to toPeg.  towerHeight > 0.
     @modifies: this, System.out
     @effects:	moves a tower of height towerHeight from fromPeg to toPeg.
                Displays the animation of the process, excluding the
                last frame.
  */
  public void moveTower(int fromPeg, int toPeg, int towerHeight) {
    if (towerHeight == 1) {
      // Degenerate case: tower of towerHeight 1 is a disk.
      showTowers();
      moveDisk(fromPeg, toPeg);
    } else {
      moveTower(fromPeg, otherPeg(fromPeg,toPeg), towerHeight-1);
      showTowers();
      moveDisk(fromPeg, toPeg);
      moveTower(otherPeg(fromPeg, toPeg), toPeg, towerHeight-1);
    }
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.noOutput == true;
  @ ensures this.diskLocation == \old(this.diskLocation);
  @ ensures daikon.Quant.pairwiseEqual(this.diskLocation, \old(this.diskLocation));
  @ ensures this.height == \old(this.height);
  @ ensures this.height == \old(daikon.Quant.size(this.diskLocation));
  @ ensures this.noOutput == \old(this.noOutput);
  @ ensures this.noOutput == true;
  @*/
  /**
     @requires:
     @modifies: System.out
     @effects: Produces a text representation of the current state of this.
  */
  public void showTowers() {
    if (!noOutput) {
      // Producing nice looking text output requires a lot of
      // uninteresting code.
      System.out.println("");
      for (int i=0; i<height; i++) {
        for (int j=0; j<3; j++) {
          for (int k=height-1; k>=0; k--) {
            if ((diskLocation[i] == j) && (k <= i)) {
              System.out.print("=");
            } else {
              System.out.print(" ");
            }
          }
          System.out.print("|");
          for (int k=0; k<height; k++) {
            if ((diskLocation[i] == j) && (k <= i)) {
              System.out.print("=");
            } else {
              System.out.print(" ");
            }
          }
          System.out.print(" ");
        }
        System.out.println("");
      }
      for (int i=0; i<((height*2+2)*3); i++) {
        System.out.print("-");
      }
      System.out.println("");
    }
  }
}
