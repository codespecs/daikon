package DataStructures;

// StackAr class
//
// CONSTRUCTION: with or without a capacity; default is 10
//
// ******************PUBLIC OPERATIONS*********************
// void push( x )         --> Insert x
// void pop( )            --> Remove most recently inserted item
// Object top( )          --> Return most recently inserted item
// Object topAndPop( )    --> Return and remove most recently inserted item
// boolean isEmpty( )     --> Return true if empty; else false
// boolean isFull( )      --> Return true if full; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Overflow and Underflow thrown as needed

/**
 * Array-based implementation of the stack.
 * @author Mark Allen Weiss
 */
public class StackAr
{

    /*@ invariant this.theArray != null; */
    /*@ invariant this.theArray.getClass().getName() == java.lang.Object[].class.getName(); */
    /*@ invariant this.topOfStack >= -1; */
    /*@ invariant this.theArray.getClass().getName().length() == 18; */
    /*@ invariant daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), null); */
    /*@ invariant daikon.Quant.eltsNotEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), null); */
    /*@ invariant this.topOfStack <= daikon.Quant.size(this.theArray)-1; */
    /*@ invariant this.theArray.getClass().getName().length() != daikon.Quant.size(this.theArray); */
    /*@ invariant this.theArray.getClass().getName().length() != daikon.Quant.size(this.theArray)-1; */
    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires capacity >= 0;
    @ ensures \old(capacity) == daikon.Quant.size(this.theArray);
    @ ensures daikon.Quant.eltsEqual(this.theArray, null);
    @ ensures this.topOfStack == -1;
    @ ensures \old(capacity) != this.theArray.getClass().getName().length();
    @*/
    /**
     * Construct the stack.
     * @param capacity the capacity.
     */
    public StackAr( int capacity )
    {
        theArray = new Object[ capacity ];
        topOfStack = -1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
    @ ensures this.topOfStack == \old(this.topOfStack);
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures (this.topOfStack == -1)  <==>  (\result == true);
    @ ensures (this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, null));
    @ ensures (this.topOfStack == -1)  ==>  (this.topOfStack < this.theArray.getClass().getName().length());
    @ ensures (this.topOfStack >= 0)  <==>  (\result == false);
    @ ensures (this.topOfStack >= 0)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0));
    @*/
    /**
     * Test if the stack is logically empty.
     * @return true if empty, false otherwise.
     * @observer // annotation added by Jeremy
     */
    public boolean isEmpty( )
    {
        return topOfStack == -1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
    @ ensures this.topOfStack == \old(this.topOfStack);
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures (\result == false)  <==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), null));
    @ ensures (\result == false)  <==>  (this.topOfStack < daikon.Quant.size(this.theArray)-1);
    @ ensures (\result == false)  ==>  (this.topOfStack <= this.theArray.getClass().getName().length());
    @ ensures (\result == true)  <==>  (this.topOfStack == daikon.Quant.size(this.theArray)-1);
    @ ensures (\result == true)  ==>  (daikon.Quant.eltsNotEqual(this.theArray, null));
    @ ensures (\result == true)  ==>  (this.topOfStack != this.theArray.getClass().getName().length());
    @*/
    /**
     * Test if the stack is logically full.
     * @return true if full, false otherwise.
     * @observer // annotation added by Jeremy
     */
    public boolean isFull( )
    {
        return topOfStack == theArray.length - 1;
    }


    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.topOfStack < this.theArray.getClass().getName().length();
    @ requires (!(this.topOfStack == 0)) || (daikon.Quant.size(this.theArray)-1 == 0);
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))));
    @ ensures daikon.Quant.eltsEqual(this.theArray, null);
    @ ensures this.topOfStack == -1;
    @ ensures this.topOfStack <= \old(this.topOfStack);
    @ ensures \old(this.topOfStack) < this.theArray.getClass().getName().length();
    @ ensures (!(\old(this.topOfStack) == 0)) || (daikon.Quant.size(this.theArray)-1 == 0);
    @ ensures \old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1;
    @*/
    /**
     * Make the stack logically empty.
     */
    public void makeEmpty( )
    {
        java.util.Arrays.fill(theArray, 0, topOfStack + 1, null);
        topOfStack = -1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
    @ ensures this.topOfStack == \old(this.topOfStack);
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures (this.topOfStack == -1)  <==>  (\result == null);
    @ ensures (this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, null));
    @ ensures (this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, \result));
    @ ensures (this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), \result));
    @ ensures (this.topOfStack == -1)  ==>  (this.topOfStack < this.theArray.getClass().getName().length());
    @ ensures (this.topOfStack >= 0)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0));
    @ ensures (this.topOfStack >= 0)  ==>  (\result == \old(daikon.Quant.getElement_Object(this.theArray, this.topOfStack)));
    @ ensures (this.topOfStack >= 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)));
    @ ensures (this.topOfStack >= 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, this.topOfStack));
    @ ensures (this.topOfStack >= 0)  ==>  (\result.getClass().getName().length() % 2 == 0);
    @ ensures (this.topOfStack >= 0)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 22 || \result.getClass().getName().length() == 24);
    @ ensures (this.topOfStack >= 0)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length());
    @ ensures (this.topOfStack >= 0)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length());
    @ ensures (this.topOfStack >= 0)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName());
    @ ensures (this.topOfStack >= 0)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length());
    @ ensures \result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 22 || \result.getClass().getName().length() == 24;
    @ ensures \result.getClass().getName().length() % 2 == 0;
    @ ensures this.theArray.getClass().getName() != \result.getClass().getName();
    @ ensures this.theArray.getClass().getName().length() != \result.getClass().getName().length();
    @ ensures (!(daikon.Quant.size(this.theArray) == 0)) || (\result.getClass().getName().length() == 0);
    @ ensures daikon.Quant.size(this.theArray) != \result.getClass().getName().length();
    @ ensures daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length();
    @*/
    /**
     * Get the most recently inserted item in the stack.
     * Does not alter the stack.
     * @return the most recently inserted item in the stack, or null, if empty.
     * @observer // annotation added by Jeremy
     */
    public Object top( )
    {
        if( isEmpty( ) )
            return null;
        return theArray[ topOfStack ];
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.topOfStack >= 0;
    @ requires daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, this.topOfStack));
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1)));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))));
    @ ensures daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)) == null;
    @ ensures daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, \old(this.topOfStack)));
    @ ensures this.topOfStack - \old(this.topOfStack) + 1 == 0;
    @ ensures this.topOfStack <= this.theArray.getClass().getName().length();
    @ ensures this.topOfStack < daikon.Quant.size(this.theArray)-1;
    @ ensures \old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1;
    @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)));
    @*/
    /**
     * Remove the most recently inserted item from the stack.
     * @exception Underflow if stack is already empty.
     */
    public void pop( ) throws Underflow
    {
        if( isEmpty( ) )
            throw new Underflow( );
        theArray[ topOfStack-- ] = null;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires x != null;
    @ requires x.getClass().getName().length() == 16 || x.getClass().getName().length() == 22 || x.getClass().getName().length() == 24;
    @ requires x.getClass().getName().length() % 2 == 0;
    @ requires this.theArray.getClass().getName() != x.getClass().getName();
    @ requires this.topOfStack <= this.theArray.getClass().getName().length();
    @ requires this.topOfStack < daikon.Quant.size(this.theArray)-1;
    @ requires this.theArray.getClass().getName().length() != x.getClass().getName().length();
    @ requires daikon.Quant.size(this.theArray) != x.getClass().getName().length();
    @ requires daikon.Quant.size(this.theArray)-1 != x.getClass().getName().length();
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures \old(x) == daikon.Quant.getElement_Object(this.theArray, this.topOfStack);
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
    @ ensures x.getClass().getName().length() == \old(x.getClass().getName()).length();
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack)));
    @ ensures this.topOfStack >= 0;
    @ ensures x.getClass().getName().length() == 16 || x.getClass().getName().length() == 22 || x.getClass().getName().length() == 24;
    @ ensures x.getClass().getName().length() % 2 == 0;
    @ ensures this.theArray.getClass().getName() != \old(x.getClass().getName());
    @ ensures this.topOfStack - \old(this.topOfStack) - 1 == 0;
    @ ensures (!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0);
    @ ensures \old(this.topOfStack) <= this.theArray.getClass().getName().length();
    @ ensures \old(this.topOfStack) < daikon.Quant.size(this.theArray)-1;
    @ ensures daikon.Quant.eltsEqual(this.theArray[][\old(this.topOfStack)+1..this.topOfStack], \old(x));
    @ ensures this.theArray.getClass().getName().length() != x.getClass().getName().length();
    @ ensures daikon.Quant.size(this.theArray) != x.getClass().getName().length();
    @ ensures daikon.Quant.size(this.theArray)-1 != x.getClass().getName().length();
    @*/
    /**
     * Insert a new item into the stack, if not already full.
     * @param x the item to insert.
     * @exception Overflow if stack is already full.
     */
    public void push( Object x ) throws Overflow
    {
        if( isFull( ) )
            throw new Overflow( );
        theArray[ ++topOfStack ] = x;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, this.topOfStack));
    @ ensures this.theArray == \old(this.theArray);
    @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
    @ ensures this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length();
    @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))));
    @ ensures (\result != null)  <==>  (\old(this.topOfStack) >= 0);
    @ ensures (\result != null)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.topOfStack) == 0));
    @ ensures (\result != null)  ==>  (\old(this.topOfStack) != \result.getClass().getName().length());
    @ ensures (\result != null)  ==>  (\result.getClass().getName().length() % 8 == 0);
    @ ensures (\result != null)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 24);
    @ ensures (\result != null)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length());
    @ ensures (\result != null)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length());
    @ ensures (\result != null)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName());
    @ ensures (\result != null)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length());
    @ ensures (\result != null)  ==>  (daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1))));
    @ ensures (\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack), daikon.Quant.size(this.theArray)), null));
    @ ensures (\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack), daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack))));
    @ ensures (\result != null)  ==>  (daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)) == null);
    @ ensures (\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack))));
    @ ensures (\result != null)  ==>  (this.topOfStack - \old(this.topOfStack) + 1 == 0);
    @ ensures (\result != null)  ==>  (this.topOfStack < daikon.Quant.size(this.theArray)-1);
    @ ensures (\result == null)  <==>  (\old(this.topOfStack) == -1);
    @ ensures (\result == null)  <==>  (this.topOfStack == \old(this.topOfStack));
    @ ensures (\result == null)  ==>  (daikon.Quant.eltsEqual(\old(this.theArray), null));
    @ ensures (\result == null)  ==>  (\old(this.topOfStack) < this.theArray.getClass().getName().length());
    @ ensures (\result == null)  ==>  (daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray)));
    @ ensures (\result == null)  ==>  (daikon.Quant.eltsEqual(this.theArray, null));
    @ ensures (\result == null)  ==>  (this.topOfStack < this.theArray.getClass().getName().length());
    @ ensures (\result == null)  ==>  (this.topOfStack == -1);
    @ ensures \result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 24;
    @ ensures \result.getClass().getName().length() % 8 == 0;
    @ ensures daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, \old(this.topOfStack)));
    @ ensures this.theArray.getClass().getName() != \result.getClass().getName();
    @ ensures this.topOfStack <= \old(this.topOfStack);
    @ ensures this.topOfStack <= this.theArray.getClass().getName().length();
    @ ensures \old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1;
    @ ensures \old(this.topOfStack) != \result.getClass().getName().length();
    @ ensures this.theArray.getClass().getName().length() != \result.getClass().getName().length();
    @ ensures (!(daikon.Quant.size(this.theArray) == 0)) || (\result.getClass().getName().length() == 0);
    @ ensures daikon.Quant.size(this.theArray) != \result.getClass().getName().length();
    @ ensures daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length();
    @*/
    /**
     * Return and remove most recently inserted item from the stack.
     * @return most recently inserted item, or null, if stack is empty.
     */
    public Object topAndPop( )
    {
        if( isEmpty( ) )
            return null;
        Object topItem = top( );
        theArray[ topOfStack-- ] = null;
        return topItem;
    }

    /*@ spec_public */ private Object [ ] theArray;
    /*@ spec_public */ private int        topOfStack;

}
