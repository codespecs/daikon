===========================================================================
DataStructures.StackAr:::OBJECT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
this.theArray != null
this.theArray.getClass().getName() == java.lang.Object[].class.getName()
this.topOfStack >= -1
this.theArray.getClass().getName().length() == 18
daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), null)
daikon.Quant.eltsNotEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), null)
this.topOfStack <= daikon.Quant.size(this.theArray)-1
(daikon.Quant.size(this.theArray) >> this.theArray.getClass().getName().length() == 0)
this.theArray.getClass().getName().length() != daikon.Quant.size(this.theArray)
this.theArray.getClass().getName().length() != daikon.Quant.size(this.theArray)-1
===========================================================================
DataStructures.StackAr.StackAr(int):::ENTER
    Variables: capacity
capacity >= 0
===========================================================================
DataStructures.StackAr.StackAr(int):::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack capacity orig(capacity) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[capacity] this.theArray[capacity-1] this.theArray[capacity..] this.theArray[capacity+1..] this.theArray[0..capacity] this.theArray[0..capacity-1] this.theArray[orig(capacity)] this.theArray[orig(capacity)-1] this.theArray[orig(capacity)..] this.theArray[orig(capacity)+1..] this.theArray[0..orig(capacity)] this.theArray[0..orig(capacity)-1] this.theArray[this.topOfStack+1..capacity] this.theArray[this.topOfStack..capacity-1] this.theArray[this.topOfStack+1..capacity-1] this.theArray[capacity+1..this.topOfStack] this.theArray[capacity..this.topOfStack-1] this.theArray[capacity+1..this.topOfStack-1] this.theArray[this.topOfStack+1..orig(capacity)] this.theArray[this.topOfStack..orig(capacity)-1] this.theArray[this.topOfStack+1..orig(capacity)-1] this.theArray[orig(capacity)+1..this.topOfStack] this.theArray[orig(capacity)..this.topOfStack-1] this.theArray[orig(capacity)+1..this.topOfStack-1] this.theArray[capacity+1..orig(capacity)] this.theArray[capacity..orig(capacity)-1] this.theArray[capacity+1..orig(capacity)-1] this.theArray[orig(capacity)+1..capacity] this.theArray[orig(capacity)..capacity-1] this.theArray[orig(capacity)+1..capacity-1]
\old(capacity) == daikon.Quant.size(this.theArray)
daikon.Quant.eltsEqual(this.theArray, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null)
this.topOfStack == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
(\old(capacity) >> this.theArray.getClass().getName().length() == 0)
\old(capacity) != this.theArray.getClass().getName().length()
===========================================================================
DataStructures.StackAr.isEmpty():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
===========================================================================
DataStructures.StackAr.isEmpty():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray))
this.topOfStack == \old(this.topOfStack)
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
(this.topOfStack == -1)  <==>  (\result == true)
(this.topOfStack == -1)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, null))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null))
(this.topOfStack == -1)  ==>  (this.topOfStack < this.theArray.getClass().getName().length())
(this.topOfStack >= 0)  <==>  (\result == false)
(this.topOfStack >= 0)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0))
(this.topOfStack >= 0)  ==>  ((daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  ((this.topOfStack >> this.theArray.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(this.topOfStack >= 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
===========================================================================
DataStructures.StackAr.isFull():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
===========================================================================
DataStructures.StackAr.isFull():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray))
this.topOfStack == \old(this.topOfStack)
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
(\result == false)  <==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), null))
(\result == false)  <==>  (this.topOfStack < daikon.Quant.size(this.theArray)-1)
(\result == false)  ==>  ((daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0))
(\result == false)  ==>  (this.topOfStack <= this.theArray.getClass().getName().length())
(\result == true)  <==>  (this.topOfStack == daikon.Quant.size(this.theArray)-1)
(\result == true)  ==>  (daikon.Quant.eltsNotEqual(this.theArray, null))
(\result == true)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == true)  ==>  (this.topOfStack != this.theArray.getClass().getName().length())
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
===========================================================================
DataStructures.StackAr.makeEmpty():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
this.topOfStack < this.theArray.getClass().getName().length()
(!(this.topOfStack == 0)) || (daikon.Quant.size(this.theArray)-1 == 0)
===========================================================================
DataStructures.StackAr.makeEmpty():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[*], this.topOfStack, this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))))
daikon.Quant.eltsEqual(this.theArray, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null)
this.topOfStack == -1
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
this.topOfStack <= \old(this.topOfStack)
\old(this.topOfStack) < this.theArray.getClass().getName().length()
(!(\old(this.topOfStack) == 0)) || (daikon.Quant.size(this.theArray)-1 == 0)
\old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1
===========================================================================
DataStructures.StackAr.pop():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
this.topOfStack >= 0
daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, this.topOfStack))
(this.topOfStack >> this.theArray.getClass().getName().length() == 0)
===========================================================================
DataStructures.StackAr.pop():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[*], this.topOfStack, this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[this.topOfStack+1..], this.theArray[0..this.topOfStack], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, \new(this.topOfStack))))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))))
daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)) == null
daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, \old(this.topOfStack)))
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
this.topOfStack - \old(this.topOfStack) + 1 == 0
this.topOfStack <= this.theArray.getClass().getName().length()
this.topOfStack < daikon.Quant.size(this.theArray)-1
(\old(this.topOfStack) >> this.theArray.getClass().getName().length() == 0)
\old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1
daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)))
===========================================================================
DataStructures.StackAr.push(java.lang.Object):::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack x x.getClass().getName() this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 x.getClass().getName().length() this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
x != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: x.getClass().getName() is printable
x.getClass().getName().length() == 16 || x.getClass().getName().length() == 22 || x.getClass().getName().length() == 24
x.getClass().getName().length() % 2 == 0
this.theArray.getClass().getName() != x.getClass().getName()
this.topOfStack <= this.theArray.getClass().getName().length()
this.topOfStack < daikon.Quant.size(this.theArray)-1
(daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0)
this.theArray.getClass().getName().length() != x.getClass().getName().length()
(daikon.Quant.size(this.theArray) >> x.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray) != x.getClass().getName().length()
(daikon.Quant.size(this.theArray)-1 >> x.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray)-1 != x.getClass().getName().length()
===========================================================================
DataStructures.StackAr.push(java.lang.Object):::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack x x.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) orig(x) orig(x.getClass().getName()) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 x.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 orig(x.getClass().getName()).length() this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[*], this.topOfStack, this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[this.topOfStack+1..], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
\old(x) == daikon.Quant.getElement_Object(this.theArray, this.topOfStack)
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray))
x.getClass().getName().length() == \old(x.getClass().getName()).length()
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, \new(this.topOfStack)+1, daikon.Quant.size(this.theArray))))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1), \old(daikon.Quant.slice(this.theArray, 0, \new(this.topOfStack)-1)))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack)))
this.topOfStack >= 0
x.getClass().getName().length() == 16 || x.getClass().getName().length() == 22 || x.getClass().getName().length() == 24
x.getClass().getName().length() % 2 == 0
daikon.Quant.eltsEqual(\old(daikon.Quant.slice(this.theArray, \new(this.topOfStack), daikon.Quant.size(this.theArray))), null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
this.theArray.getClass().getName() != \old(x.getClass().getName())
daikon.Quant.memberOf(\old(x.getClass().getName()) , daikon.Quant.typeArray(this.theArray) )
this.topOfStack - \old(this.topOfStack) - 1 == 0
(this.topOfStack >> this.theArray.getClass().getName().length() == 0)
(!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0)
(this.topOfStack >> x.getClass().getName().length() == 0)
\old(this.topOfStack) <= this.theArray.getClass().getName().length()
\old(this.topOfStack) < daikon.Quant.size(this.theArray)-1
daikon.Quant.eltsEqual(this.theArray[][\old(this.topOfStack)+1..this.topOfStack], \old(x))
(daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0)
this.theArray.getClass().getName().length() != x.getClass().getName().length()
(daikon.Quant.size(this.theArray) >> x.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray) != x.getClass().getName().length()
(daikon.Quant.size(this.theArray)-1 >> x.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray)-1 != x.getClass().getName().length()
daikon.Quant.eltsEqual(\old(daikon.Quant.slice(this.theArray, \new(this.topOfStack), daikon.Quant.size(this.theArray))), \old(daikon.Quant.getElement_Object(this.theArray, \new(this.topOfStack))))
===========================================================================
DataStructures.StackAr.top():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
===========================================================================
DataStructures.StackAr.top():::EXIT74
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack-1]
daikon.Quant.eltsEqual(this.theArray, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null)
this.topOfStack == -1
\result == null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(this.theArray, \result)
===========================================================================
DataStructures.StackAr.top():::EXIT75
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack-1]
\result == daikon.Quant.getElement_Object(this.theArray, this.topOfStack)
\result == daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack))
\result == \old(daikon.Quant.getElement_Object(this.theArray, \new(this.topOfStack)))
\result == \old(daikon.Quant.getElement_Object(this.theArray, this.topOfStack))
this.topOfStack >= 0
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable
\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 22 || \result.getClass().getName().length() == 24
\result.getClass().getName().length() % 2 == 0
this.theArray.getClass().getName() != \result.getClass().getName()
daikon.Quant.memberOf(\result.getClass().getName() , daikon.Quant.typeArray(this.theArray) )
(this.topOfStack >> this.theArray.getClass().getName().length() == 0)
(!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0)
(this.topOfStack >> \result.getClass().getName().length() == 0)
(daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0)
this.theArray.getClass().getName().length() != \result.getClass().getName().length()
(daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray) != \result.getClass().getName().length()
(daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length()
===========================================================================
DataStructures.StackAr.top():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray))
this.topOfStack == \old(this.topOfStack)
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
(this.topOfStack == -1)  <==>  (\result == null)
(this.topOfStack == -1)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, null))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(this.theArray, \result))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null))
(this.topOfStack == -1)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), \result))
(this.topOfStack == -1)  ==>  (this.topOfStack < this.theArray.getClass().getName().length())
(this.topOfStack >= 0)  ==>  ((daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.topOfStack == 0))
(this.topOfStack >= 0)  ==>  ((daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  ((daikon.Quant.size(this.theArray)-1 >> this.theArray.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  ((this.topOfStack >> \result.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  ((this.topOfStack >> this.theArray.getClass().getName().length() == 0))
(this.topOfStack >= 0)  ==>  (\result == \old(daikon.Quant.getElement_Object(this.theArray, \new(this.topOfStack))))
(this.topOfStack >= 0)  ==>  (\result == \old(daikon.Quant.getElement_Object(this.theArray, this.topOfStack)))
(this.topOfStack >= 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)))
(this.topOfStack >= 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, this.topOfStack))
(this.topOfStack >= 0)  ==>  (daikon.Quant.memberOf(\result.getClass().getName() , daikon.Quant.typeArray(this.theArray) ))
(this.topOfStack >= 0)  ==>  (warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable)
(this.topOfStack >= 0)  ==>  (\result.getClass().getName().length() % 2 == 0)
(this.topOfStack >= 0)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 22 || \result.getClass().getName().length() == 24)
(this.topOfStack >= 0)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length())
(this.topOfStack >= 0)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length())
(this.topOfStack >= 0)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName())
(this.topOfStack >= 0)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length())
(this.topOfStack >= 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(this.topOfStack >= 0)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result != null)  ==>  (warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable)
(\result != null)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 22 || \result.getClass().getName().length() == 24)
(\result != null)  ==>  (\result.getClass().getName().length() % 2 == 0)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
(\result != null)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName())
(\result != null)  ==>  (daikon.Quant.memberOf(\result.getClass().getName() , daikon.Quant.typeArray(this.theArray) ))
(\result != null)  ==>  ((this.topOfStack >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length())
(\result != null)  ==>  ((!(daikon.Quant.size(this.theArray) == 0)) || (\result.getClass().getName().length() == 0))
(\result != null)  ==>  ((daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length())
(\result != null)  ==>  ((daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length())
===========================================================================
DataStructures.StackAr.topAndPop():::ENTER
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1]
daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, this.topOfStack))
===========================================================================
DataStructures.StackAr.topAndPop():::EXIT108
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[0..this.topOfStack-1]
daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray))
this.topOfStack == \old(this.topOfStack)
daikon.Quant.eltsEqual(this.theArray, null)
daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null)
this.topOfStack == -1
\result == null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
===========================================================================
DataStructures.StackAr.topAndPop():::EXIT111
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[*], this.topOfStack, this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[this.topOfStack+1..], this.theArray[0..this.topOfStack], this.theArray[0..this.topOfStack-1]
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1)))
\result != null
warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable
\old(this.topOfStack) >= 0
\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 24
\result.getClass().getName().length() % 8 == 0
daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)) == null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
this.theArray.getClass().getName() != \result.getClass().getName()
this.topOfStack - \old(this.topOfStack) + 1 == 0
this.topOfStack < daikon.Quant.size(this.theArray)-1
daikon.Quant.memberOf(\result.getClass().getName() , \old(daikon.Quant.typeArray(this.theArray)) )
(\old(this.topOfStack) >> this.theArray.getClass().getName().length() == 0)
(!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.topOfStack) == 0)
(\old(this.topOfStack) >> \result.getClass().getName().length() == 0)
\old(this.topOfStack) != \result.getClass().getName().length()
this.theArray.getClass().getName().length() != \result.getClass().getName().length()
(daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray) != \result.getClass().getName().length()
(daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0)
daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length()
daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)))
===========================================================================
DataStructures.StackAr.topAndPop():::EXIT
    Variables: this this.theArray this.theArray.getClass().getName() this.theArray[] this.theArray[].getClass().getName() this.topOfStack return return.getClass().getName() orig(this) orig(this.theArray) orig(this.theArray.getClass().getName()) orig(this.theArray[]) orig(this.theArray[].getClass().getName()) orig(this.topOfStack) this.theArray.getClass().getName().length() size(this.theArray[]) size(this.theArray[])-1 return.getClass().getName().length() orig(this.theArray.getClass().getName()).length() orig(size(this.theArray[])) orig(size(this.theArray[]))-1 this.theArray[this.topOfStack] this.theArray[this.topOfStack-1] this.theArray[this.topOfStack..] this.theArray[this.topOfStack+1..] this.theArray[0..this.topOfStack] this.theArray[0..this.topOfStack-1] this.theArray[orig(this.topOfStack)] this.theArray[orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)..] this.theArray[orig(this.topOfStack)+1..] this.theArray[0..orig(this.topOfStack)] this.theArray[0..orig(this.topOfStack)-1] orig(this.theArray[post(this.topOfStack)]) orig(this.theArray[post(this.topOfStack)-1]) orig(this.theArray[post(this.topOfStack)..]) orig(this.theArray[post(this.topOfStack)+1..]) orig(this.theArray[0..post(this.topOfStack)]) orig(this.theArray[0..post(this.topOfStack)-1]) orig(this.theArray[this.topOfStack]) orig(this.theArray[this.topOfStack-1]) orig(this.theArray[this.topOfStack..]) orig(this.theArray[this.topOfStack+1..]) orig(this.theArray[0..this.topOfStack]) orig(this.theArray[0..this.topOfStack-1]) this.theArray[this.topOfStack+1..orig(this.topOfStack)] this.theArray[this.topOfStack..orig(this.topOfStack)-1] this.theArray[this.topOfStack+1..orig(this.topOfStack)-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack] this.theArray[orig(this.topOfStack)..this.topOfStack-1] this.theArray[orig(this.topOfStack)+1..this.topOfStack-1]
assignable this.theArray[*], this.topOfStack, this.theArray[this.topOfStack], this.theArray[this.topOfStack-1], this.theArray[this.topOfStack..], this.theArray[this.topOfStack+1..], this.theArray[0..this.topOfStack], this.theArray[0..this.topOfStack-1]
this.theArray == \old(this.theArray)
this.theArray.getClass().getName() == \old(this.theArray.getClass().getName())
this.theArray.getClass().getName().length() == \old(this.theArray.getClass().getName()).length()
daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, \new(this.topOfStack))))
daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray))))
(\result != null)  <==>  (\old(this.topOfStack) >= 0)
(\result != null)  <==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result != null)  ==>  ((\old(this.topOfStack) >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  ((\old(this.topOfStack) >> this.theArray.getClass().getName().length() == 0))
(\result != null)  ==>  ((daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.topOfStack) == 0))
(\result != null)  ==>  ((daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (\old(this.topOfStack) != \result.getClass().getName().length())
(\result != null)  ==>  (daikon.Quant.memberOf(\result.getClass().getName() , \old(daikon.Quant.typeArray(this.theArray)) ))
(\result != null)  ==>  (warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable)
(\result != null)  ==>  (\result.getClass().getName().length() % 8 == 0)
(\result != null)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 24)
(\result != null)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length())
(\result != null)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length())
(\result != null)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName())
(\result != null)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length())
(\result != null)  ==>  (daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, this.topOfStack), \old(daikon.Quant.slice(this.theArray, 0, this.topOfStack-1))))
(\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack), daikon.Quant.size(this.theArray)), null))
(\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, \old(this.topOfStack), daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack))))
(\result != null)  ==>  (daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack)) == null)
(\result != null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.topOfStack+1, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.topOfStack))))
(\result != null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result != null)  ==>  (this.topOfStack - \old(this.topOfStack) + 1 == 0)
(\result != null)  ==>  (this.topOfStack < daikon.Quant.size(this.theArray)-1)
(\result == null)  <==>  (\old(this.topOfStack) == -1)
(\result == null)  <==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == null)  <==>  (this.topOfStack == \old(this.topOfStack))
(\result == null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == null)  ==>  (daikon.Quant.eltsEqual(\old(this.theArray), null))
(\result == null)  ==>  (daikon.Quant.eltsEqual(\old(daikon.Quant.typeArray(this.theArray)), null))
(\result == null)  ==>  (daikon.Quant.eltsEqual(\old(daikon.Quant.slice(this.theArray, \new(this.topOfStack)+1, daikon.Quant.size(this.theArray))), null))
(\result == null)  ==>  (\old(this.topOfStack) < this.theArray.getClass().getName().length())
(\result == null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == null)  ==>  (daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray)))
(\result == null)  ==>  (daikon.Quant.eltsEqual(this.theArray, null))
(\result == null)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.typeArray(this.theArray), null))
(\result == null)  ==>  (("oneOf.java.jpp: SEQUENCE unimplemented" != null))
(\result == null)  ==>  (this.topOfStack < this.theArray.getClass().getName().length())
(\result == null)  ==>  (this.topOfStack == -1)
(\result != null)  ==>  (warning: method daikon.inv.unary.string.PrintableString.format(OutputFormat:JML) needs to be implemented: return.getClass().getName() is printable)
(\result != null)  ==>  (\result.getClass().getName().length() == 16 || \result.getClass().getName().length() == 24)
(\result != null)  ==>  (\result.getClass().getName().length() % 8 == 0)
daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, \old(this.topOfStack)))
(\result != null)  ==>  (this.theArray.getClass().getName() != \result.getClass().getName())
this.topOfStack <= \old(this.topOfStack)
this.topOfStack <= this.theArray.getClass().getName().length()
(\result != null)  ==>  (daikon.Quant.memberOf(\result.getClass().getName() , \old(daikon.Quant.typeArray(this.theArray)) ))
\old(this.topOfStack) <= daikon.Quant.size(this.theArray)-1
(\result != null)  ==>  ((\old(this.topOfStack) >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (\old(this.topOfStack) != \result.getClass().getName().length())
(\result != null)  ==>  (this.theArray.getClass().getName().length() != \result.getClass().getName().length())
(\result != null)  ==>  ((!(daikon.Quant.size(this.theArray) == 0)) || (\result.getClass().getName().length() == 0))
(\result != null)  ==>  ((daikon.Quant.size(this.theArray) >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (daikon.Quant.size(this.theArray) != \result.getClass().getName().length())
(\result != null)  ==>  ((daikon.Quant.size(this.theArray)-1 >> \result.getClass().getName().length() == 0))
(\result != null)  ==>  (daikon.Quant.size(this.theArray)-1 != \result.getClass().getName().length())
