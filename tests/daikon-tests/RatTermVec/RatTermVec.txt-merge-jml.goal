package PolyCalc;

import java.util.ArrayList;

/** RatTermVec is a mutable, growable array of RatTerms.  Such arrays
    are commonly referred to as <i>vectors</i>.  One can access
    RatTerms in a RatTermVec using an integer index (starting at
    zero).  The size of a RatTermVec grows (or shrinks) as needed to
    accommodate the addition and removal of RatTerms.
    <p>
    The current state of a RatTermVec can be notated as a sequence:
    [Ta, Tb, ...].  Examples of RatTermVecs include [] (an empty
    vector), [Ta], [Ta, Tb], and [Ta, Tb, Ta], where Ta and Tb are
    RatTerm objects.
*/
public class RatTermVec {
    /*@ invariant this.wrapped != null; */
    /*@ invariant daikon.Quant.eltsNotEqual(this.wrapped, null); */
    // Definitions:
    // For a RatTermVec r, let T(r,i) be "r.wrapped.get(i)"

    // AF(r) = forall i=0 to r.wrapped.size()-1, [T(r,0), T(r,1), ..., T(r,i), ...]

    // RI(r) = r.wrapped != null && forall i=0 to r.wrapped.size()-1, T(r,i) is-a Term

    /*@ spec_public */ private ArrayList<RatTerm> wrapped;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /** @effects: constructs a new empty RatTermVec, []. */
    public RatTermVec() { wrapped = new ArrayList<RatTerm>(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result == daikon.Quant.size(this.wrapped);
    @ ensures \result == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @*/
    /** @return the size of this RatTermVec. */
    public int size() { return wrapped.size(); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ requires daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, index+1, daikon.Quant.size(this.wrapped)));
    @ requires daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, 0, index));
    @ requires (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.wrapped)-1;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result == daikon.Quant.getElement_Object(this.wrapped, \old(index));
    @ ensures \result != null;
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, \old(index)+1, daikon.Quant.size(this.wrapped)));
    @ ensures daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, 0, \old(index)));
    @ ensures daikon.Quant.memberOf(\result , this.wrapped );
    @ ensures daikon.Quant.memberOf(\result , daikon.Quant.slice(this.wrapped, \old(index), daikon.Quant.size(this.wrapped)) );
    @ ensures daikon.Quant.memberOf(\result , daikon.Quant.slice(this.wrapped, 0, \old(index)) );
    @ ensures (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.wrapped)-1;
    @*/
    /** Indexing operation.
	@requires: 0 <= index < this.size()
	@return the RatTerm at the specified index.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the expression
	"v.get(1)" will return the RatTerm t3.
     */
    public RatTerm get(int index) { return wrapped.get(index); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires t != null;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped);
    @ ensures daikon.Quant.memberOf(\old(t) , this.wrapped );
    @*/
    /** Appending operation.
	@requires: t != null
	@modifies: this
	@effects: Adds the specified RatTerm, 't', to the end of this
	vector, increasing the vector's size by one.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.addElement(t3);" will make v_post = [t2, t3, t4, t3].
    */
    public void addElement(RatTerm t) { wrapped.add(t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires t != null;
    @ requires index >= 0;
    @ requires daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, 0, index-1));
    @ requires (!(daikon.Quant.size(this.wrapped) == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.wrapped);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures \old(t) == daikon.Quant.getElement_Object(this.wrapped, \old(index));
    @ ensures daikon.Quant.size(this.wrapped)-1 == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, \old(index)+1, daikon.Quant.size(this.wrapped)), \old(daikon.Quant.slice(this.wrapped, index, daikon.Quant.size(this.wrapped))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, 0, \old(index)-1), \old(daikon.Quant.slice(this.wrapped, 0, index-1)));
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.noDups(daikon.Quant.slice(this.wrapped, 0, \old(index)-1));
    @ ensures daikon.Quant.subsetOf(\old(this.wrapped), this.wrapped);
    @ ensures daikon.Quant.memberOf(\old(t) , this.wrapped );
    @ ensures daikon.Quant.memberOf(\old(t) , daikon.Quant.slice(this.wrapped, \old(index), daikon.Quant.size(this.wrapped)) );
    @ ensures daikon.Quant.memberOf(\old(t) , daikon.Quant.slice(this.wrapped, 0, \old(index)) );
    @ ensures (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.wrapped)-1;
    @*/
    /** Insertion operation.
	@requires: t != null && 0 <= index <= this.size()
	@modifies: this
	@effects: Inserts 't' as a component in this RatTermVec at the
	specified index. Each component in this vector with an index
	greater or equal to the specified index is shifted upward to
	have an index one greater than the value it had previously.
	The size of this vector is increased by 1.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.insert(t5, 1);" will make v_post = [t2, t5, t3, t4].
    */
    public void insert(RatTerm t, int index) { wrapped.add(index, t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ requires (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.wrapped)-1;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped))-1;
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, \old(index), daikon.Quant.size(this.wrapped)), \old(daikon.Quant.slice(this.wrapped, index+1, daikon.Quant.size(this.wrapped))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, 0, \old(index)-1), \old(daikon.Quant.slice(this.wrapped, 0, index-1)));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures daikon.Quant.subsetOf(this.wrapped, \old(this.wrapped));
    @ ensures (!(daikon.Quant.size(this.wrapped) == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.wrapped);
    @*/
    /** Deletion operation.
	@requires: 0 <= index < this.size()
	@modifies: this
	@effects: Deletes the RatTerm at the specified index. Each
	RatTerm in this vector with an index greater or equal to the
	specified index is shifted downward to have an index one
	smaller than the value it had previously. The size of this
	vector is decreased by 1.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.remove(1);" will make v_post = [t2, t4].
    */
    public void remove(int index) { wrapped.remove(index); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ requires t != null;
    @ requires index >= 0;
    @ requires daikon.Quant.size(this.wrapped) >= 1;
    @ requires (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.wrapped)-1;
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures \old(t) == daikon.Quant.getElement_Object(this.wrapped, \old(index));
    @ ensures daikon.Quant.size(this.wrapped) == \old(daikon.Quant.size(this.wrapped));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, \old(index)+1, daikon.Quant.size(this.wrapped)), \old(daikon.Quant.slice(this.wrapped, index+1, daikon.Quant.size(this.wrapped))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.wrapped, 0, \old(index)-1), \old(daikon.Quant.slice(this.wrapped, 0, index-1)));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures daikon.Quant.size(this.wrapped) >= 1;
    @ ensures daikon.Quant.memberOf(\old(t) , this.wrapped );
    @ ensures daikon.Quant.memberOf(\old(t) , daikon.Quant.slice(this.wrapped, \old(index), daikon.Quant.size(this.wrapped)) );
    @ ensures daikon.Quant.memberOf(\old(t) , daikon.Quant.slice(this.wrapped, 0, \old(index)) );
    @ ensures (!(daikon.Quant.size(this.wrapped)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.wrapped)-1;
    @*/
    /** Replacement operation.
	@requires: t != null && 0 < index < this.size()
	@modifies: this
	@effects: Sets the RatTerm at the 'index' of this vector to be
	          't'. The previous RatTerm at 'index' is discarded.
	<br>
	e.g. Given a RatTermVec v = [t2, t3, t4], the statement
	"v.set(t5, 1);" will make v_post = [t2, t5, t4].
    */
    public void set(RatTerm t, int index) { wrapped.set(index, t); }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires daikon.Quant.noDups(this.wrapped);
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \result.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures daikon.Quant.noDups(this.wrapped);
    @ ensures \result != null;
    @ ensures \result.wrapped != null;
    @*/
    /** Copy operation.
	@return a new RatTermVec whose initial state matches that of
	this RatTermVec.  Changes made to the state of the returned vector
	will NOT be reflected in this vector, and vice versa.  (Also recall
	that RatTerm objects are immutable.)
    */
    @SuppressWarnings("unchecked")
    public RatTermVec copy() {
	RatTermVec tv = new RatTermVec();
	tv.wrapped = (ArrayList<RatTerm>) this.wrapped.clone();
	return tv;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result != null;
    @*/
    /** @return implementation specific debugging string. */
    public String printDebug() {
	return "RatTermVec<wrapped:"+this.wrapped+">";
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.wrapped == \old(this.wrapped);
    @ ensures daikon.Quant.pairwiseEqual(this.wrapped, \old(this.wrapped));
    @ ensures \result != null;
    @*/
    public String toString() { return printDebug(); }
}
