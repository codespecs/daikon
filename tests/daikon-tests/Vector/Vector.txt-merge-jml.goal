/*
 * @(#)Vector.java	1.39 98/07/01
 *
 * Copyright 1995-1998 by Sun Microsystems, Inc.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 * 
 * This software is the confidential and proprietary information
 * of Sun Microsystems, Inc. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

package javautil;

import java.util.Enumeration;
import java.util.NoSuchElementException;


/**
 * The <code>Vector</code> class implements a growable array of 
 * objects. Like an array, it contains components that can be 
 * accessed using an integer index. However, the size of a 
 * <code>Vector</code> can grow or shrink as needed to accommodate 
 * adding and removing items after the <code>Vector</code> has been created.
 * <p>
 * Each vector tries to optimize storage management by maintaining a 
 * <code>capacity</code> and a <code>capacityIncrement</code>. The 
 * <code>capacity</code> is always at least as large as the vector 
 * size; it is usually larger because as components are added to the 
 * vector, the vector's storage increases in chunks the size of 
 * <code>capacityIncrement</code>. An application can increase the 
 * capacity of a vector before inserting a large number of 
 * components; this reduces the amount of incremental reallocation. 
 *
 * @author  Lee Boynton
 * @author  Jonathan Payne
 * @version 1.39, 07/01/98
 * @since   JDK1.0
 */
public
class Vector13 implements Cloneable, java.io.Serializable {
    /*@ invariant this.elementData != null; */
    /*@ invariant this.elementData.getClass().getName() == java.lang.Object[].class.getName(); */
    /*@ invariant this.elementCount >= 0; */
    /*@ invariant this.capacityIncrement >= 0; */
    /*@ invariant daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), null); */
    /*@ invariant this.elementCount > javautil.Vector13.serialVersionUID; */
    /*@ invariant (!(daikon.Quant.size(this.elementData) == 0)) || (this.elementCount == 0); */
    /*@ invariant this.elementCount <= daikon.Quant.size(this.elementData); */
    /*@ invariant this.capacityIncrement > javautil.Vector13.serialVersionUID; */
    /*@ invariant javautil.Vector13.serialVersionUID < daikon.Quant.size(this.elementData)-1; */
    /**
     * The array buffer into which the components of the vector are 
     * stored. The capacity of the vector is the length of this array buffer.
     *
     * @since   JDK1.0
     */
    /*@ spec_public */ protected Object elementData[];

    /**
     * The number of valid components in the vector. 
     *
     * @since   JDK1.0
     */
    /*@ spec_public */ protected int elementCount;

    /**
     * The amount by which the capacity of the vector is automatically 
     * incremented when its size becomes greater than its capacity. If 
     * the capacity increment is <code>0</code>, the capacity of the 
     * vector is doubled each time it needs to grow. 
     *
     * @since   JDK1.0
     */
    /*@ spec_public */ protected int capacityIncrement;

    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    /*@ spec_public */ private static final long serialVersionUID = -2767605614048989439L;

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires initialCapacity >= 0;
    @ requires capacityIncrement >= 0;
    @ ensures this.capacityIncrement == \old(capacityIncrement);
    @ ensures \old(initialCapacity) == daikon.Quant.size(this.elementData);
    @ ensures daikon.Quant.eltsEqual(this.elementData, null);
    @ ensures this.elementCount == 0;
    @ ensures this.elementCount <= this.capacityIncrement;
    @ ensures this.elementCount <= \old(initialCapacity);
    @ ensures this.elementCount == (this.capacityIncrement / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (\old(initialCapacity) / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (daikon.Quant.size(this.elementData)-1 / javautil.Vector13.serialVersionUID);
    @*/
    /**
     * Constructs an empty vector with the specified initial capacity and
     * capacity increment. 
     *
     * @param   initialCapacity     the initial capacity of the vector.
     * @param   capacityIncrement   the amount by which the capacity is
     *                              increased when the vector overflows.
     * @since   JDK1.0
     */
    public Vector13(int initialCapacity, int capacityIncrement) {
	super();
	this.elementData = new Object[initialCapacity];
	this.capacityIncrement = capacityIncrement;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires initialCapacity >= 0;
    @ ensures this.elementCount == this.capacityIncrement;
    @ ensures \old(initialCapacity) == daikon.Quant.size(this.elementData);
    @ ensures daikon.Quant.eltsEqual(this.elementData, null);
    @ ensures this.elementCount == 0;
    @ ensures this.elementCount <= \old(initialCapacity);
    @ ensures this.elementCount == (\old(initialCapacity) / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (daikon.Quant.size(this.elementData)-1 / javautil.Vector13.serialVersionUID);
    @*/
    /**
     * Constructs an empty vector with the specified initial capacity.
     *
     * @param   initialCapacity   the initial capacity of the vector.
     * @since   JDK1.0
     */
    public Vector13(int initialCapacity) {
	this(initialCapacity, 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementCount == this.capacityIncrement;
    @ ensures daikon.Quant.eltsEqual(this.elementData, null);
    @ ensures this.elementCount == 0;
    @ ensures daikon.Quant.size(this.elementData) == 10;
    @ ensures daikon.Quant.eltsEqual(this.elementData, daikon.Quant.getElement_Object(this.elementData, this.elementCount));
    @*/
    /**
     * Constructs an empty vector. 
     *
     * @since   JDK1.0
     */
    public Vector13() {
	this(10);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.elementData.getClass().getName() == anArray.getClass().getName();
    @ requires anArray != null;
    @ requires daikon.Quant.eltwiseEqual(daikon.Quant.slice(anArray, this.elementCount, daikon.Quant.size(anArray)));
    @ requires (!(daikon.Quant.size(anArray) == 0)) || (this.elementCount == 0);
    @ requires this.elementCount <= daikon.Quant.size(anArray);
    @ requires javautil.Vector13.serialVersionUID < daikon.Quant.size(anArray)-1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.elementData.getClass().getName() == \old(anArray.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, this.elementCount-1), daikon.Quant.slice(anArray, 0, this.elementCount-1));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, \old(this.elementCount)-1), daikon.Quant.slice(anArray, 0, this.elementCount-1));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(anArray, this.elementCount, daikon.Quant.size(anArray)), \old(daikon.Quant.slice(anArray, this.elementCount, daikon.Quant.size(anArray))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(anArray, 0, this.elementCount-1), \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @ ensures daikon.Quant.eltwiseEqual(daikon.Quant.slice(anArray, this.elementCount, daikon.Quant.size(anArray)));
    @ ensures (!(\old(daikon.Quant.size(anArray)) == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= \old(daikon.Quant.size(anArray));
    @ ensures javautil.Vector13.serialVersionUID < daikon.Quant.size(anArray)-1;
    @*/
    /**
     * Copies the components of this vector into the specified array. 
     * The array must be big enough to hold all the objects in this  vector.
     *
     * @param   anArray   the array into which the components get copied.
     * @since   JDK1.0
     */
    public final synchronized void copyInto(Object[] anArray) {
	int i = elementCount;
	while (i-- > 0) {
	    anArray[i] = elementData[i];
	}
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.elementCount == daikon.Quant.size(this.elementData);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures (!(\old(daikon.Quant.size(this.elementData)) == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.size(this.elementData)-1 <= \old(daikon.Quant.size(this.elementData))-1;
    @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData))));
    @*/
    /**
     * Trims the capacity of this vector to be the vector's current 
     * size. An application can use this operation to minimize the 
     * storage of a vector. 
     *
     * @since   JDK1.0
     */
    public final synchronized void trimToSize() {
	int oldCapacity = elementData.length;
	if (elementCount < oldCapacity) {
	    Object oldData[] = elementData;
	    elementData = new Object[elementCount];
	    System.arraycopy(oldData, 0, elementData, 0, elementCount);
	}
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires minCapacity >= 0;
    @ requires javautil.Vector13.serialVersionUID < minCapacity;
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, this.elementCount-1), \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @ ensures daikon.Quant.subsetOf(\old(this.elementData), this.elementData);
    @ ensures (!(\old(daikon.Quant.size(this.elementData)) == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= \old(daikon.Quant.size(this.elementData));
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(minCapacity) == 0);
    @ ensures \old(minCapacity) <= daikon.Quant.size(this.elementData);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(daikon.Quant.size(this.elementData)) == 0);
    @ ensures daikon.Quant.size(this.elementData) >= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.size(this.elementData)-1 >= \old(daikon.Quant.size(this.elementData))-1;
    @*/
    /**
     * Increases the capacity of this vector, if necessary, to ensure 
     * that it can hold at least the number of components specified by 
     * the minimum capacity argument. 
     *
     * @param   minCapacity   the desired minimum capacity.
     * @since   JDK1.0
     */
    public final synchronized void ensureCapacity(int minCapacity) {
	if (minCapacity > elementData.length) {
	    ensureCapacityHelper(minCapacity);
	}
    }

    /*@
    @ private normal_behavior // Generated by Daikon
    @ requires minCapacity >= 1;
    @ requires this.elementCount < minCapacity;
    @ requires javautil.Vector13.serialVersionUID < minCapacity;
    @ requires minCapacity > daikon.Quant.size(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.getElement_Object(this.elementData, this.elementCount) == daikon.Quant.getElement_Object(this.elementData, \old(minCapacity)-1);
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, this.elementCount-1), \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @ ensures daikon.Quant.size(this.elementData) >= 1;
    @ ensures daikon.Quant.subsetOf(\old(this.elementData), this.elementData);
    @ ensures this.elementCount < \old(minCapacity);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= daikon.Quant.size(this.elementData)-1;
    @ ensures (!(\old(daikon.Quant.size(this.elementData)) == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= \old(daikon.Quant.size(this.elementData));
    @ ensures this.capacityIncrement <= daikon.Quant.size(this.elementData);
    @ ensures daikon.Quant.subsetOf(\old(this.elementData), daikon.Quant.slice(this.elementData, 0, this.elementCount));
    @ ensures daikon.Quant.subsetOf(\old(this.elementData), daikon.Quant.slice(this.elementData, 0, \old(minCapacity)-1));
    @ ensures \old(minCapacity) <= daikon.Quant.size(this.elementData);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(daikon.Quant.size(this.elementData)) == 0);
    @ ensures daikon.Quant.size(this.elementData)-1 >= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), daikon.Quant.getElement_Object(this.elementData, this.elementCount));
    @*/
    /**
     * This implements the unsynchronized semantics of ensureCapacity.
     * Synchronized methods in this class can internally call this 
     * method for ensuring capacity without incurring the cost of an 
     * extra synchronization.
     *
     * @see java.util.Vector#ensureCapacity(int)
     */ 
    private void ensureCapacityHelper(int minCapacity) {
	int oldCapacity = elementData.length;
	Object oldData[] = elementData;
	int newCapacity = (capacityIncrement > 0) ?
	    (oldCapacity + capacityIncrement) : (oldCapacity * 2);
	if (newCapacity < minCapacity) {
	    newCapacity = minCapacity;
	}
	elementData = new Object[newCapacity];
	System.arraycopy(oldData, 0, elementData, 0, elementCount);
    }
    
    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires newSize >= 0;
    @ requires javautil.Vector13.serialVersionUID < newSize;
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.elementCount == \old(newSize);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, \old(this.elementCount), daikon.Quant.size(this.elementData)), null);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (this.capacityIncrement == 0);
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(this.elementCount) == 0);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(daikon.Quant.size(this.elementData)) == 0);
    @ ensures daikon.Quant.size(this.elementData) >= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.size(this.elementData)-1 >= \old(daikon.Quant.size(this.elementData))-1;
    @ ensures daikon.Quant.size(this.elementData) == (java.lang.Math.max(this.elementCount, \old(daikon.Quant.size(this.elementData))));
    @*/
    /**
     * Sets the size of this vector. If the new size is greater than the 
     * current size, new <code>null</code> items are added to the end of 
     * the vector. If the new size is less than the current size, all 
     * components at index <code>newSize</code> and greater are discarded.
     *
     * @param   newSize   the new size of this vector.
     * @since   JDK1.0
     */
    public final synchronized void setSize(int newSize) {
	if ((newSize > elementCount) && (newSize > elementData.length)) {
	    ensureCapacityHelper(newSize);
	} else {
	    for (int i = newSize ; i < elementCount ; i++) {
		elementData[i] = null;
	    }
	}
	elementCount = newSize;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires true;
    @*/
    /**
     * Returns the current capacity of this vector.
     *
     * @return  the current capacity of this vector.
     * @since   JDK1.0
     */
    public final int capacity() {
	return elementData.length;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \result;
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result == \old(this.elementCount);
    @ ensures \result >= 0;
    @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, \result, daikon.Quant.size(this.elementData)), null);
    @ ensures javautil.Vector13.serialVersionUID < \result;
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\result == 0);
    @ ensures \result <= daikon.Quant.size(this.elementData);
    @*/
    /**
     * Returns the number of components in this vector.
     *
     * @return  the number of components in this vector.
     * @since   JDK1.0
     */
    public final int size() {
	return elementCount;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures (this.elementCount == 0)  <==>  (\result == true);
    @ ensures (this.elementCount == 0)  ==>  (this.elementCount <= this.capacityIncrement);
    @ ensures (this.elementCount == 0)  ==>  (this.elementCount == (daikon.Quant.size(this.elementData) / javautil.Vector13.serialVersionUID));
    @ ensures (this.elementCount == 0)  ==>  (this.elementCount == (daikon.Quant.size(this.elementData)-1 / javautil.Vector13.serialVersionUID));
    @ ensures (this.elementCount == 0)  ==>  (this.elementCount == (this.capacityIncrement / javautil.Vector13.serialVersionUID));
    @ ensures (this.elementCount == 0)  ==>  (this.elementCount is a pointer);
    @ ensures (this.elementCount == 0)  ==>  (daikon.Quant.eltsEqual(this.elementData, null));
    @*/
    /**
     * Tests if this vector has no components.
     *
     * @return  <code>true</code> if this vector has no components;
     *          <code>false</code> otherwise.
     * @since   JDK1.0
     */
    public final boolean isEmpty() {
	return elementCount == 0;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result != null;
    @ ensures \result.getClass().getName() == javautil.VectorEnumerator13.class.getName();
    @ ensures this.elementData.getClass().getName() != \result.getClass().getName();
    @*/
    /**
     * Returns an enumeration of the components of this vector.
     *
     * @return  an enumeration of the components of this vector.
     * @see     java.util.Enumeration
     * @since   JDK1.0
     */
    public final synchronized Enumeration elements() {
	return new VectorEnumerator13(this);
    }
    
    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires elem != null;
    @ requires this.elementData.getClass().getName() != elem.getClass().getName();
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(elem) , daikon.Quant.slice(this.elementData, 0, this.elementCount-1) ));
    @ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(elem) , this.elementData ));
    @ ensures (\result == true)  ==>  (this.elementCount >= 1);
    @ ensures this.elementData.getClass().getName() != \old(elem.getClass().getName());
    @*/
    /**
     * Tests if the specified object is a component in this vector.
     *
     * @param   elem   an object.
     * @return  <code>true</code> if the specified object is a component in
     *          this vector; <code>false</code> otherwise.
     * @since   JDK1.0
     */
    public final boolean contains(Object elem) {
	return indexOf(elem, 0) >= 0;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires elem != null;
    @ requires this.elementData.getClass().getName() != elem.getClass().getName();
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result >= -1;
    @ ensures this.elementData.getClass().getName() != \old(elem.getClass().getName());
    @ ensures this.elementCount > \result;
    @ ensures javautil.Vector13.serialVersionUID < \result;
    @ ensures \result <= daikon.Quant.size(this.elementData)-1;
    @*/
    /**
     * Searches for the first occurence of the given argument, testing 
     * for equality using the <code>equals</code> method. 
     *
     * @param   elem   an object.
     * @return  the index of the first occurrence of the argument in this
     *          vector; returns <code>-1</code> if the object is not found.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @since   JDK1.0
     */
    public final int indexOf(Object elem) {
	return indexOf(elem, 0);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires elem != null;
    @ requires index >= 0;
    @ requires this.elementData.getClass().getName() != elem.getClass().getName();
    @ requires javautil.Vector13.serialVersionUID < index;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures (\result == -1)  <==>  (\result < \old(index));
    @ ensures (\result == -1)  ==>  (this.capacityIncrement > \result);
    @ ensures (\result >= 0)  <==>  (\result >= \old(index));
    @ ensures (\result >= 0)  ==>  ((!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0));
    @ ensures (\result >= 0)  ==>  ((!(daikon.Quant.size(this.elementData)-1 == 0)) || (\result == 0));
    @ ensures (\result >= 0)  ==>  (\old(elem) == daikon.Quant.getElement_Object(this.elementData, \result));
    @ ensures (\result >= 0)  ==>  (\old(index) <= daikon.Quant.size(this.elementData)-1);
    @ ensures (\result >= 0)  ==>  (this.elementCount > \old(index));
    @ ensures (\result >= 0)  ==>  (this.elementCount >= 1);
    @ ensures (\result >= 0)  ==>  (daikon.Quant.getElement_Object(this.elementData, \result) != null);
    @ ensures \result >= -1;
    @ ensures this.elementData.getClass().getName() != \old(elem.getClass().getName());
    @ ensures this.elementCount > \result;
    @ ensures javautil.Vector13.serialVersionUID < \result;
    @ ensures (!(\result == 0)) || (\old(index) == 0);
    @ ensures \result <= daikon.Quant.size(this.elementData)-1;
    @*/
    /**
     * Searches for the first occurence of the given argument, beginning 
     * the search at <code>index</code>, and testing for equality using 
     * the <code>equals</code> method. 
     *
     * @param   elem    an object.
     * @param   index   the index to start searching from.
     * @return  the index of the first occurrence of the object argument in
     *          this vector at position <code>index</code> or later in the
     *          vector; returns <code>-1</code> if the object is not found.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @since   JDK1.0
     */
    public final synchronized int indexOf(Object elem, int index) {
	for (int i = index ; i < elementCount ; i++) {
	    if (elem.equals(elementData[i])) {
		return i;
	    }
	}
	return -1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires elem != null;
    @ requires this.elementData.getClass().getName() != elem.getClass().getName();
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result >= -1;
    @ ensures this.elementData.getClass().getName() != \old(elem.getClass().getName());
    @ ensures this.elementCount > \result;
    @ ensures javautil.Vector13.serialVersionUID < \result;
    @ ensures \result <= daikon.Quant.size(this.elementData)-1;
    @*/
    /**
     * Returns the index of the last occurrence of the specified object in
     * this vector.
     *
     * @param   elem   the desired component.
     * @return  the index of the last occurrence of the specified object in
     *          this vector; returns <code>-1</code> if the object is not found.
     * @since   JDK1.0
     */
    public final int lastIndexOf(Object elem) {
	return lastIndexOf(elem, elementCount-1);
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires elem != null;
    @ requires index >= -1;
    @ requires this.elementData.getClass().getName() != elem.getClass().getName();
    @ requires this.elementCount > index;
    @ requires javautil.Vector13.serialVersionUID < index;
    @ requires index <= daikon.Quant.size(this.elementData)-1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures (\result == -1)  ==>  (\old(index) >= -1);
    @ ensures (\result == -1)  ==>  (this.capacityIncrement > \result);
    @ ensures (\result >= 0)  ==>  ((!(\old(index) == 0)) || (\result == 0));
    @ ensures (\result >= 0)  ==>  ((!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0));
    @ ensures (\result >= 0)  ==>  ((!(daikon.Quant.size(this.elementData)-1 == 0)) || (\result == 0));
    @ ensures (\result >= 0)  ==>  (\old(elem) == daikon.Quant.getElement_Object(this.elementData, \result));
    @ ensures (\result >= 0)  ==>  (\old(index) >= 0);
    @ ensures (\result >= 0)  ==>  (this.elementCount >= 1);
    @ ensures (\result >= 0)  ==>  (daikon.Quant.getElement_Object(this.elementData, \result) != null);
    @ ensures \result >= -1;
    @ ensures this.elementData.getClass().getName() != \old(elem.getClass().getName());
    @ ensures this.elementCount > \result;
    @ ensures this.elementCount > \old(index);
    @ ensures javautil.Vector13.serialVersionUID < \result;
    @ ensures \result <= \old(index);
    @ ensures \result <= daikon.Quant.size(this.elementData)-1;
    @ ensures \old(index) <= daikon.Quant.size(this.elementData)-1;
    @*/
    /**
     * Searches backwards for the specified object, starting from the 
     * specified index, and returns an index to it. 
     *
     * @param   elem    the desired component.
     * @param   index   the index to start searching from.
     * @return  the index of the last occurrence of the specified object in this
     *          vector at position less than <code>index</code> in the vector;
     *          <code>-1</code> if the object is not found.
     * @since   JDK1.0
     */
    public final synchronized int lastIndexOf(Object elem, int index) {
	for (int i = index ; i >= 0 ; i--) {
	    if (elem.equals(elementData[i])) {
		return i;
	    }
	}
	return -1;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires index >= 0;
    @ requires this.elementCount > index;
    @ requires javautil.Vector13.serialVersionUID < index;
    @ requires (!(daikon.Quant.size(this.elementData)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.elementData)-1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result == daikon.Quant.getElement_Object(this.elementData, \old(index));
    @ ensures \result == \old(daikon.Quant.getElement_Object(this.elementData, index));
    @ ensures this.elementData.getClass().getName() != \result.getClass().getName();
    @ ensures this.elementCount > \old(index);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.elementData)-1;
    @*/
    /**
     * Returns the component at the specified index.
     *
     * @param      index   an index into this vector.
     * @return     the component at the specified index.
     * @exception  ArrayIndexOutOfBoundsException  if an invalid index was
     *               given.
     * @since      JDK1.0
     */
    public final synchronized Object elementAt(int index) {
	if (index >= elementCount) {
	    throw new ArrayIndexOutOfBoundsException(index + " >= " + elementCount);
	}
	/* Since try/catch is free, except when the exception is thrown,
	   put in this extra try/catch to catch negative indexes and
	   display a more informative error message.  This might not
	   be appropriate, especially if we have a decent debugging
	   environment - JP. */
	try {
	    return elementData[index];
	} catch (ArrayIndexOutOfBoundsException e) {
	    throw new ArrayIndexOutOfBoundsException(index + " < 0");
	}
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.elementCount >= 1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures this.elementCount >= 1;
    @ ensures this.elementData.getClass().getName() != \result.getClass().getName();
    @ ensures daikon.Quant.memberOf(\result , this.elementData );
    @ ensures daikon.Quant.memberOf(\result , daikon.Quant.slice(this.elementData, 0, this.elementCount-1) );
    @*/
    /**
     * Returns the first component of this vector.
     *
     * @return     the first component of this vector.
     * @exception  NoSuchElementException  if this vector has no components.
     * @since      JDK1.0
     */
    public final synchronized Object firstElement() {
	if (elementCount == 0) {
	    throw new NoSuchElementException();
	}
	return elementData[0];
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.elementCount >= 1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result == daikon.Quant.getElement_Object(this.elementData, this.elementCount-1);
    @ ensures \result == daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount)-1);
    @ ensures \result == \old(daikon.Quant.getElement_Object(this.elementData, this.elementCount-1));
    @ ensures this.elementCount >= 1;
    @ ensures this.elementData.getClass().getName() != \result.getClass().getName();
    @*/
    /**
     * Returns the last component of the vector.
     *
     * @return  the last component of the vector, i.e., the component at index
     *          <code>size()&nbsp;-&nbsp;1</code>.
     * @exception  NoSuchElementException  if this vector is empty.
     * @since   JDK1.0
     */
    public final synchronized Object lastElement() {
	if (elementCount == 0) {
	    throw new NoSuchElementException();
	}
	return elementData[elementCount - 1];
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires index >= 0;
    @ requires this.elementData.getClass().getName() != obj.getClass().getName();
    @ requires this.elementCount > index;
    @ requires javautil.Vector13.serialVersionUID < index;
    @ requires (!(daikon.Quant.size(this.elementData)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.elementData)-1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \old(obj) == daikon.Quant.getElement_Object(this.elementData, \old(index));
    @ ensures daikon.Quant.size(this.elementData) == \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, \old(index)+1, daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, index+1, daikon.Quant.size(this.elementData))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, \old(index)-1), \old(daikon.Quant.slice(this.elementData, 0, index-1)));
    @ ensures this.elementData.getClass().getName() != \old(obj.getClass().getName());
    @ ensures daikon.Quant.memberOf(\old(daikon.Quant.getElement_Object(this.elementData, this.elementCount-1)) , this.elementData );
    @ ensures this.elementCount > \old(index);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.elementData)-1;
    @ ensures daikon.Quant.memberOf(\old(daikon.Quant.getElement_Object(this.elementData, this.elementCount-1)) , daikon.Quant.slice(this.elementData, 0, this.elementCount-1) );
    @*/
    /**
     * Sets the component at the specified <code>index</code> of this 
     * vector to be the specified object. The previous component at that 
     * position is discarded. 
     * <p>
     * The index must be a value greater than or equal to <code>0</code> 
     * and less than the current size of the vector. 
     *
     * @param      obj     what the component is to be set to.
     * @param      index   the specified index.
     * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
     * @see        java.util.Vector#size()
     * @since      JDK1.0
     */
    public final synchronized void setElementAt(Object obj, int index) {
	if (index >= elementCount) {
	    throw new ArrayIndexOutOfBoundsException(index + " >= " + 
						     elementCount);
	}
	elementData[index] = obj;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.elementCount >= 1;
    @ requires index >= 0;
    @ requires this.elementCount > index;
    @ requires javautil.Vector13.serialVersionUID < index;
    @ requires (!(daikon.Quant.size(this.elementData)-1 == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.elementData)-1;
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.size(this.elementData) == \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.getElement_Object(this.elementData, this.elementCount) == daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount)-1);
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, this.elementCount+1, daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData))));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, \old(index)-1), \old(daikon.Quant.slice(this.elementData, 0, index-1)));
    @ ensures this.elementCount - \old(this.elementCount) + 1 == 0;
    @ ensures (!(this.elementCount == 0)) || (\old(index) == 0);
    @ ensures this.elementCount >= \old(index);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= daikon.Quant.size(this.elementData)-1;
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.elementData)-1;
    @ ensures daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), daikon.Quant.getElement_Object(this.elementData, this.elementCount));
    @*/
    /**
     * Deletes the component at the specified index. Each component in 
     * this vector with an index greater or equal to the specified 
     * <code>index</code> is shifted downward to have an index one 
     * smaller than the value it had previously. 
     * <p>
     * The index must be a value greater than or equal to <code>0</code> 
     * and less than the current size of the vector. 
     *
     * @param      index   the index of the object to remove.
     * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
     * @see        java.util.Vector#size()
     * @since      JDK1.0
     */
    public final synchronized void removeElementAt(int index) {
	if (index >= elementCount) {
	    throw new ArrayIndexOutOfBoundsException(index + " >= " + 
						     elementCount);
	}
	else if (index < 0) {
	    throw new ArrayIndexOutOfBoundsException(index);
	}
	int j = elementCount - index - 1;
	if (j > 0) {
	    System.arraycopy(elementData, index + 1, elementData, index, j);
	}
	elementCount--;
	elementData[elementCount] = null; /* to let gc do its work */
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires index >= 0;
    @ requires this.elementData.getClass().getName() != obj.getClass().getName();
    @ requires (!(this.elementCount == 0)) || (index == 0);
    @ requires this.elementCount >= index;
    @ requires javautil.Vector13.serialVersionUID < index;
    @ requires (!(daikon.Quant.size(this.elementData) == 0)) || (index == 0);
    @ requires index <= daikon.Quant.size(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \old(obj) == daikon.Quant.getElement_Object(this.elementData, \old(index));
    @ ensures daikon.Quant.getElement_Object(this.elementData, this.elementCount-1) == daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, \old(index)-1), \old(daikon.Quant.slice(this.elementData, 0, index-1)));
    @ ensures this.elementCount >= 1;
    @ ensures this.elementData.getClass().getName() != \old(obj.getClass().getName());
    @ ensures this.elementCount - \old(this.elementCount) - 1 == 0;
    @ ensures this.elementCount > \old(index);
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(this.elementCount) == 0);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData)-1;
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(index) == 0);
    @ ensures \old(index) <= daikon.Quant.size(this.elementData)-1;
    @ ensures daikon.Quant.size(this.elementData) >= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.size(this.elementData)-1 >= \old(daikon.Quant.size(this.elementData))-1;
    @*/
    /**
     * Inserts the specified object as a component in this vector at the 
     * specified <code>index</code>. Each component in this vector with 
     * an index greater or equal to the specified <code>index</code> is 
     * shifted upward to have an index one greater than the value it had 
     * previously. 
     * <p>
     * The index must be a value greater than or equal to <code>0</code> 
     * and less than or equal to the current size of the vector. 
     *
     * @param      obj     the component to insert.
     * @param      index   where to insert the new component.
     * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
     * @see        java.util.Vector#size()
     * @since      JDK1.0
     */
    public final synchronized void insertElementAt(Object obj, int index) {
	int newcount = elementCount + 1;
	if (index >= newcount) {
	    throw new ArrayIndexOutOfBoundsException(index
						     + " > " + elementCount);
	}
	if (newcount > elementData.length) {
	    ensureCapacityHelper(newcount);
	}
	System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
	elementData[index] = obj;
	elementCount++;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires this.elementData.getClass().getName() != obj.getClass().getName();
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \old(obj) == daikon.Quant.getElement_Object(this.elementData, this.elementCount-1);
    @ ensures \old(obj) == daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, 0, \old(this.elementCount)-1), \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @ ensures this.elementCount >= 1;
    @ ensures daikon.Quant.size(this.elementData) >= 1;
    @ ensures this.elementData.getClass().getName() != \old(obj.getClass().getName());
    @ ensures this.elementCount - \old(this.elementCount) - 1 == 0;
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures (!(daikon.Quant.size(this.elementData)-1 == 0)) || (\old(this.elementCount) == 0);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData)-1;
    @ ensures daikon.Quant.size(this.elementData) >= \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.size(this.elementData)-1 >= \old(daikon.Quant.size(this.elementData))-1;
    @*/
    /**
     * Adds the specified component to the end of this vector, 
     * increasing its size by one. The capacity of this vector is 
     * increased if its size becomes greater than its capacity. 
     *
     * @param   obj   the component to be added.
     * @since   JDK1.0
     */
    public final synchronized void addElement(Object obj) {
	int newcount = elementCount + 1;
	if (newcount > elementData.length) {
	    ensureCapacityHelper(newcount);
	}
	elementData[elementCount++] = obj;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ requires obj != null;
    @ requires this.elementData.getClass().getName() != obj.getClass().getName();
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.size(this.elementData) == \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, \old(this.elementCount), daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData))));
    @ ensures (\result == false)  <==>  (this.elementCount == \old(this.elementCount));
    @ ensures (\result == false)  ==>  (daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData)));
    @ ensures (\result == true)  <==>  (this.elementCount - \old(this.elementCount) + 1 == 0);
    @ ensures (\result == true)  ==>  ((!(daikon.Quant.size(this.elementData)-1 == 0)) || (this.elementCount == 0));
    @ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(obj) , \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)) ));
    @ ensures (\result == true)  ==>  (daikon.Quant.memberOf(\old(obj) , \old(this.elementData) ));
    @ ensures (\result == true)  ==>  (\old(this.elementCount) >= 1);
    @ ensures (\result == true)  ==>  (this.elementCount <= daikon.Quant.size(this.elementData)-1);
    @ ensures (\result == true)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount)-1)));
    @ ensures (\result == true)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData)), daikon.Quant.getElement_Object(this.elementData, this.elementCount)));
    @ ensures (\result == true)  ==>  (daikon.Quant.getElement_Object(this.elementData, this.elementCount) == daikon.Quant.getElement_Object(this.elementData, \old(this.elementCount)-1));
    @ ensures this.elementData.getClass().getName() != \old(obj.getClass().getName());
    @ ensures (!(\old(this.elementCount) == 0)) || (this.elementCount == 0);
    @ ensures this.elementCount <= \old(this.elementCount);
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(this.elementCount) == 0);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData);
    @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.elementData, 0, this.elementCount-1), \old(daikon.Quant.slice(this.elementData, 0, this.elementCount-1)));
    @*/
    /**
     * Removes the first occurrence of the argument from this vector. If 
     * the object is found in this vector, each component in the vector 
     * with an index greater or equal to the object's index is shifted 
     * downward to have an index one smaller than the value it had previously.
     *
     * @param   obj   the component to be removed.
     * @return  <code>true</code> if the argument was a component of this
     *          vector; <code>false</code> otherwise.
     * @since   JDK1.0
     */
    public final synchronized boolean removeElement(Object obj) {
	int i = indexOf(obj);
	if (i >= 0) {
	    removeElementAt(i);
	    return true;
	}
	return false;
    }

    /*@
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures daikon.Quant.size(this.elementData) == \old(daikon.Quant.size(this.elementData));
    @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.elementData, \old(this.elementCount), daikon.Quant.size(this.elementData)), \old(daikon.Quant.slice(this.elementData, this.elementCount, daikon.Quant.size(this.elementData))));
    @ ensures daikon.Quant.eltsEqual(this.elementData, null);
    @ ensures this.elementCount == 0;
    @ ensures this.elementCount <= this.capacityIncrement;
    @ ensures this.elementCount <= \old(this.elementCount);
    @ ensures javautil.Vector13.serialVersionUID < \old(this.elementCount);
    @ ensures (!(daikon.Quant.size(this.elementData) == 0)) || (\old(this.elementCount) == 0);
    @ ensures \old(this.elementCount) <= daikon.Quant.size(this.elementData);
    @ ensures this.elementCount == (this.capacityIncrement / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (\old(this.elementCount) / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (daikon.Quant.size(this.elementData) / javautil.Vector13.serialVersionUID);
    @ ensures this.elementCount == (daikon.Quant.size(this.elementData)-1 / javautil.Vector13.serialVersionUID);
    @*/
    /**
     * Removes all components from this vector and sets its size to zero.
     *
     * @since   JDK1.0
     */
    public final synchronized void removeAllElements() {
	for (int i = 0; i < elementCount; i++) {
	    elementData[i] = null;
	}
	elementCount = 0;
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result != null;
    @ ensures \result.getClass().getName() == javautil.Vector13.class.getName();
    @ ensures this.elementData.getClass().getName() != \result.getClass().getName();
    @*/
    /**
     * Returns a clone of this vector.
     *
     * @return  a clone of this vector.
     * @since   JDK1.0
     */
    public synchronized Object clone() {
	try { 
	    Vector13 v = (Vector13)super.clone();
	    v.elementData = new Object[elementCount];
	    System.arraycopy(elementData, 0, v.elementData, 0, elementCount);
	    return v;
	} catch (CloneNotSupportedException e) { 
	    // this shouldn't happen, since we are Cloneable
	    throw new InternalError();
	}
    }

    /*@
    @ also
    @ public normal_behavior // Generated by Daikon
    @ ensures this.elementData == \old(this.elementData);
    @ ensures this.elementData.getClass().getName() == \old(this.elementData.getClass().getName());
    @ ensures daikon.Quant.pairwiseEqual(this.elementData, \old(this.elementData));
    @ ensures this.elementCount == \old(this.elementCount);
    @ ensures this.capacityIncrement == \old(this.capacityIncrement);
    @ ensures \result != null;
    @*/
    /**
     * Returns a string representation of this vector. 
     *
     * @return  a string representation of this vector.
     * @since   JDK1.0
     */
    public final synchronized String toString() {
	int max = size() - 1;
	StringBuffer buf = new StringBuffer();
	Enumeration e = elements();
	buf.append("[");

	for (int i = 0 ; i <= max ; i++) {
	    buf.append(String.valueOf(e.nextElement()));
	    if (i < max) {
		buf.append(", ");
	    }
	}
	buf.append("]");
	return buf.toString();
    }
}
