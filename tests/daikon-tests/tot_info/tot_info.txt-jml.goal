===========================================================================
..InfoTbl():::ENTER
    Variables: ::line ::f ::f[] ::r ::c r c f f[] pdf pdf[] size(::f[]) size(::f[])-1 size(f[]) size(f[])-1 size(pdf[]) size(pdf[])-1
::f == f
daikon.Quant.pairwiseEqual(::f, f)
::r == r
::c == c
::f != null
daikon.Quant.eltsGTE(::f, 0)
f != null
f != null
pdf != null
pdf != null
(pdf != null)  ==>  (daikon.Quant.eltsGTE(pdf, 2))
(pdf != null)  ==>  (daikon.Quant.eltsGtIndex(pdf))
daikon.Quant.size(::f) == 1000
(pdf != null)  ==>  (daikon.Quant.size(pdf) == 1)
(pdf != null)  ==>  (daikon.Quant.eltsGTE(::f, daikon.Quant.size(pdf)-1))
(pdf != null)  ==>  (daikon.Quant.memberOf(daikon.Quant.size(pdf)-1 , ::f ))
::r < daikon.Quant.size(::f)-1
(pdf != null)  ==>  (::r >= daikon.Quant.size(pdf)-1)
::c < daikon.Quant.size(::f)-1
(pdf != null)  ==>  (::c != daikon.Quant.size(pdf))
(pdf != null)  ==>  (::c >= daikon.Quant.size(pdf)-1)
(pdf != null)  ==>  (daikon.Quant.eltsLT(pdf, daikon.Quant.size(::f)-1))
(pdf != null)  ==>  (daikon.Quant.eltsGT(pdf, daikon.Quant.size(pdf)))
===========================================================================
..InfoTbl():::EXIT
    Variables: ::line ::f ::f[] ::r ::c r c f f[] pdf pdf[] return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(r) orig(c) orig(f) orig(f[]) orig(pdf) orig(pdf[]) size(::f[]) size(::f[])-1 size(f[]) size(f[])-1 size(pdf[]) size(pdf[])-1 orig(size(::f[])) orig(size(::f[]))-1 orig(size(f[])) orig(size(f[]))-1 orig(size(pdf[])) orig(size(pdf[]))-1
assignable pdf[*]
::line.equals(\old(::line))
::f == \old(::f)
::f == \old(f)
daikon.Quant.pairwiseEqual(::f, f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
daikon.Quant.pairwiseEqual(::f, \old(f))
::r == \old(::r)
::r == \old(r)
::c == \old(::c)
::c == \old(c)
::f != null
daikon.Quant.eltsGTE(::f, 0)
daikon.Quant.eltsGTE(pdf, 2)
daikon.Quant.eltsGtIndex(pdf)
daikon.Quant.size(::f) == 1000
daikon.Quant.eltsGTE(::f, daikon.Quant.size(pdf)-1)
daikon.Quant.memberOf(daikon.Quant.size(pdf)-1 , ::f )
(\old(pdf) != null)  ==>  (daikon.Quant.eltsGTE(::f, \old(daikon.Quant.size(pdf))-1))
(\old(pdf) != null)  ==>  (daikon.Quant.memberOf(\old(daikon.Quant.size(pdf))-1 , ::f ))
::r < daikon.Quant.size(::f)-1
::r >= daikon.Quant.size(pdf)-1
(\old(pdf) != null)  ==>  (::r >= \old(daikon.Quant.size(pdf))-1)
::c < daikon.Quant.size(::f)-1
::c >= daikon.Quant.size(pdf)-1
(\old(pdf) != null)  ==>  (::c != \old(daikon.Quant.size(pdf)))
(\old(pdf) != null)  ==>  (::c >= \old(daikon.Quant.size(pdf))-1)
daikon.Quant.eltsLT(pdf, daikon.Quant.size(::f)-1)
(\old(pdf) != null)  ==>  (daikon.Quant.eltsGT(pdf, \old(daikon.Quant.size(pdf))))
(\old(pdf) != null)  ==>  (daikon.Quant.eltsLT(\old(pdf), daikon.Quant.size(::f)-1))
===========================================================================
..LGamma():::ENTER
    Variables: ::cof ::cof[] ::line ::f ::f[] ::r ::c x size(::cof[]) size(::cof[])-1 size(::f[]) size(::f[])-1
::cof != null
daikon.Quant.pairwiseEqual(::cof, new double[] { 76.18009173, -86.50532032999999, 24.014098219999997, -1.231739516, 0.00120858003, -5.363819999999999E-6 })
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
x >= 1.0
daikon.Quant.size(::cof) == 6
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
(::r >> daikon.Quant.size(::cof) == 0)
::r != daikon.Quant.size(::cof)
(::r >> daikon.Quant.size(::cof)-1 == 0)
::r < daikon.Quant.size(::f)-1
(::c >> daikon.Quant.size(::cof) == 0)
(::c >> daikon.Quant.size(::cof)-1 == 0)
::c < daikon.Quant.size(::f)-1
===========================================================================
..LGamma():::EXIT
    Variables: ::cof ::cof[] ::line ::f ::f[] ::r ::c x return orig(::cof) orig(::cof[]) orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(x) size(::cof[]) size(::cof[])-1 size(::f[]) size(::f[])-1 orig(size(::cof[])) orig(size(::cof[]))-1 orig(size(::f[])) orig(size(::f[]))-1
::cof == \old(::cof)
daikon.Quant.pairwiseEqual(::cof, \old(::cof))
::line.equals(\old(::line))
::f == \old(::f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
::r == \old(::r)
::c == \old(::c)
::cof != null
daikon.Quant.pairwiseEqual(::cof, new double[] { 76.18009173, -86.50532032999999, 24.014098219999997, -1.231739516, 0.00120858003, -5.363819999999999E-6 })
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
daikon.Quant.size(::cof) == 6
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
(::r >> daikon.Quant.size(::cof) == 0)
::r != daikon.Quant.size(::cof)
(::r >> daikon.Quant.size(::cof)-1 == 0)
::r < daikon.Quant.size(::f)-1
(::c >> daikon.Quant.size(::cof) == 0)
(::c >> daikon.Quant.size(::cof)-1 == 0)
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.ne(return, \old(x))
===========================================================================
..QChiSq():::ENTER
    Variables: ::line ::f ::f[] ::r ::c chisq df size(::f[]) size(::f[])-1
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
chisq >= 0.0
df >= 2
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
df < daikon.Quant.size(::f)-1
===========================================================================
..QChiSq():::EXIT
    Variables: ::line ::f ::f[] ::r ::c chisq df return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(chisq) orig(df) size(::f[]) size(::f[])-1 orig(size(::f[])) orig(size(::f[]))-1
::line.equals(\old(::line))
::f == \old(::f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
::r == \old(::r)
::c == \old(::c)
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.ne(return, \old(chisq))
\old(df) < daikon.Quant.size(::f)-1
===========================================================================
..QGamma():::ENTER
    Variables: ::line ::f ::f[] ::r ::c a x size(::f[]) size(::f[])-1
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
a >= 1.0
x >= 0.0
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.ne(a, x)
===========================================================================
..QGamma():::EXIT
    Variables: ::line ::f ::f[] ::r ::c a x return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(a) orig(x) size(::f[]) size(::f[])-1 orig(size(::f[])) orig(size(::f[]))-1
::line.equals(\old(::line))
::f == \old(::f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
::r == \old(::r)
::c == \old(::c)
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.lte(return, \old(a))
daikon.Quant.fuzzy.ne(return, \old(x))
===========================================================================
..main():::ENTER
    Variables: ::line ::f ::f[] ::r ::c argc argv argv[] size(::f[]) size(::f[])-1 size(argv[]) size(argv[])-1
::r == ::c
::r == daikon.Quant.size(argv)-1
argc == daikon.Quant.size(argv)
::line.equals("")
::f != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsEqual(::f, 0)
argc == 1
argv != null
daikon.Quant.pairwiseEqual(argv, new String[] { "./tot_info" })
daikon.Quant.eltsEqual(argv, "./tot_info")
daikon.Quant.size(::f) == 1000
daikon.Quant.eltsEqual(::f, ::r)
daikon.Quant.memberOf(::r , ::f )
===========================================================================
..main():::EXIT
    Variables: ::line ::f ::f[] ::r ::c argc argv argv[] return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(argc) orig(argv) orig(argv[]) size(::f[]) size(::f[])-1 size(argv[]) size(argv[])-1 orig(size(::f[])) orig(size(::f[]))-1 orig(size(argv[])) orig(size(argv[]))-1
assignable ::line, ::f[*], ::r, ::c
::f == \old(::f)
::r == ::c
return == \old(argc)
return == \old(daikon.Quant.size(argv))
\old(::r) == daikon.Quant.size(argv)-1
daikon.Quant.size(::f) == \old(daikon.Quant.size(::f))
::line.equals("44 44\n")
::f != null
("oneOf.java.jpp: SEQUENCE unimplemented" != null)
daikon.Quant.eltsGTE(::f, 0)
::r == 44
daikon.Quant.pairwiseEqual(argv, new String[] { "./tot_info" })
daikon.Quant.eltsEqual(argv, "./tot_info")
return == 1
daikon.Quant.size(::f) == 1000
::line.contains(\old(::line))
daikon.Quant.memberOf(::r , ::f )
daikon.Quant.memberOf(return , ::f )
daikon.Quant.subsetOf(\old(::f), ::f)
daikon.Quant.memberOf(\old(::r) , ::f )
===========================================================================
tot_info.c.gcf():::ENTER
    Variables: ::line ::f ::f[] ::r ::c a x size(::f[]) size(::f[])-1
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
a >= 1.0
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.lt(a, x)
===========================================================================
tot_info.c.gcf():::EXIT
    Variables: ::line ::f ::f[] ::r ::c a x return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(a) orig(x) size(::f[]) size(::f[])-1 orig(size(::f[])) orig(size(::f[]))-1
::line.equals(\old(::line))
::f == \old(::f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
::r == \old(::r)
::c == \old(::c)
::f != null
daikon.Quant.eltsGTE(::f, 0)
::r >= 2
daikon.Quant.size(::f) == 1000
(::r >> ::c == 0)
::r < daikon.Quant.size(::f)-1
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.lt(return, \old(a))
daikon.Quant.fuzzy.lt(return, \old(x))
===========================================================================
tot_info.c.gser():::ENTER
    Variables: ::line ::f ::f[] ::r ::c a x size(::f[]) size(::f[])-1
::f != null
daikon.Quant.eltsGTE(::f, 0)
a >= 1.0
x >= 0.0
daikon.Quant.size(::f) == 1000
daikon.Quant.memberOf(::r , ::f )
daikon.Quant.memberOf(::c , ::f )
(::c >> ::r == 0)
(::r >> ::c == 0)
(::r & daikon.Quant.size(::f)) == 0
::r < daikon.Quant.size(::f)-1
daikon.Quant.size(::f)-1 == (::r | daikon.Quant.size(::f)-1)
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.ne(a, x)
===========================================================================
tot_info.c.gser():::EXIT
    Variables: ::line ::f ::f[] ::r ::c a x return orig(::line) orig(::f) orig(::f[]) orig(::r) orig(::c) orig(a) orig(x) size(::f[]) size(::f[])-1 orig(size(::f[])) orig(size(::f[]))-1
::line.equals(\old(::line))
::f == \old(::f)
daikon.Quant.pairwiseEqual(::f, \old(::f))
::r == \old(::r)
::c == \old(::c)
::f != null
daikon.Quant.eltsGTE(::f, 0)
daikon.Quant.size(::f) == 1000
daikon.Quant.memberOf(::r , ::f )
daikon.Quant.memberOf(::c , ::f )
(::c >> ::r == 0)
(::r >> ::c == 0)
(::r & daikon.Quant.size(::f)) == 0
::r < daikon.Quant.size(::f)-1
daikon.Quant.size(::f)-1 == (::r | daikon.Quant.size(::f)-1)
::c < daikon.Quant.size(::f)-1
daikon.Quant.fuzzy.lt(return, \old(a))
(!(\old(x) == 0)) || (return == 0)
(!(return == 0)) || (\old(x) == 0)
daikon.Quant.fuzzy.lte(return, \old(x))
