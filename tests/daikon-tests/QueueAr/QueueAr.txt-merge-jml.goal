// [[ This is an edited version compared to the DSAA book.  Jeremy has
// removed the no-arg constructor, inlined the increment method, and
// updated the makeEmpty method. ]]

package DataStructures;

// QueueAr class
//

// ******************PUBLIC OPERATIONS*********************
// void enqueue( x )      --> Insert x
// Object getFront( )     --> Return least recently inserted item
// Object dequeue( )      --> Return and remove least recent item
// boolean isEmpty( )     --> Return true if empty; else false
// boolean isFull( )      --> Return true if capacity reached
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Overflow thrown for enqueue on full queue

/**
 * Array-based implementation of the queue.
 * @author Mark Allen Weiss
 */
public class QueueAr
{

  /*@ invariant this.theArray != null; */
  /*@ invariant this.theArray.getClass().getName() == java.lang.Object[].class.getName(); */
  /*@ invariant this.currentSize >= 0; */
  /*@ invariant this.front >= 0; */
  /*@ invariant this.back >= 0; */
  /*@ invariant this.currentSize <= daikon.Quant.size(this.theArray); */
  /*@ invariant (!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.front == 0); */
  /*@ invariant this.front <= daikon.Quant.size(this.theArray)-1; */
  /*@ invariant (!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.back == 0); */
  /*@ invariant this.back <= daikon.Quant.size(this.theArray)-1; */
  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.currentSize == this.front;
  @ ensures this.back == daikon.Quant.size(this.theArray)-1;
  @ ensures \old(capacity) == daikon.Quant.size(this.theArray);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, this.back);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(capacity)-1);
  @ ensures daikon.Quant.eltsEqual(this.theArray, null);
  @ ensures this.currentSize == 0;
  @ ensures daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.currentSize));
  @ ensures this.currentSize <= this.back;
  @*/
  /**
   * Construct the queue.
   */
  public QueueAr( int capacity )
  {
    theArray = new Object[ capacity ];
    currentSize = 0;
    front = 0;
    back = theArray.length-1;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
  @ ensures this.currentSize == \old(this.currentSize);
  @ ensures this.front == \old(this.front);
  @ ensures this.back == \old(this.back);
  @ ensures (this.currentSize == 0)  <==>  (\result == true);
  @ ensures (this.currentSize == 0)  ==>  ((!(this.back == 0)) || (daikon.Quant.size(this.theArray)-1 == 0));
  @ ensures (this.currentSize == 0)  ==>  ((!(this.back == 0)) || (this.front == 0));
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= daikon.Quant.size(this.theArray)-1);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= this.back);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= this.front);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize is a pointer);
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, null));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, \old(daikon.Quant.getElement_Object(this.theArray, this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.back)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.front)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), null));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), \old(daikon.Quant.getElement_Object(this.theArray, this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.back)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.front)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, this.back));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, this.front));
  @*/
  /**
   * Test if the queue is logically empty.
   * @return true if empty, false otherwise.
   */
  public boolean isEmpty( )
  {
    return currentSize == 0;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
  @ ensures this.currentSize == \old(this.currentSize);
  @ ensures this.front == \old(this.front);
  @ ensures this.back == \old(this.back);
  @ ensures (\result == false)  <==>  (this.currentSize <= daikon.Quant.size(this.theArray)-1);
  @ ensures (\result == false)  ==>  ((!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.currentSize == 0));
  @ ensures (\result == true)  <==>  (this.currentSize == daikon.Quant.size(this.theArray));
  @ ensures (\result == true)  ==>  (daikon.Quant.noDups(daikon.Quant.slice(this.theArray, 0, this.currentSize-1)));
  @ ensures (\result == true)  ==>  (daikon.Quant.eltsNotEqual(daikon.Quant.slice(this.theArray, 0, this.currentSize-1), null));
  @ ensures (\result == true)  ==>  (daikon.Quant.noDups(this.theArray));
  @ ensures (\result == true)  ==>  (daikon.Quant.eltsNotEqual(this.theArray, null));
  @*/
  /**
   * Test if the queue is logically full.
   * @return true if full, false otherwise.
   */
  public boolean isFull( )
  {
    return currentSize == theArray.length;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires (!(this.currentSize == 0)) || (this.front == 0);
  @ requires (!(this.back == 0)) || (this.front == 0);
  @ requires (!(this.back == 0)) || (daikon.Quant.size(this.theArray)-1 == 0);
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures this.currentSize == this.front;
  @ ensures this.back == daikon.Quant.size(this.theArray)-1;
  @ ensures this.back == \old(daikon.Quant.size(this.theArray))-1;
  @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, this.back);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(this.front));
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(this.back));
  @ ensures daikon.Quant.eltsEqual(this.theArray, null);
  @ ensures this.currentSize == 0;
  @ ensures daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.currentSize));
  @ ensures this.currentSize <= this.back;
  @ ensures this.currentSize <= \old(this.currentSize);
  @ ensures this.currentSize <= \old(this.front);
  @ ensures this.currentSize <= \old(this.back);
  @ ensures (!(this.back == 0)) || (\old(this.front) == 0);
  @ ensures this.back >= \old(this.front);
  @ ensures (!(\old(this.back) == 0)) || (this.back == 0);
  @ ensures (!(this.back == 0)) || (\old(this.back) == 0);
  @ ensures this.back >= \old(this.back);
  @ ensures \old(this.currentSize) <= daikon.Quant.size(this.theArray);
  @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.theArray, 0, \old(this.front)-1), \old(daikon.Quant.slice(this.theArray, 0, this.currentSize-1)));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.theArray, 0, \old(this.front)-1), \old(daikon.Quant.slice(this.theArray, 0, this.front)));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.theArray, 0, \old(this.front)-1), \old(daikon.Quant.slice(this.theArray, 0, this.front-1)));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.theArray, \old(this.back)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.back, daikon.Quant.size(this.theArray))));
  @ ensures daikon.Quant.subsetOf(daikon.Quant.slice(this.theArray, \old(this.back)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.back+1, daikon.Quant.size(this.theArray))));
  @*/
  /**
   * Make the queue logically empty.
   */
  public void makeEmpty( )
  {
    currentSize = 0;
    front = 0;
    back = theArray.length-1;
    java.util.Arrays.fill(theArray, 0, theArray.length, null);
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures daikon.Quant.pairwiseEqual(this.theArray, \old(this.theArray));
  @ ensures this.currentSize == \old(this.currentSize);
  @ ensures this.front == \old(this.front);
  @ ensures this.back == \old(this.back);
  @ ensures \result == daikon.Quant.getElement_Object(this.theArray, this.front);
  @ ensures \result == daikon.Quant.getElement_Object(this.theArray, \old(this.front));
  @ ensures \result == \old(daikon.Quant.getElement_Object(this.theArray, this.front));
  @ ensures (this.currentSize == 0)  <==>  (\result == null);
  @ ensures (this.currentSize == 0)  <==>  (daikon.Quant.getElement_Object(this.theArray, this.back) == null);
  @ ensures (this.currentSize == 0)  ==>  ((!(this.back == 0)) || (daikon.Quant.size(this.theArray)-1 == 0));
  @ ensures (this.currentSize == 0)  ==>  ((!(this.back == 0)) || (this.front == 0));
  @ ensures (this.currentSize == 0)  ==>  (\old(daikon.Quant.getElement_Object(this.theArray, this.currentSize)) == null);
  @ ensures (this.currentSize == 0)  ==>  (\result == \old(daikon.Quant.getElement_Object(this.theArray, this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, this.back));
  @ ensures (this.currentSize == 0)  ==>  (\result == daikon.Quant.getElement_Object(this.theArray, this.currentSize));
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= daikon.Quant.size(this.theArray)-1);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= this.back);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize <= this.front);
  @ ensures (this.currentSize == 0)  ==>  (this.currentSize is a pointer);
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, null));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, \old(daikon.Quant.getElement_Object(this.theArray, this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, \result));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.back)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize)) == null);
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), null));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), \old(daikon.Quant.getElement_Object(this.theArray, this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), \result));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize))));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.back)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.currentSize, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.currentSize)));
  @ ensures (this.currentSize == 0)  ==>  (daikon.Quant.getElement_Object(this.theArray, this.currentSize) == null);
  @ ensures this.theArray.getClass().getName() != \result.getClass().getName();
  @*/
  /**
   * Get the least recently inserted item in the queue.
   * Does not alter the queue.
   * @return the least recently inserted item in the queue, or null, if empty.
   */
  public Object getFront( )
  {
    if( isEmpty( ) )
      return null;
    return theArray[ front ];
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires daikon.Quant.getElement_Object(this.theArray, this.front) != null;
  @ requires daikon.Quant.getElement_Object(this.theArray, this.back) != null;
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures this.back == \old(this.back);
  @ ensures \result == \old(daikon.Quant.getElement_Object(this.theArray, this.front));
  @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize)-1);
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, \old(this.front)+1, daikon.Quant.size(this.theArray)), \old(daikon.Quant.slice(this.theArray, this.front+1, daikon.Quant.size(this.theArray))));
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.slice(this.theArray, 0, \old(this.front)-1), \old(daikon.Quant.slice(this.theArray, 0, this.front-1)));
  @ ensures \result != null;
  @ ensures daikon.Quant.getElement_Object(this.theArray, \old(this.front)) == null;
  @ ensures this.theArray.getClass().getName() != \result.getClass().getName();
  @ ensures this.currentSize - \old(this.currentSize) + 1 == 0;
  @ ensures (!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.currentSize == 0);
  @ ensures this.currentSize <= daikon.Quant.size(this.theArray)-1;
  @ ensures \old(this.currentSize) <= daikon.Quant.size(this.theArray);
  @ ensures (!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.front) == 0);
  @ ensures \old(this.front) <= daikon.Quant.size(this.theArray)-1;
  @*/
  /**
   * Return and remove the least recently inserted item from the queue.
   * @return the least recently inserted item in the queue, or null, if empty.
   */
  public Object dequeue( )
  {
    if( isEmpty( ) )
      return null;
    currentSize--;

    Object frontItem = theArray[ front ];
    theArray[ front ] = null;
    if ( ++front == theArray.length )
      front = 0;
    return frontItem;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires x != null;
  @ requires this.theArray.getClass().getName() != x.getClass().getName();
  @ requires (!(this.currentSize == 0)) || (this.front == 0);
  @ requires (!(daikon.Quant.size(this.theArray)-1 == 0)) || (this.currentSize == 0);
  @ requires this.currentSize <= daikon.Quant.size(this.theArray)-1;
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures this.front == \old(this.front);
  @ ensures \old(x) == daikon.Quant.getElement_Object(this.theArray, this.back);
  @ ensures daikon.Quant.size(this.theArray) == \old(daikon.Quant.size(this.theArray));
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize-1) == daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize));
  @ ensures this.currentSize >= 1;
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.front) != null;
  @ ensures this.theArray.getClass().getName() != \old(x.getClass().getName());
  @ ensures this.currentSize - \old(this.currentSize) - 1 == 0;
  @ ensures (!(\old(this.currentSize) == 0)) || (this.front == 0);
  @ ensures (!(\old(this.currentSize) == 0)) || (this.back == 0);
  @ ensures (!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.currentSize) == 0);
  @ ensures \old(this.currentSize) <= daikon.Quant.size(this.theArray)-1;
  @ ensures (!(daikon.Quant.size(this.theArray)-1 == 0)) || (\old(this.back) == 0);
  @ ensures \old(this.back) <= daikon.Quant.size(this.theArray)-1;
  @*/
  /**
   * Insert a new item into the queue.
   * @param x the item to insert.
   * @exception Overflow if queue is full.
   */
  public void enqueue( Object x ) throws Overflow
  {
    if( isFull( ) )
      throw new Overflow( );
    if ( ++back == theArray.length )
      back = 0;
    theArray[ back ] = x;
    currentSize++;
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires this.currentSize == daikon.Quant.size(this.theArray);
  @ requires this.back == daikon.Quant.size(this.theArray)-1;
  @ requires daikon.Quant.getElement_Object(this.theArray, this.currentSize-1) == daikon.Quant.getElement_Object(this.theArray, this.back);
  @ requires this.front == 0;
  @ requires daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, 0, this.front), daikon.Quant.getElement_Object(this.theArray, this.front));
  @ requires daikon.Quant.eltsEqual(daikon.Quant.slice(this.theArray, this.back, daikon.Quant.size(this.theArray)), daikon.Quant.getElement_Object(this.theArray, this.back));
  @ ensures this.theArray == \old(this.theArray);
  @ ensures this.theArray.getClass().getName() == \old(this.theArray.getClass().getName());
  @ ensures this.currentSize == this.front;
  @ ensures this.currentSize == \old(this.front);
  @ ensures this.back == \old(this.back);
  @ ensures this.back == daikon.Quant.size(this.theArray)-1;
  @ ensures this.back == \old(daikon.Quant.size(this.theArray))-1;
  @ ensures \old(this.currentSize) == daikon.Quant.size(this.theArray);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, this.back);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(this.currentSize)-1);
  @ ensures daikon.Quant.getElement_Object(this.theArray, this.currentSize) == daikon.Quant.getElement_Object(this.theArray, \old(this.back));
  @ ensures daikon.Quant.eltsEqual(this.theArray, null);
  @ ensures this.currentSize == 0;
  @ ensures daikon.Quant.eltsEqual(this.theArray, daikon.Quant.getElement_Object(this.theArray, this.currentSize));
  @*/
  public void dequeueAll()
  {
    while( !isEmpty() ) {
      dequeue();
    }
  }

  /*@ spec_public */ private Object [ ] theArray;
  /*@ spec_public */ private int        currentSize;
  /*@ spec_public */ private int        front;
  /*@ spec_public */ private int        back;

}
