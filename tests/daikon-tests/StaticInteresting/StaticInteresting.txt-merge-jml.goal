package misc;
import java.util.*;

/**
 * For testing of static checks for whether something is interesting.
 * If behavior is incorrect, the following should be reported:
 * 
 * <p>
 * this.inner[this.x] in this.outer[]  
 *
 * <p>
 * Why is this code so complicated?  Because we want
 * this.inner[this.x] == this.outer[something] for the above invariant
 * to be true (it is true).  However, we order inner, outer, x and y
 * such that outer[this.y] comes first in the VarInfo index ordering.
 * Hence initially, this.outer[this.y] == this.inner[this.x] with
 * this.outer[this.y] being the leader.  Since Daikon thinks it's
 * obvious that this.outer[this.y] is in this.outer[] and it doesn't
 * look at the equality relationship to see if other variables may be
 * interesting, the invariant is never instantiated.  We make sure the
 * invariant *is* something that's interesting to the user by breaking
 * the equality halfway.  So correct behavior should print the
 * invariant.
 *
 * <p> Requises Ajax to work properly, because otherwise the equality
 * leader initially is y, since it's even earlier in the VarInfo index
 * ordering.  In fact, this pathology was very hard to reproduce since
 * regular variables always come first and are never statically
 * unintersting.
 *
 * <p> Member is just one example of this.  Others include
 * subsequence.
 */

public class StaticInteresting {
  /*@ invariant this.x == daikon.Quant.size(this.inner)-1; */
  /*@ invariant this != null; */
  /*@ invariant this.outer != null; */
  /*@ invariant this.outer != null; */
  /*@ invariant daikon.Quant.noDups(this.outer); */
  /*@ invariant this.inner != null; */
  /*@ invariant this.inner != null; */
  /*@ invariant this.y == 25; */
  /*@ invariant daikon.Quant.size(this.outer) == 100; */
  /*@ invariant daikon.Quant.size(this.inner) == 1; */
  /*@ invariant daikon.Quant.getElement_int(this.outer, this.y) != 0; */
  /*@ invariant daikon.Quant.getElement_int(this.outer, this.y-1) != 0; */
  /*@ invariant daikon.Quant.getElement_int(this.inner, this.x) != 0; */
  /*@ invariant daikon.Quant.memberOf(daikon.Quant.getElement_int(this.inner, this.x) , this.outer ); */
  /*@ invariant daikon.Quant.eltsEqual(this.inner, daikon.Quant.getElement_int(this.inner, this.x)); */
  /*@ invariant this.y != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant this.y != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant this.y != daikon.Quant.getElement_int(this.inner, this.x); */
  /*@ invariant daikon.Quant.size(this.outer) != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant daikon.Quant.size(this.outer) != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant daikon.Quant.size(this.outer) != daikon.Quant.getElement_int(this.inner, this.x); */
  /*@ invariant daikon.Quant.size(this.outer)-1 != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant daikon.Quant.size(this.outer)-1 != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant daikon.Quant.size(this.outer)-1 != daikon.Quant.getElement_int(this.inner, this.x); */
  /*@ invariant daikon.Quant.getElement_int(this.outer, this.y) != daikon.Quant.getElement_int(this.outer, this.y-1); */
  public int[] outer = new int[100];
  public int[] inner = new int[1];
  public int y = 25;
  public int x = 0;
  public static final Random rand = new Random(10);

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires args != null;
  @ requires args.getClass().getName() == java.lang.String[].class.getName();
  @ requires daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  });
  @ ensures misc.StaticInteresting.rand == \old(misc.StaticInteresting.rand);
  @ ensures daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  });
  @*/
  public static void main(String[] args)
  {
    // s.outer[s.y] is in s.outer[] (obviously)
    StaticInteresting s = new StaticInteresting();
    for (int i = 0; i < 100; i++) {
      s.inner[s.x] = s.outer[s.y];
      // so s.inner[s.x] is in s.outer[] too (not obvious)
      s.work ();
    }
    // Now break the equality
    for (int i = 0; i < 100; i++) {
      s.inner[s.x] = s.outer[s.y - 1];
      
      // Still true that s.inner[s.x] is in s.outer[]
      s.work ();
    }

    StaticInteresting2.main(null);
  }


  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.outer == \old(this.outer);
  @ ensures this.inner == \old(this.inner);
  @ ensures this.y == \old(this.y);
  @ ensures this.x == \old(this.x);
  @ ensures this.x == \old(daikon.Quant.size(this.inner))-1;
  @ ensures misc.StaticInteresting.rand == \old(misc.StaticInteresting.rand);
  @ ensures daikon.Quant.size(this.outer) == \old(daikon.Quant.size(this.outer));
  @ ensures daikon.Quant.size(this.inner) == \old(daikon.Quant.size(this.inner));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.outer, \old(this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.inner, this.x);
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.inner, \old(this.x));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) == daikon.Quant.getElement_int(this.outer, \old(this.y)-1);
  @ ensures daikon.Quant.eltsEqual(this.inner, daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures this.y != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures this.y != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures this.y != \old(daikon.Quant.getElement_int(this.inner, this.x));
  @ ensures daikon.Quant.size(this.outer) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.size(this.outer) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.size(this.outer) != \old(daikon.Quant.getElement_int(this.inner, this.x));
  @ ensures daikon.Quant.size(this.outer)-1 != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.size(this.outer)-1 != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.size(this.outer)-1 != \old(daikon.Quant.getElement_int(this.inner, this.x));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) != \old(daikon.Quant.getElement_int(this.inner, this.x));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) != \old(daikon.Quant.getElement_int(this.inner, this.x));
  @*/
  /**
   *
   */
  public  void work() {
    for (int i = 0; i < outer.length; i++) {
      outer[i] = rand.nextInt();
    }
    inner[x] = outer[y];
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.inner, this.x);
  @ ensures daikon.Quant.eltsEqual(this.inner, -1339421172);
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == -1339421172;
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) == 134578847;
  @ ensures daikon.Quant.eltsEqual(this.inner, daikon.Quant.getElement_int(this.outer, this.y));
  @*/
  public StaticInteresting() {
    for (int i = 0; i < outer.length; i++) {
      outer[i] = i*i + rand.nextInt();
    }
    inner[x] = outer[y];    
  }
}

/**
 * Alternative version, where the key invariant
 * <p>
 *  this.inner[this.x] in this.outer[]
 * <p>
 * should not be reported because this.inner[this.x] == this.outer[this.y]
 */
class StaticInteresting2 {
  /*@ invariant this.x == daikon.Quant.size(this.inner)-1; */
  /*@ invariant daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.inner, this.x); */
  /*@ invariant this != null; */
  /*@ invariant this.outer != null; */
  /*@ invariant this.outer != null; */
  /*@ invariant daikon.Quant.noDups(this.outer); */
  /*@ invariant this.inner != null; */
  /*@ invariant this.inner != null; */
  /*@ invariant this.y == 25; */
  /*@ invariant daikon.Quant.size(this.outer) == 100; */
  /*@ invariant daikon.Quant.size(this.inner) == 1; */
  /*@ invariant daikon.Quant.eltsEqual(this.inner, daikon.Quant.getElement_int(this.outer, this.y)); */
  /*@ invariant this.y != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant this.y != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant daikon.Quant.size(this.outer) != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant daikon.Quant.size(this.outer) != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant daikon.Quant.size(this.outer)-1 != daikon.Quant.getElement_int(this.outer, this.y); */
  /*@ invariant daikon.Quant.size(this.outer)-1 != daikon.Quant.getElement_int(this.outer, this.y-1); */
  /*@ invariant daikon.Quant.getElement_int(this.outer, this.y) != daikon.Quant.getElement_int(this.outer, this.y-1); */
  public int[] outer = new int[100];
  public int[] inner = new int[1];
  public int y = 25;
  public int x = 0;
  public static final Random rand = new Random(10);

  /*@
  @ public normal_behavior // Generated by Daikon
  @ requires args == null;
  @ ensures misc.StaticInteresting2.rand == \old(misc.StaticInteresting2.rand);
  @*/
  public static void main(String[] args)
  {
    // s.outer[s.y] is in s.outer[] (obviously)
    StaticInteresting2 s = new StaticInteresting2();
    for (int i = 0; i < 100; i++) {
      s.inner[s.x] = s.outer[s.y];
      // so s.inner[s.x] is in s.outer[] too (not obvious)
      s.work ();
    }
  }


  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures this.outer == \old(this.outer);
  @ ensures this.inner == \old(this.inner);
  @ ensures this.y == \old(this.y);
  @ ensures this.x == \old(this.x);
  @ ensures this.x == \old(daikon.Quant.size(this.inner))-1;
  @ ensures misc.StaticInteresting2.rand == \old(misc.StaticInteresting2.rand);
  @ ensures daikon.Quant.size(this.outer) == \old(daikon.Quant.size(this.outer));
  @ ensures daikon.Quant.size(this.inner) == \old(daikon.Quant.size(this.inner));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.outer, \old(this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == daikon.Quant.getElement_int(this.inner, \old(this.x));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) == daikon.Quant.getElement_int(this.outer, \old(this.y)-1);
  @ ensures this.y != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures this.y != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.size(this.outer) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.size(this.outer) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.size(this.outer)-1 != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.size(this.outer)-1 != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) != \old(daikon.Quant.getElement_int(this.outer, this.y));
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) != \old(daikon.Quant.getElement_int(this.outer, this.y-1));
  @*/
  /**
   *
   */
  public  void work() {
    for (int i = 0; i < outer.length; i++) {
      outer[i] = rand.nextInt();
    }
    inner[x] = outer[y];
  }

  /*@
  @ public normal_behavior // Generated by Daikon
  @ ensures daikon.Quant.eltsEqual(this.inner, -1339421172);
  @ ensures daikon.Quant.getElement_int(this.outer, this.y) == -1339421172;
  @ ensures daikon.Quant.getElement_int(this.outer, this.y-1) == 134578847;
  @*/
  public StaticInteresting2() {
    for (int i = 0; i < outer.length; i++) {
      outer[i] = i*i + rand.nextInt();
    }
    inner[x] = outer[y];    
  }
}

