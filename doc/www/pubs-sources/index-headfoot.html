<!DOCTYPE html>
<html lang="en">
<head><link rel="icon" href="../daikon-favicon.png" type="image/png"/>
  <title>Invariant detection publications</title>
</head>
<body>

<p>
<img src="../daikon-logo.gif" alt="Daikon logo" />
</p>

<p>
[ <a href="../">Home</a>
| <a href="../faq.html">FAQ</a>
| <a href="../download/">Download</a>
| <a href="../download/doc/">Documentation</a>
| <b>Publications</b>
| <a href="../mailing-lists.html">Mailing lists</a>
]
</p>

<hr />

<h1>Daikon-related invariant detection publications</h1>

<p>
This page lists publications related to the technique of invariant
detection and to the <a href="../">Daikon invariant
detector</a> tool that implements it.  The page is separated into four
parts:
</p>

<dl>
<dt>
<a href="#invariant-detection">Invariant detection technique</a>
</dt>
<dd>
This section describes the technique of invariant detection and the
implementation of the Daikon invariant detector.
</dd>

<dt>
<a href="#daikon-methodology">Methodology using invariant detection</a>
</dt>
<dd>
This section lists publications whose research methodology depends on
running the Daikon tool.  The research uses Daikon's invariant detection as
one step of its technique.  (Research that uses <a href="#other-tools">other
invariant detection tools</a> is not listed here.)
</dd>

<dt>
<a href="#daikon-testsubject">Daikon as test subject</a>
</dt>
<dd>
This section lists
publications that use the Daikon invariant detector as a test subject.  For
instance, Daikon has been used as a subject when evaluating regression
testing tools, since it has both a version control repository and a test
suite.
</dd>

<dt>
<a href="#other-tools">Other invariant detection tools</a>
</dt>
<dd>
This section briefly lists some other invariant detection tools (besides
Daikon).
</dd>

</dl>

<p>
The lists of papers and tools are undoubtedly incomplete.  If you know of
other work that should be listed here, or discover an error, please send
mail to <a href="mailto:mernst@cs.washington.edu">mernst@cs.washington.edu</a>.
Thanks.
</p>


<hr />

<h1><a name="invariant-detection">Invariant detection technique</a></h1>

BODY-INVARIANTDETECTION

<hr />

<h1><a name="daikon-methodology">Methodology using invariant detection</a></h1>

BODY-METHODOLOGYUSINGDAIKON

<hr />

<h1><a name="daikon-testsubject">Daikon as test subject</a></h1>

BODY-DAIKONTESTSUBJECT

<hr />

<h1><a name="other-tools">Other invariant detection tools</a></h1>

<p>
Other researchers and commercializers have adopted the idea of invariant
detection, extending the technique and building new tools.  This section
is a selected list of some of those
<a href="#other-tools-industrial">industrial</a> and <a href="#other-tools-academic">academic</a>
efforts.  This is a partial list; please let me know of any others that are
not industrial or academic secrets.
</p>


<h2><a name="other-tools-industrial">Industrial invariant detection implementations</a></h2>

<dl>
<dt>
Sun Microsystems
</dt>
<dd>
IODINE is an invariant detector for hardware designs, built by
<a href="http://xenon.stanford.edu/~hangal/">Sudheendra Hangal</a> (who is
also responsible for the DIDUCE invariant detector, described below) and
colleagues.  The goal is to execute test vectors or real loads on a
simulator in order to learn emergent properties of the design.  See the
paper
<a href="https://dl.acm.org/citation.cfm?id=1065579.1065786">"IODINE: A
tool to automatically infer dynamic invariants for hardware designs"</a> in
the Design Automation Conference, DAC 2005.
</dd>

<dt>
Microsoft
</dt>
<dd>
<a href="https://www.microsoft.com/en-us/research/people/trishulc/">Trishul Chilimbi</a> is
building a high-performance dynamic invariant detector that operates at
garbage collection (GC) time.  Since all of memory must be scanned then
anyway, the invariant detector imposes relatively little additional cost
for its memory accesses.  The invariant detector's grammar includes
run-time types (for checking what types a collection contains),
immutability, and cycles in the object reference graph (the heap).
</dd>

<dt>
Agitar
</dt>
<dd>
Agitar's product, Agitator, was
inspired by Daikon.  Agitar performs dynamic invariant detection in order
to inform users about tests, and to improve those tests.  The results are
called "observations", they include equality (x = y), range (-10 &lt;= x &lt;=
10), non-null (x != null), equality (.equals), and properties gleaned from
the user's source code.  Agitar won the Wall Street Journal's 2005
<a href="http://web.archive.org/web/20121229061259/http://www.dowjones.com/innovation/ei_winners_2005.html#software">Software
Technology Innovation Award</a>.  Regarding Agitar's work and its
connection to Daikon, see the ISSTA 2006 paper <a href="http://doi.acm.org/10.1145/1146238.1146258">``From Daikon to Agitator:
Lessons and Challenges in Building a Commercial Tool for Developer
Testing''</a>, by Marat Boshernitsan, Roongko Doong, and Alberto Savoia.
</dd>

<dt>
Microsoft
</dt>
<dd>
The Axiom Meister tool (built by <a href="https://www.microsoft.com/en-us/research/people/schulte/">Wolfram Schulte</a> and colleagues) infers
specifications from code by performing exhaustive symbolic execution
(similar to model checking).  The tool generalizes over the results of
user-specified observer methods.  The output can be used for test
generation and program verification.
</dd>

<!-- I have made no attempt to update this page since 2006 or ealier,
  except when people send mail mentioning a specific tool. -->

<dt>
Rebert Bosch RTC and University of Maryland
</dt>
<dd>
  The Magnum Opus tool generates invariants from Simulink models, then
  other tools generate test cases to expand the test suite.  See the paper
  <a
  href="https://link.springer.com/chapter/10.1007/978-3-642-16612-9_1">"Automatic
  Requirement Extraction from Test Cases"</a> (appears in RV 2010).
</dd>

</dl>

<h2><a name="other-tools-academic">Academic invariant detection implementations</a></h2>

<dl>

<dt>
Stanford
</dt>
<dd>
The <a href="https://diduce.sourceforge.net/">DIDUCE</a> tool (DIDUCE stands
for "Dynamic Invariant Detection Union Checking Engine") checks one
invariant:  the bitwise or of the values of a variable.  DIDUCE performs
dynamic invariant detection online -- while the target program is running.
DIDUCE is described in the paper
<a href="https://dl.acm.org/citation.cfm?id=581377">"Tracking down software
bugs using automatic anomaly detection"</a>, by
<a href="http://xenon.stanford.edu/~hangal/">Sudheendra Hangal</a> and
<a href="https://suif.stanford.edu/~lam/">Monica S. Lam</a> (appears in ICSE
2002).
</dd>

<dt>
Wisconsin and Microsoft
</dt>
<dd>
The paper <a href="https://dl.acm.org/doi/10.1145/565816.503275">"Mining
specifications"</a> by Glenn Ammons,
<a href="http://homes.cs.washington.edu/~bodik/">Rastislav Bod&iacute;k</a>, and
<a href="https://www.microsoft.com/en-us/research/people/larus/">James R. Larus</a> (appears
in POPL 2002) describes a system for inferring temporal specifications,
such as "method <code>open</code> must be called before method <code>close</code>".
The sequence of observed method calls is fed to a machine learner in order
to obtain a grammar of permitted call sequences.
</dd>

<dt>
Stanford
</dt>
<dd>
<!-- For Michael Martin, "http://www.stanford.edu/~mcmartin/" no longer works. -->
The paper <a href="https://dl.acm.org/citation.cfm?id=566171.566212">"Automatic extraction of object-oriented component interfaces"</a> by
<!--a href="https://www.linkedin.com/in/joewhaley"-->John Whaley<!--/a-->, Michael C. Martin, and
<a href="https://suif.stanford.edu/~lam/">Monica S Lam</a> (appears in ISSTA
2002) has the same goal as that of the "Mining specifications" paper:
determining the legal sequences of procedure calls (in the paper, called
"interfaces").  The paper proposes a combination of static and dynamic
methods.
</dd>

<dt>
Berkeley
</dt>
<dd>
<a href="https://pages.cs.wisc.edu/~liblit/">Ben Liblit</a>'s
statistical debugging project, described in a variety of
<a href="https://pages.cs.wisc.edu/~liblit/">publications</a>, aims to permit
collecting a small amount of information from a large number of executions
in the field (some faulty, some not) in order to determine which properties
of an execution are most relevant to errors.  Its mechanism for collecting
the information is a type of invariant detection.
</dd>

<dt>
Brown
</dt>
<dd>
The Carrot dynamic invariant detection system is described in the paper
"Automated fault localization using potential invariants", by Brock Pytlik,
<a href="https://www.linkedin.com/in/manos-renieris-99b5531">Manos Renieris</a>,
<a href="https://cs.brown.edu/~sk/">Shriram Krishnamurthi</a>, and
<a href="https://cs.brown.edu/~spr/">Steven P. Reiss</a> (appears in
AADEBUG 2003).  It is built partly upon the Daikon infrastructure, but
investigates other implementation strategies.
</dd>

<dt>
Colorado
</dt>
<dd>
Two papers by <a href="http://www.jhenkel.de/">Johannes Henkel</a> and
<a href="https://cs.brown.edu/~sk/">Amer Diwan</a> -- "Discovering
algebraic specifications from Java classes" (appears in ECOOP 2003) and
<a href="https://dl.acm.org/citation.cfm?id=998675.999449">"A tool for
writing and debugging algebraic specifications"</a> (appears in ICSE 2004)
-- describe an application of dynamic invariant detection to algebraic
specifications.  Algebraic specifications are equations between terms, such
as "pop(push(s,i).state).retval = i" and "pop(push(s,i).state).state = s".
</dd>

<dt>
Virginia and Microsoft
</dt>
<dd>
<a href="https://www.cs.virginia.edu/~evans/">David Evans</a> and <a href="https://www.linkedin.com/in/jinliny/">Jinlin Yang</a> are building
<a href="https://www.cs.virginia.edu/terracotta/">Terracotta</a>,
a dynamic analysis tool for automatically inferring temporal properties.
It takes the program's execution traces as input and outputs a set of
likely temporal properties.  It is reported in
<a href="https://www.computer.org/csdl/proceedings-article/2004/issre/22150340/12OmNwCJOUO">"Automatically
Inferring Temporal Properties for Program Evolution"</a> (appears in ISSRE 2004).  Jinlin Yang
applied the techniques to the Windows Kernel while at Microsoft.
</dd>

<dt>
SUNY at Stony Brook
</dt>
<dd>
"Type discovery" can be thought of as dynamic invariant detection for
ownership (locks held when a field is accessed).  It is a dynamic analysis
that observes run-time types and forms hypotheses based on those
observations.  Two papers describe the technique and the analyses that can
be built upon it:  "Type discovery for Parameterized Race-Free Java"
(appears at VMCAI 2005) and
<a href="https://dl.acm.org/citation.cfm?id=1065944.1065956">"Automated type-based analysis of data races and atomicity"</a>
(appears at PPOPP 2005).
</dd>

<dt>
Purdue
</dt>
<dd>
C-DIDUCE is a re-implementation, for C, of Stanford's DIDUCE tool (which
works on Java).  DIDUCE is described in the paper <a href="http://doi.acm.org/10.1145/1133981.1133992">"Artemis:  Practical
runtime monitoring  of applications for execution anomalies"</a>, by Long Fei
and Samuel P. Midkiff (appears in PLDI 2006).
</dd>

<!-- I have made no attempt to update this page since 2006 or ealier,
  except when people send mail mentioning a specific tool. -->

</dl>

<hr />

[ <a href="../">Home</a>
| <a href="../faq.html">FAQ</a>
| <a href="../download/">Download</a>
| <a href="../download/doc/">Documentation</a>
| <b>Publications</b>
| <a href="../mailing-lists.html">Mailing lists</a>
]


</body>
</html>

<!--  LocalWords:  FAQ INVARIANTDETECTION METHODOLOGYUSINGDAIKON Sudheendra GC
 -->
<!--  LocalWords:  DAIKONTESTSUBJECT Hangal DIDUCE Trishul Chilimbi Ammons Bod
 -->
<!--  LocalWords:  commercializers Microsystems Rastislav Larus Whaley ISSTA
 -->
<!--  LocalWords:  Liblit's Pytlik Manos Renieris Shriram Krishnamurthi Reiss
 -->
<!--  LocalWords:  Henkel Amer Diwan retval DAC Schulte Jinlin Terracotta ISSRE
 -->
<!--  LocalWords:  Agitar Liblit AADEBUG SUNY VMCAI atomicity PPOPP
 -->
