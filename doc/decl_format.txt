
                       Daikon declaration record format

Introduction

  Daikon declarations define the variables at each program point.  Each
  variable definition includes its comparability, declared type,
  representation type, and other information.  There are a number of
  problems with the current format.  Daikon derives information from the
  variable and program point names in a poorly defined ad-hoc manner.
  This proposal suggests an augmented format that more completely
  defines the information and allows for future expandability.

Current problems

  There are a number of deficiencies in the current format.  Most of these
  are simply the result of changing uses of the declaration information.
  For example, the program point hierarchy (originally not implemented in
  Daikon) is determined from the program  point names.  Some specific
  issues are:

    - The variable names must be in a java-like format so that they
      can be parsed by daikon.  This makes it awkward to support languages
      with different variable names.  It also creates a conflict between
      communicating information about the variable to Daikon and an
      appropriate variable name for output.

    - The java-like variable name format doesn't make it possible to
      distinguish between fields and packages

    - The hierarchy relationship is inferred from the program point and
      variable names.  This limits the names that can be used and leads
      to complex processing in Daikon.

    - The internal processing of variable names is complex.  The VarInfoName
      class duplicates much of the information in the derived variables
      of VarInfo.

    - Nested arrays are not supported.  This may not be a problem we want
      to solve right now and it is more of a problem with dtrace records
      than decl records, but we at least want to have a clean path for
      expansion in this area.

    - It is not possible to add new variables dynamically.  Again, this
      is probably not a problem we wish to solve now, but we want to make
      sure that solution is reasonably feasible.

Goals

  The goals for our solution are:

    - Program point and variable hierarchy that are controllable by the
      front end (as appropriate for its language)

    - The format should remain easily readable.  Declaration records are
      a relatively small part of the total file.  Optimizing them for
      size or parsing time should be unnecessary.

    - The format should have reasonable defaults so that it is relatively
      easy to produce by hand or with a program.

    - The format should be expandable in a straight-forward way.

Proposal

  The new format will contain the following information:

    - An external variable name whose syntax is appropriate for the
      front end language.  These variables will be used unparsed and
      unmodified by daikon as much as possible.  The only exception is
      that the front end will specify where array indices (if any) are
      placed within the name.

    - Information about a variable (such as the enclosing variable,
      whether it is a function or a field, etc) will be specified in
      specific records.  The name will not be parsed to obtain this
      information.

    - The parent ppt and variable within the ppt/variable hierarchy.
      Also, the type (object-user, enter-exit, object-method, etc) of
      the hierarchy relationship between the two variables

    - Flags about the variable.  These include most of the
      current VarInfoAux flags.

    - Language specific flags about the variables and ppts.  These can
      be utilized by language specific formatting methods (for
      example, JML formatting may use java specific language
      information).  Examples, include final, static, public, private,
      etc.

External variable names

  External variable names should match as much as possible the legal
  variable name in the input language.  All characters are legal
  except for '..'.  Blanks must be escaped with \_ and backslashes
  with \\.  If the variable is an array '..'  marks the location of
  array indices within the variable name.  Adding array indices is the
  only manipulation that daikon output needs to make to an external
  variable name.  Note that array indices can occur multiple times in
  a variable name, but the index will always be the same for each
  instance.  For example, consider the following Java definitions:

    Class A {               Class B {
      B b;                    int c;
      B barr[];               int m1(int arg) {}
      List<B> blist;        }
      int d;
      int[] e
    }

    A a;

  The following names could be specified:

     a.b.c
     a.barr[..].c
     a.barr[..].m1(a.barr[..].c)
     a.barr[..].m1(a.d)
     a.blist.get(..).c

  In the last case, a.blist is a list that we are treating as an array.

  Note that the variable name 'a.barr[..].m1(a.e[..])' should not be
  used because there is no guarantee that the same index can be used for
  'a.barr[]' and 'a.e[]'.

Variable name information

  The following information is specified for each variable:

    var-kind

      Specifies the kind of the variable.  The choices are 'field',
      'function', 'array', or 'variable'.   Pointers to arrays are of type
      'field'.  The arrays themselves (a sequence of values) are of
      type 'array'.  If the variable is a field or function, the name
      of the field or function is specified after the kind.  For
      example:  'var-kind  field f1'.  Field/Function names can include
      any characters except spaces.

    enclosing-var

      The variable that contains this variable.  Required for fields
      and arrays and optional for functions.  If specified for
      functions, the function is an instance method.  If not specified
      the function is static.  A variable is specified by its external
      name.  Note that the enclosing-var must be defined.  If a
      variable is omitted (eg, by the omit-var switch), any variable
      for which it is the enclosing variable must be omitted as well.

    reference-type

      Specifies the kind of reference for variables which are structures
      or classes.  The choices are pointer or offset.  In C, pointer is
      used if the variable is a pointer, offset is used when the structure
      is placed inline.  Pointer would be used for all references to
      java objects.  Defaults to pointer.

    array

      The number of array dimensions inherited or declared by this variable.
      The valid values are 0 or 1.  This should be specified for any variable
      that has multiple values.  If not specified it defaults to 0.  Future
      versions of Daikon may support more levels of arrays.

    function-args

      Specifies the arguments to a function (if any).  Specified by the
      external name of the argument variables.  Multiple arguments are
      blank separated.  For example

        function-args a.b this.f1

      specifies that the function takes two arguments which are 'a.b' and
      'this.f1'.  As with enclosing variables, each of the arguments must
      be defined as variables.

  Some Java examples are:

    PrintStream java.lang.System.out

      var-kind          variable
      type              PrintStream
      rep-type          hashcode

    Type1 arg1

      var-kind          variable
      reference-type    reference
      type              Type1
      rep-type          hashcode

     Type2 arg1.a

      var-kind          field a
      reference-type    reference
      enclosing-var     arg1
      type              Type2
      rep-type          hashcode

    string arg1.a.m1(java.lang.System.out)

      var-kind          function m1
      enclosing-var     arg1.a
      function-args     java.lang.System.out
      type              string
      rep-type          string

    int[] arg1.barr

      var-kind          field barr
      reference-type    reference
      enclosing-var     arg1
      rep-type          hashcode
      type              int[]

    int[] arg1.barr[]

      var-kind          array
      enclosing-var     arg1.barr
      rep-type          int
      type              int
      array             1

    Type3[] arg1.carr

      var-kind          field carr
      reference-type    reference
      enclosing-var     arg1
      rep-type          hashcode
      type              Type3[]

    Type3[] arg1.carr[]

      var-kind          array
      reference-type    reference
      enclosing-var     arg1.carr
      rep-type          hashcode
      type              type3[]
      array             1

    int arg1.carr[].f1

      var-kind          field f1
      enclosing-var     arg1.carr[]
      rep-type          int
      type              int
      array             1

  Some C examples are:

    (int *) a

      var-kind          variable
      rep-type          hashcode
      type              int*

    int *a

      var-kind          function *
      enclosing-var     a
      rep-type          int
      type              int

    Type1 a

      var-kind          variable
      rep-type          hashcode
      type              Type1

    int a->rgb
      var-kind          field rgb
      enclosing-var     a
      rep-type

    int a->rgb[1]

      var-kind          field rgb[1]
      enclosing-var     a
      rep-type          int
      type              int

  Note that the dereference operator is treated as an instance function
  on the variable being dereferenced.  We could support this with a special
  var-kind if desired.

Declared Type

  The declared type of the variable.  Unchanged except that blanks must
  be quoted as they are in variable names.

Representation Type

  The type used to represent the variable in the dtrace file.  Unchanged
  except that strings are named 'string' rather than 'java.lang.String'.

Program point names

  Like external variable names, program point names are not parsed by
  Daikon and are simply passed through to the output.  The only
  restrictions on them is that they are distinct and that blanks must
  be quotes as they are in variable names.

  Information on the type of the program point is contained in a separate
  ppt-type record that specifies the type of the record.  The possible
  types of program points are class, object, enter, exit, subexit and point.

  The 'subexit' type is used for multiple exits from the same method.
  When 'subexit' is used, the program point name must still be made
  distinct.  This can be accomplished by adding the line number of the
  various exits as is done today or by some other front-end specific
  manner.  The 'point' type is used for program points that are not
  of the typical method enter/exit, object, class style.

  As an example of 'subexit', consider the following procedure:
    int foo() {
      if (...)
	return 2*x;
      else
	return 2*x+1;
    }
  A Daikon front end would create two subexit points for this procedure --
  one for each return statement.  No instrumentation is needed for the
  overall exit point, which generalizes the two subexit points.

Parent Ppt/variable

  Each variable can have one or more parent variables in the
  Ppt/variable hierarchy.  Each program point optionally defines one or more
  program points as parents.  Each variable within a program point can
  reference one or more parent program points and variable names.  For
  example, consider the following method in class 'A':

    void m (B b, C c)

  Method 'm' has 3 different parents in the ppt hierarchy.  It is a member
  of class A and it has arguments of classes B and C.  It could also
  be related to an interface or a superclass.

  Each variable can specify one or more of the program point parents and
  optionally the parent variable name within the parent program point.
  If the parent variable name is not specified, it is assumed to be the
  same as the current name.  Presuming that classes A, B, and C each
  have one field named f1, f2, and f3 respectively, the parents for m
  would be:

    variable    parent ppt  parent variable     relation type
    --------    ----------  ---------------     -------------
    this        A:::OBJECT  this                parent
    this.f1     A:::OBJECT  this.f1             parent
    b           B:::OBJECT  this                parent
    b.f2        B:::OBJECT  this.f2             parent
    c           C:::OBJECT  this                parent
    c.f3        C:::OBJECT  this.f3             parent

  Some program points have a 'complete' relationship with the parent
  program points.  For example, each variable in a numbered exit point
  has a parent of the same variable in the common exit point.  In that
  case the relation type is 'complete' and each variable does not have
  to be explicitly annotated.

  The following types of relations are supported:

    enter_exit  - enter method to exit method relation.  In this case, the
                  individual variables are not annotated.  Daikon automatically
                  connects the orig versions of variables at the exit ppt
                  to the same variable at the enter ppt.  The corresponding
                  program points must have the flags 'enter' and 'exit'.
                  See the ppt flags below.

    complete    - All vars in the child have a matching variable with the
                  same name in the parent.  Individual variables are not
                  annotated, Daikon automatically matches each variable.
                  It is an error for the parent and child not to have exactly
                  the same set of variables.  Other relation types cannot
                  be combined with complete.

    parent      - Used for acyclic parent-child relationships.  For
                  example, an object to its methods.  Each variable must
                  be annotated.

    user        - Similar to 'parent', but used if the relationship might have
                  a cycle.  For example, objects used within an
                  object ppt would be a user relation (since they
                  could form a cycle).

Program point flags

  The following flags are supported

    Flag        Default   Description
    ----------  ------    -------------------
    static      false     True if a program point that is a method entry
                          or exit is static (does not have a receiver)

    private     false     True if the program point is private to its class.
                          Only applicable to object oriented languages that
                          have this distinction.  By default, all ppts are
                          not private (ie, public)

Variable Flags

  The following flags are supported

    Flag        Default   Description
    ----------  ------    -------------------
    is_param    false     True if variable is a parameter.  Unchanged
    no_dups     false     True if a collection cannot have duplicates (ie,
                          it is a set).  Used to be has_duplicates
    not_ordered false     True if a collection is not ordered.  Used to
                          be has_order
    no_size     false     True if a collection's size is not relevant.
                          Used to be has_size.  Only valid on collections
    no_mod      false     True if a variable cannot be modified (eg, is
                          final in java).  New.
    synthetic   false     Any variable created by the front end that is not
                          a program variable.  For example, the class name
                          variables.  Pure method calls are marked with
                          'method' only (below) and not 'synthetic'.
    classname   false     Variable is the classname synthetic variable
    non_null    flase     True if a variable can never be null.


  Most of these are the same as previously except that they are changed
  so that the default value is always false.  This somewhat simplifies
  specifying them (a value doesn't have to be specified)  Also, the
  default is the more typical case.

Language specific variable flags

  These flags are specific to the input language and thus can only be
  used by output formatting that is cognizant of the input language.

  The java flags are all of the access flags: public, private, protected,
  static, final, synchronized, volatile, transient, annotation, enum.

  The C flags are TBD.

  Language specific flags will be implemented to make adding a flag
  very easy (just adding a name to a static table).

File format

  The declaration format is line oriented.  Each line is a record that
  consists of an item name followed by the value for that item.  A
  value consists of one or more blank separated items.  A record
  is referred to by its item name.  For example

    ppt C:::OBJECT

  is a ppt record that specifies the name of the program point as
  'C:::OBJECT'.

  The definition for each program point consists of a ppt record
  followed by parent records for the program point and then variable
  definitions.  Each variable definition consists of a variable record
  which defines the external name followed by records that describe
  the details of the variable (kind, enclosing variable, flags,
  comparability, parents, etc).  Program point definitions are
  terminated by a blank line.  Variable definitions are terminated by
  the next variable definition or the end of the program point
  definition.  A rough description of the format is:

    ppt <pptname>
      ppt-type <ppt-type>
      [parent* <relation-type> <parent-ppt-name> <parent-id>]
      [flags <ppt-flags>]
      variable <external-name>
        var-kind <variable-kinds>
        [enclosing-var <external-name>]
        [reference-type pointer|offset]
        [array <dim-cnt>]
        [function-args <arg-list>]
        rep-type <representation-type>
        dec-type <declared-type>
        constant <constant-value>
        [flags <variable-flags>]
        [lang-flags <language-specific-flags>]
        [parent <parent-ppt-name> <parent-id> [<parent-var-name>]]
        [comparability <comparability-value>]

  where

    <relation-type>     ::= enter_exit|complete|parent|user
    <ppt-flags>         ::= static
    <variable-kinds>    ::= field <name>|function <name>|array|variable
    <variable-flags>    ::= is_param|no_dups|not_ordered|no_size|nomod|
                            synthetic|classname
    <ppt-type>          ::= class|object|enter|exit|subexit
    <parent_id>         ::= Number that uniquely identifies a relation
    * means that the record can occur one or more times

  There are also global records that can be specified at the beginning
  of the file (before the first program point definition).  These
  are:

    - Input language record.  Specifies the language of the target
      program.

        input-language |C|C++|Perl|Java

    - The type of comparability used in the file

        var-comparability none|implicit

File compatibility

  Since each item of information about a program point or variable
  is in the record (name-value) format, it is easy to add new items
  (with defaults) while still being compatible with the previous versions
  of the file.

  We can also add a switch that ignores names/flags that are not known so
  that newer versions of the file  can be used with earlier versions
  of daikon.  In that cases, information which is not known would only
  print a warning message.

Daikon internal changes

  The VarInfoName class currently supports both variable names as defined
  in the decl file and names that are created for derived variables.
  The features added to VarInfoName for derived variables are largely
  duplicative of the derived variables code.

  The details of VarInfoName are visible to the output formats and
  the formats have to parse through the AST in order to create the
  correct variable names.

  We believe that output formatting can be significantly simplified by
  accessing all variable name information via VarInfo rather than through
  VarInfoName.  Something like VarInfoName may continue to be used but
  it would be private to VarInfo.  Information obtained from variable
  names (such as the enclosing variable) will be obtained explicitly
  from VarInfo rather than by parsing the AST.

  The downside of this is that a fair amount of work will need to be
  done to change the output formats to use VarInfo rather than VarInfoName.
  This may be a good time to change the java format as well

Object-user hierarchy relation

  Consider the following classes:

    class A {            class B {
      int f1;              int f2;
      B b;                 A a;
    }                    }

  Applied in a naive manner this results in a circular parent child
  hierarchy relationship between classes A and B.  Note, however, that
  the variable relationships are not circular:

    Child                Parent
    --------             -------------
    B::this.a            A::this
    B::this.a.f1         A::this.f1
    A::b                 B::this
    A::b.f2              B::this.f2

  This, however, does not solve the problem.  Bottom up processing must
  process the leaves of the PPT hierarchy tree first and then merge
  invariants up the tree.  Which PPT (A::Object or B::Object) should
  be processed first?  There doesn't seem to be a choice that will work.

  Currently this problem is avoided by simply turning off the object-user
  relationship.  This does not mean that instances of B that are referenced
  from A are not included.  Those instances will still be included whenever
  a method of B is called on them.  In an object oriented language this
  should happen relatively often and there is probably not a significant
  difference in the results.

  This, however, can be a significant problem for object or struct invariants
  in a non-object oriented language.  In that case, there are no object
  methods and the object-user relation is the only one that can be used to
  create struct invariants.

  The proposed solution to this problem is to create two levels of
  hierarchy relations.  The first level are direct relations that
  would not include object-user relations between two classes (it
  would include object user relations where the child is a parameter
  to a method).  These relations (and all other relations) would be
  merged in a first pass.  Then in a second pass we would merge the
  object-user relations we missed on the first pass.  Note that on the
  second pass, some variables may be missing (due to depth
  differences) The merge would be restricted (as merges are now) to
  variables that exist at the child.

  There are several alternative approaches that are discussed in
  appendix A.

Nested arrays

  Support for nested arrays is not included in this proposal.  It is
  suggested that this be undertaken as a separate project.

  The basic approach for nested arrays is to write out sample data
  as it is nested rather than flattening any arrays.  Daikon could
  flatten the data itself when appropriate or it could create 'array
  program points' whose invariants are true over all of the elements
  of the array.

  The internal variable format provides enough information to handle
  nested arrays without changes.  The change would be to the sample
  information.  Since that is not being changed by the rest of the
  proposal, there doesn't seem to be a downside to separating out these
  two issues.  A discussion of nested arrays can be found in Appendix B.

Open Issues

  The following is a list of issues concerning the proposal.  Some
  are open questions and others are concerns that I expect others to
  have.  If there are multiple paragraphs in an issue the first is
  the issue and remaining paragraphs are the proposed answer.

    - How should we handle java lists in external names?  Should we include
      '.get(..)' in the external name?  That implies that the external
      name is always indexed and that is not always the case.  Perhaps
      the external name needs an unindexed value and an indexed value.
      That way the variable 'list' could refer to the entire array referred
      to by a list and 'list.get(1..5)' would refer to a sequence from
      within the list.

      For now, I'm proposing we just include .get() in the external name

    - What does Daikon use the declared type for again?  If
      nothing, it would be nice to make it completely uninterpreted
      (along the lines of the external variable names). The current
      documentation includes a strange restriction about appending the
      right number of "[]"s which it would be nice to get rid of. (smcc)

      The only thing that I know it is used for is determining
      the comparability of hashcodes.  Currently only hashcodes with
      identical declared types are considered comparable.

      I think some output formats need to know the declared type in
      order to create legal code.  It might be useful to declare
      a temporary variable or the like and the declared type would
      be helpful.  But this would not require the declared type to
      be parsed.  I'd suggest that the declared type should be the
      correct name of the type in the input language.  That would require
      it to include the correct number of parens.

    - It might be good to specify whether the decl file is required to be 7-bit
      ASCII, a particular 8-bit character set, or UTF8, though it's actually
      more of an issue for .dtrace files. (smcc)

      I'm not at all familiar with these issues.  It should be in whatever
      format that can easily be read by java.  As long as the parsed
      parts of the file are 'normal', the unparsed parts should be able
      to be anything that can be read by java.

    - Should we change the name for 'implicit' comparability to something
      more meaningful? (pgbovine)

      Sure.  Any suggestions?

    - Should all of the record names in the file format and the flags
      be with underscores or dashes?  Currently all of the record names
      use dashes and all other values use underscores.  This is at least
      somewhat inconsistent.

      I'm happy to change to use dashes everywhere if that is preferred.


Resolved Issues:

    - Rather than supplying information about variables with a name that
      must be parsed, why not make the nesting of variables explicit by
      using xml or some other format that is explicitly nested?  Also
      xml can be easily validated give a DTD or schema (pgbovine)

      It feels like fully nesting all variables within their enclosing
      variables would create a file that both more complex to create
      and read.

      The format is so simple to parse and understand that the advantage
      of a schema is not clear to me, though perhaps I am missing something.

    - Rather than using the internal name, why not specify information about
      each variable in separate records?  for example, a.b.c could be
        field-name c
        enclosing-variable a.b
      Functions and arrays would require additional information but could
      be handled quite similarly.

      We have changed to this approach.  It is somewhat more verbose, but
      is also both more clear and easier to create.  The old approach is
      documented in Appendix C.

    - Is the internal variable operator '->' necessary?  Couldn't '.' only
      be used. (pgbovine)

      This was part of the internal name, but the same information is
      specified in the reference-type record.  We needed to pass this
      information to Daikon in the past, so it seems reasonable to
      continue to provide it.

    - Similarly, should we add '.' and '->' to array references (eg,
      a->[] or a.[]) to make it clear whether or not the array is directly
      within its enclosing name or stored separately?  Currently the proposal
      calls for the field operators to be included with arrays as well.

      (pgbovine) This is weird looking?  Is this complexity worthwhile?

      The reference-type record applies to arrays as well as fields.
      I think it is useful to distinguish between a pointer to an array
      and an inline structure.

    - Do we need to specify list implementors?  Why?

      I still don't know of a reason for these.  I'm going to suggest
      that we remove this.  We can always add it if/when we find a need
      for it.

      Mike thinks that thiswas used as hint when producing java output.
      But I'm not sure how it could bd used.

    - Should a ppt name be parsable or could we simply make this an
      unparsed string?  Its not clear that the static location is at
      all interesting or consistently applicable.  Instead, perhaps we
      should add a ppt-type record that specifies enter/exit and the
      like.  That would remove the need to parse the name completely and
      it could just be language specific.

      I've changed the proposal to take this approach (ppt names are
      unparsed).

    - Should we continue to have both class and object ppts?  The distinction
      is that static variables are in the class ppt and both class
      and instance variables are in the object ppt.  I don't think this
      distinction is valuable to the user.  The only downside I can see to
      combining these two is that there is no single sample count that can
      be used for both sets of variables (static variables receive more
      samples than do instance variables).

      Mike suggests eliminating the distinction and notes that front ends
      should be able to make this choice themselves.

      It might be a good idea in general to support relations where the
      child only contains a subset of the variables at the parent.  This
      is also true of object-user relations because of the depth.

      Daikon should allow either.  Front ends can decide what makes more
      sense for their language.  This does imply that the sample count
      will not be correct for cases where the child does not have all of
      the variables of the parent.

    - How are private methods handled?

      The front end can decide whether or not to include private
      methods in the hierarchy.

      The front end can also mark program points as private.  Daikon
      will have a switch or configuration option that will ignore
      any hierarchy relationships on private program points.  Daikon
      could also optionally check to see if the private program points
      broke any object invariants and/or create a public/private version
      of the object program points.

    - Should front ends be required to include the enclosing variable
      for each variable?  This would imply that if a variable was
      omitted that any enclosed variables would be omitted as well.
      While placing more burden on the front end, it might make a more
      consistent decl file especially if we go to a nested approach
      for sample data at some point.

      With the record oriented approach to defining variables, the enclosing
      variable is required for all fields and instance methods.  Thus all
      enclosing variables must exist.  Daikon's implementation of omit-var
      must also remove any variables whose enclosing variable is removed.

    - Do we need a program point abbreviation when specifying parent
      program points?  The point of this was to ease readability for
      long ppt names.

      I don't think this is necessary.  I think, instead, that certain
      ppt relations (exit->exitNN, enter->exit) should automatically create
      the correct variable relations.  The only reason this wouldn't work
      would be if the internal names were different from enter to exit
      or exit to numbered exit.  That doesn't seem very likely (or useful).
      Daikon already needs to understand enter/exit ppts since it creates
      orig versions of the variables (which would also be confused if
      the variables had different names).

    - How should the object-user relation handle the multiple possible
      relations that can occur with nested classes?  For example, if
      the depth is 5 and we have a variable 'a' of type A from the'
      example, the following variables exists:

        a.f1
        a.b.f2
        a.b.a.f1
        a.b.a.b.f2

      Should each instance of a field in B (a.b.f2 and a.b.a.b.f2) be tied
      back to B directly (ie, its parent is B::this.f2) or should it only
      be tied to the corresponding level in B (the parent for a.b.f2 is
      B::this.f2 and the parent for a.b.a.b.f2 is B::this.a.b.f2), or
      both?

      The later relation is correct.  Note that the B nested within B
      should also be connected by to B which covers this.

    - Should we include information on superclasses in the declaration
      information?  This could be used to determine what variables are
      possibly comparable (at least in java).  Or perhaps we should include
      two forms of comparability information -- calculated comparability
      (ala DynComp) and type comparability (that can be determined statically
      by the front end, eg, declared types, typedefs, etc).

      We should not include superclass information.  The front end could
      take this into account when creating comparability data or we can
      use other comparability data.  There is no need for two types of
      comparability data in the same file.

    - Can blanks be included in names (program point, variable, type, etc)?

      Blanks can be included, but they must be escaped with as \_.  This
      provides for easier parsing while still being somewhat reasonable.

    - It doesn't look like the internal variable grammar supports
      arrays that nest directly inside another array ("foo[][]",
      etc.). Was that intentional? (smcc)

      Nested arrays are interesting case.  The simplest way for Daikon
      to support these would be to simply flatten the two dimensions
      into a single dimension.  It doesn't seem like much would be
      lost by doing so.  But, if/when we support nested arrays in
      general, that probably wouldn't be consistent with the overall
      approach.  I think for now, nested arrays of that sort should
      not be supported, but they should be when we decide to support
      nested arrays in general.  In the interim, Its up to a front end
      to decide if it wants to flatten those arrays.  The obvious
      downside of flattening the array is that normal derived
      variables and array size invariants won't make much sense.

    - Kvasir currently makes front-end-derived array elements (for
      instance, if the array "rgb" is statically declared to have 3
      elements, we make variables scalar variables rgb[0], rgb[1], and
      rgb[2] instead of a sequence).  How would this be supported?
      (smcc)

      (pgbovine) We do this because it allows us to get 1 extra level
      of arrays.  For example:

         rgb[0].foo[]
         rgb[1].foo[]
         rgb[2].foo[]

      otherwise, rgb[].foo[] is a 2-D array which Daikon cannot curently
      support.

      As shown in the examples, this is legal.  A number inside of
      brackets is treated as a special field name.  Front ends can
      decide if they wish to do this or not.

    - Kvasir creates pointer dereferences (if x is an "int ***", you might
      want variables for x, *x, **x, and ***x).  At the moment, I think
      we output both using an array syntax, since "x[0]" happens to
      usually be equivalent to "*x" in C. How should we name these
      variables in the new syntax? (smcc)

      The external name can be exactly as indicated above.  There are
      a variety of ways that the variable could be described to
      daikon, but I suggest treating the defererence operator as
      an instance method.  Thus *a is defined as:

        var-kind           function *
        enclosing-var      a

    - Should we allow functions in the middle of variable names?
      For example 'foo(a).x' or 'a.foo().x'  This would allow pure
      functions that return non-primitives and seems reasonable.

      Both of the above examples should be legal.

    - I'd worry that a single "*" as a placeholder for array indices
      in the external name is likely to conflict with the syntaxes of
      other languages. For instance, as mentioned above it would be
      nice to use "*" for dereferences in C (though we don't at the
      moment). In Perl, there's a class of variables whose names start
      with "*" (though dfepl doesn't support them at the moment) and
      there's also a global variable for just about every punctuation
      character, including $*. Perhaps a multi-character marker would
      be more robust?  (smcc)

      I'd forgotten about '*' in C.  I've changed the proposal to use
      '..' instead.  We could also use '...', or the somewhat less
      elegant alternative of specifying the offset (in characters).
      The latter always works and it leaves the variable name
      completely unchanged.  But its quite unreadable.

    - Can we change the rep type name for strings from "java.lang.String"
      to "string"? (smcc)

      Yes, the proposal now indicates this.

    - In program point names, can <static-location> can be anything, as
      long as it doesn't contain "::" or ":::"?  The character set
      restriction on <name> seems a bit restrictive. For
      instance, C++ has methods with names like:
        std::basic_filebuf<char, std::char_traits<char> >
                       ::seekpos(std::fpos<__mbstate_t>, std::_Ios_Openmode)
      I'd say the static location there is
         std::basic_filebuf<char, std::char_traits<char> >
      and the name is
         seekpos(std::fpos<__mbstate_t>, std::_Ios_Openmode)
      Note that they both contain "::", which makes it problematic to use
      "::" as the delimiter between them. Also, the operator overloading
      syntax means that just about any punctuation mark can appear in the
      name part. (smcc)

      I think these are all good reasons why the ppt name should not be
      parsed at all by Daikon.  Lets add a ppt-type record to specify
      the type of the program point and leave the ppt-name itself
      unparsed.

    - Is the indentation in the file format meant (or just suggested)
      to be that way in the file? (smcc)

      It is not required to parse the file, but I think the file is more
      readable that way.

    - Should language specific flags be defined in a data file so that they
      can be updated without recompiling daikon? (mernst)

      I don't think this is necessary.  We already plan to have a switch
      that will ignore flags that are not understood.  Since Daikon can't
      do anything with a flag it doesn't know anything about, this would
      seem to be sufficient.

    - Are the language specific flags only intended for internal daikon
      use? (mernst)

      Yes.  I couldn't think of another use.

    - Is the set of characters for internal names the set of legal chars
      in all languages we want to support or will there need to be some
      sort of translation?  (pgbovine)

      This is no longer relevant as we do not use internal names

    - In the ppt hierarchy, what is the parent for a C function?
      The file it is contained in? (pgbovine)

      A file doesn't provide a variable hierarchy since methods from the
      same file don't necessarily share any variables in common (except
      for file statics).  Methods that are passed a structure could have
      a object-user relation.  I think this is closes to the object-method
      relation from an object oriented language.  If we think that file
      statics are interesting, then they could be included as well.  The
      front end can define the hierarchy that make sense to it.

    - Should we rename 'comparability' to 'abstract-type' as in the ISSTA
      paper and move it earlier in the list of variable records? (pgbovine)

      I think that comparability is what Daikon is interested in and this
      is a Daikon file.  But I certainly don't feel strongly about it.
      The order of the records is arbitrary.  Any order is ok.

    - Should the relation types (object-user, exit-exitnn, etc) be built-in
      to Daikon, or just a name given by the front end?

      These have been changed to be more generic.  Only enter_exit has
      a specific meaning.  That is required because relations have to
      be made to orig variables which are created by Daikon.


Appendix A -- Alternative Object-User hierarchy relation solutions

  A second approach would be to create new ppts for nested classes.
  For example, we would create A.b::Object and B.a::Object program points.
  A.b has two parents: A and B.  Similarly B.a has the same two parents.
  Unfortunately, this does not seem to work.  Bottom up processing
  presumes that a child always has a superset of the variables of the
  parent.  It won't be possible to find invariants between A::this.f1 and
  A::this.b.f2 via the A.b::Object program point (which doesn't contain
  f1).

  A third approach would be to to not create relations between objects,
  but to instead, create direct ties from the leaves to multiple object
  points.  For example, consider a ppt 'foo()' that is passed a parameter
  of type A.  We would create two object user relations:

    foo():: -> A::
    foo():: -> B::

  The variable relations would be:

    Child                Parents
    --------             -------------
    foo()::a             A::this
    foo()::a.f1          A::this.f1
    foo()::a.b           A::this.b      B::this
    foo()::a.b.f2        A::this.b.f2   B::this.f2
    foo()::a.b.a         A::this        B::this.a
    foo()::a.b.a.f1      A::this.f1     B::this.a.f1

  Two possible problems arise here.  First, is how do we handle children
  with multiple parents.  I don't really think that should be a problem.
  Each parent will merge the results from each of its children.  Having
  a child in two lists should not present a problem.

  Second, is how do we handle multiple child variables for a single
  parent variable (ie, foo()::a and foo()::a.b.a both are related to
  A::this).  This is a little less clear.  I think what would need to
  happen is that when merging, an invariant can be true for 'A::this' only
  if it is true at both of the variables that are children.  I think this
  can work but it would require changes to code that is already a tad
  complex.  The trick will be finding the sets of variables that go
  together (ie, foo()::a and foo()::a.f1 are one set of variables
  attached to A:: and foo()::a.b.a and foo()::a.b.a.f1 are a separate
  set)

  A fourth approach would be to only create object-user relations
  when an object is used as a parameter.  In our example from
  above, only the relations to A:: would be created.  The nested
  occurence of B would not create any object-user relations to B.
  The same would be true at the object level, there would be no relations
  between A:: and B::.  This removes the circular problem while still
  allowing object-user relations in the most obvious case.


Appendix B -- nested arrays

  Consider the following classes

    class A {           class B {          class C {
      int f1;             int f3;            int f5;
      int f2;             int f4;            int f6;
      B[] b_arr;          C[] c_arr;       }
    }                   }

    A a;

  Currently front ends create arrays of primitives from arrays
  of objects.  For example:  a.b_arr[].f3 and a.b_arr[].f4.  This
  requires some uinutitive and repetitive processing in the front
  end.  It also doesn't seem to extend well to nested arrays.  If
  a.b_arr[].c_arr[].f5 were combined into one flat array, it is not
  clear what useful invariants would be found.  We are really
  interested in invariants that are true over c_arr[] at each
  element of b_arr[] (such as c_arr[] is sorted) that wouldn't necessarily
  be true of the combined array.

  A different option for arrays would be to look for invariants over
  each element of an array of classes/structures.  Consider a variable
  of class B from above.  Rather than creating arrays of b[].f5 and b[].f6,
  we would create a special program point for b[].  The variables at this
  program point might be:

    b.f3
    b.f4
    b.c_arr.f5
    b.c_arr.f6

  For each element of c_arr, we would apply the values.  Note that the
  values of b.f3 and b.f4 are fixed and would thus be repeated for each
  element of the array.

  This approach would find almost all of the invariants that our
  current approach does with the following exceptions:

    - It would not find the sequence invariants (no-dups, one-of,
      reverse, subset, or subsequence), over f5 and f6 because those
      sequences are never actually created.  The no-dups invariant
      could be found with an invariant with state.

    - It could find the sequence-index invairants if we added the index
      as a derived variable.  Its not clear how interesting an invariant
      this is anyway.

    - It would not find the lexical comparisons, because those are
      order dependent.  Again, its not clear how interesting these would
      be on anything that is not an array of characters.

    - Pairwise invs would be found between elements of the same
      class (here f5 and f6), but not between elements of different
      classes (if B contained a second array of a different class, those
      fields would not be compared).  Since many of the invs require
      that their arrays be of the same length, these invs may occur
      only rarely.

    - It would not find the adjacent element comparisons (sequence is
      sorted by ...) unless we did something special to enable them.
      It seems like it should be possible to do this (and perhaps other
      things as well, by keeping a special 'prev' version of each
      variable (this is missing on the first element).  For example, the
      vars would be:

        b.f3
        b.f4
        b.c_arr.f5
        b.c_arr.f6
        prev(b.c_arr.f5)
        prev(b.c_arr.f6)

      Or by adding special invariants that remember their previous
      value.

  I believe that all of the other invairants could be found and with
  less implementation effort (all of the elt-wise and pairwise invs
  could be eliminated as they would now be found by their scalar
  versions).  A number of other invariants that we have not currently
  implemented for sequences (such as square) would be found as well
  with no extra implementation work.


Appendix C -- Internal Variable Names

  This appendix contains the original internal variable name proposal.
  This has been replaced by individual records specifying variable
  information.

  The internal variable name is a C-like canonical name for the variable.
  A rough BNF is:

    [<static-location>]::<name>

  where

    <static-location> ::= an arbitrary string name for the static location
                          of the variable.  For example 'java.lang.System'.

    <name>            ::= [<name>[<field-op><array-op>]<field-op>]<field>
    <field>           ::= <identifier>[([<args>])]
    <array-op>        ::= '[]'
    <field-op>        ::= '.' | '->'
    <args>            ::= <name>|<name>,<args>

  For example:

    java.lang.System::out
    a.b.c
    a->b->c
    a->d
    a->d->[].c
    a->g.[]
    a->foo()
    a->m1(b.c,a->d)

  The field-op specifies that the field is enclosed within the name.
  As in C, the '.' operator specifies that the field is physically
  stored as part of its enclosing name and the '->' operator specifies
  that the name is a reference to a separate memory area that contains
  the field.  Note that in Java, '->' would always be used.  It may be
  that this distinction is not important to Daikon, but it seems
  reasonable to include the information that is available to the front
  end.

  The array-op specifies that there the preceeding name is an array
  and that this variable represents its contents.  Just as with fields,
  if the '.' operator is used before the array op, the array is stored
  as part of its enclosing name and if the '->' operator is used,
  the name is a reference to a separate memory area that contains
  the array.

  If the field name is followed by parens it is a function (presumably
  pure) and not a field.  Arguments can optionally be specified.  Initial
  versions may not fully support arguments.  If the function is an instance
  method, then it should appear enclosed within its receiver variable.
  Static methods appear at the top level (eg, m1(b.c))  If the reciever
  or any the arguments to a function is an array element, other arguments must
  be elements of the same array or occur before the array.  It is not
  possible to use elements from two unrelated arrays as arguments.  For
  example:

    class A {
      int f1;
      int f2;
      String m1 (int i, int j) {}
    }

    A[] a;
    int[] karr;
    int ii;
    int jj;

  Legal variables with functions are:

    a->[]->m1(a->[]->f1,a->[]->f2)
    a->[]->m1(a->[]->f1, jj)
    a->[]->m1(ii,jj)

  An illegal function name would be

    a->[]->m1(karr[],jj)

  There is a special function named '*' which dereferences its one
  argument.  For example '*(a.b)' dereferences the pointer a.b.

  Identifiers can include the following characters:  a-zA-Z0-9_$@%
  Other characters are reserved for future features.

  The internal name conveys the following information to Daikon:

    - The name of the enclosing class or structure.  For example:

        Internal name                 Parent name
        --------------                -----------
        a                             <none>
        a->b                          a
        package.class::a->b           package.class::a
        this                          <none>
        this->j                       this
        this->j->[]                   this->j
        this->j->[]->i                this->j->[]

      Note that even if an enclosing name can be determined (as in all
      the cases except 'a' and 'this' above), it will not necessarily
      be declared in the decl file.  Front ends can be configured to
      ignore variables by name.  As an alternative, we could require
      that front ends always remove any enclosed variables of any
      omitted variable.

    - The name of the field itself.  This allows the internal name to
      be used to construct names in other languages (such as simplify)
      that have a different naming scheme for fields.

    - The location of any arrays.  Note that the syntax supports nested
      arrays even though Daikon currently limits arrays to one level.


Appendix D -- Various Notes

Things we need to include:

  - variable declared type (including arrays).

  - variable rep type

  - hierarchy relationships (by variable, ppt?).  Do we want to
    duplicate information at each ppt or somehow refer to the
    upper element?

  - attributes (public, private, protected, is param, declaring
    class, synthetic, etc)

  - Nesting information.  Arrays of arrays.  What variables are
    fields inside of other variables.

  - Comparability information

  - Global information (type of comparability, possibly other)

  - Language specific formatting information (., ->, etc)

Formatting possibilities

  - xml

  - line oriented ascii

  - There doesn't seem to be any need to optimize the format since decl
    files are relatively small compared to dtrace files.  Readability
    and expandability seem like important considerations.

  - Do we want a format that is forwards compatible (ie, a new version
    of the decl file could be read by an old version of the program).
    I tend to think not.  This is a pain and it usually means that
    error messages are impossible to produce.

Other:

  - Do we want to consider changes to the dtrace format at the same time?
    In particular, would we like to change the way that nested arrays
    are handled?  Change to a binary (or, at least, less verbose) format?

-----------------------------------------------------

Mike's notes:

  - Daikon doesn't properly omit private methods from the hierarchy because
    we don't tell it which methods are private.  This is really
    the hierarchy issue.

  - Daikon parses variable names such x.y.z and presumes that x and x.y
    are variables also.  This is not necessarily true (as in java
    static variables).  This is the variable-fields issue.

  - How do we create language-specific legal variables?  For example,
    in C x.y->z.  Do we ever need to create language-1 output from
    language-2 input?  I tend to think not.  Another way to ask this
    question is do we ever need to create JML or ESC/Java output from
    C programs?

  - How do we create format specific variables (like those for simplify)
    from language-specific input?

  - Format should remain simple and human readable.

  - We need to be able to manipulate variables to create derived
    variables.  In particular, we need to create array references and
    subsequences.

  - We don't need to be backwards compatible with existing files, though
    it would be nice to add a tool that would update existing files to the
    new format.

  - Something loads .class fiels for java.  What and why?

  - Need to know if a method is static (reason for this is unclear to
    me -- something from Carlos)

------------------------------------------

Ideas:

  - Each variable has a language specific name (such as a.x->y) and a
    internal Daikon name (in this case, perhaps a.x.y)

Questions:

  - What sort of information do we really need from ProglangType?

    Why is this so complex for a tool that only has primitives and one-
    dimensional arrays?

  - What information do we really need about variables?  All I can
    think of is what their enclosing variable is (eg, x is the
    enclosing variable for x.y)

  - What future features do we want to consider?
      - adding new variables dynamically
      - Multi-dimensional arrays?
      - new basic types (maps?)

  - Do we want to support object-user relations.  Do we want to name
    various relations so Daikon can choose which ones to support?

  - Should include attributes such as final (used to determine if a variable
    can be modified) and should add an attribute for variables derived in
    the front end.  We might want to identify them specifically as well (as
    opposed to looking at their name which is what we do now).

--------------------------------------------

VarInfoName issues:

  - esc_name returns the name in ESC format.  Since this is java specific
    it may only make sense to do this for java input formats (where this
    would seemingly be simple).  Similarly for java_name() and jml_name()

  - ioa_name returns the name in IOA format.  Do we still use this?  Does
    it make sense if the input langauge is not IOA?

  - What does '$noprint' mean?  Why do we use this?  I'm guessing there
    some advantage to having format still return something but have
    PrintInvariants not print it.  But this seems like a somewhat awkward
    way to do that.  Note we do similar things for java format (by ignoring
    invariants that include $pre)

  - There is test code for VarInfoName in VarInfoNameDriver.  This code
    passes in null for VarInfos that are sometimes required in VarInfoName.
    There is a boolean in VarInfoName (testCall) that accepts these nulls
    where it normally would not.  It is not at all clear why a proper
    VarInfo cannot be created in VarInfoNameDriver to avoid this gross
    usage.

  - The code that reads class files is used to determine if things are
    final.  That can be removed if we add final to the attributes contained
    in the decl file.

  - There are at least 10 cached variables within each VarInfoName.  If
    there are many instances, this could take up a fair amount of space.

Other issues:

  - Simplify is not tested by the regression tests.  It is not at all
    clear to me why that is.

  - Do we need to distinguish between fields (a.b) and pure methods (a.pure())?

  - If we make other classes (eg, lists) look like arrays to Daikon, how
    do we name those variables?  In the language specific output formats
    it seems clear that we would want to use the list syntax.  For example,
    in java:

       list.get() as opposed to list[]

    But perhaps the internal format should always treat it as an array

       list[]

  - How do we handle names that cannot be represented in the input
    language format?  I think this is just orig, but there may be others
    as well.

  - How should we handle nested variables with orig.  Now, in Daikon format,
    orig is presumed to apply to any other variables (such as subscripts)
    within the orig.  I tend to think this is confusing as hard to parse.
    Perhaps we should always use orig with each variable as appropriate and
    drop the use of 'post' in all circumstances.

  - As mike has suggested, I think VarInfo needs to be the base for all
    name issues.  Arguablly, VarInfoName should be private to VarInfo.
    This make sense because VarInfo has all of the information about a
    name (in particular, derived variable).  We don't want to have to
    add complexity to VarInfoName to handle derived variables.

Possible formats for variable names

  - language specific format.  Arrays are marked as such and contain
    a placeholder where the indices go.  For example:

      x.y[...].z
      x->y[...].z

    The placeholder is '...'.  The decl file format ought to allow this
    to specified by the front end (so that it doesn't conflict with any
    valid character sequence in a name).  Creating a name with an index
    then is simply a matter of replacing the placeholder with the index.

  - If a variable is a field within another variable, then its parent
    variable should be specified (by name).  Do we need to differentiate
    between classes which are physically contained within each other
    (such as structures in C) and pointers?  For example:

      struct A {
        int i;
        int j;
        int k[10];
        int *arr;
      }

      struct B {
        struct A a;
      }

      struct C {
        struct A *a;
      }

  - front end derived variables should be specified specifically and not
    just embedded in the name.  Specifically getClass.  Note that array
    lengths are daikon derived variables and are thus easy to figure out
    from the varinfo.  Similarly with orig variables.

  - internal name.  The internal name should be in a standard format and
    that does not vary by front end.  I think C would be a good choice as
    is more expressive than java.  Given (from the above example)

       struct B b;
       struct C c;

     we have variables:

        b.a.i
        b.a.j
        b.a.k[]
        b.a.arr[]
        c.a.arr

        c.a->i
        c.a->j
        c.a->k[]
        c.a->arr
        c.a->arr[]

Arrays:

  - Example classes:

    class A {
      int f1;
      int f2;
      B[] b_arr;
    }

    class B {
      int f3;
      int f4;
      C[] c_arr;
    }

    class C {
      int f5;
      int f6;
    }

    A a;

  - What invariants do we want with c_arr

    1) a.b_arr[].c_arr[].f5 unary invariants
    2) a.b_arr[].c_arr[].f5 op a.b_arr[].c_arr[].f6 elementwise invairants
    3) a.b_arr[].c_arr[].f5 op a.b_arr[].f3 seq-scalar invariants
    4) a.b_arr[].c_arr[].f5 op a.f1 seq-scalar invariants

  - Possible invariants

    - common subsequence (array that always contains some elements)
    - elt upper/lower bound (x[] elements > C)
    - elt non zero (x[] elements != 0)
    - elt one of (x[] elements one of c1, c2 ,c3)
    - eltwise equality (x[] elements are equal)
    - eltwise comparison (X[] sorted by >, >= <, or <=)
    - pairwise comparison (x[] ==,>,<,>=,<=,!= y[])
    - pairwise divides (x[] % y[] == 0)
    - pairwise square (x[] = y[]^2)
    - pairwise bitwise-and=0 (x[] & y[] = 0)
    - pairwise bitwise complement (x[] = ~y[])
    - pairwise shift-zero (x[] >> y[] == 0)

    - scalar equal (x == y)
    - scalar comparison (x >, >=, <, <=, or != y)
    - scalar function binary (x = y & z), (x = y | z), etc
    - scalar linear binary (ax + by = c)
    - scalar linear ternary (ax + by + cz = d)
    - scalar upper/lower bound
    - scalar non-zero (x != 0)
    - member (x in y[])
    - scalar divides (x % y == 0)
    - scalar square (x = y^2)
    - scalar bitwise-and-0 (x & y == 0)
    - scalar bitwise complement (x = ~y)
    - scalar one-of (x oneof c1, c2, c3)
    - sequence no-dups (x[] contains no duplicates)
    - sequence one-of (x[] one of {c1,c2}, {c3, c5, c6})
    - sequence reverse (x[] is the reverse of y[])
    - sequence index comparison (x[i] ==,>=,>,<,<=,!= i)
    - seq-seq lexical comparisons (x[] ==,<,<=,>,>= y[] lexically)
    - subsequence (x[] is a subsequence of y[])
    - subset (x[] is a subset of y[])

  - A different option for arrays would be to look for invariants over
    each element of an array of classes/structures.  Consider a variable
    of class B from above.  Rather than creating arrays of b[].f5 and b[].f6,
    we would create a special program point for b[].  The variables at this
    program point might by:

      b.f3
      b.f4
      b.c_arr.f5
      b.c_arr.f6

    For each element of c_arr, we would apply the values.  Note that the
    values of b.f3 and b.f4 are fixed and would thus be repeated for each
    element of the array.

    This approach would find almost all of the invariants that our
    current approach does with the following exceptions:

      - It would not find the sequence invariants (no-dups, one-of,
        reverse, subset, or subsequence), over f5 and f6 because those
        sequences are never actually created.

      - It could find the sequence-index invairants if we added the index
        as a derived variable.  Its not clear how interesting an invariant
        this is anyway.

      - It would not find the lexical comparisons, because those are
        order dependent.  Again, its not clear how interesting these would
        be on anything that is not an array of characters.

      - Pairwise invs would be found between elements of the same
        class (here f5 and f6), but not between elements of different
        classes (if B contained a second array of a different class, those
        fields would not be compared).  Since many of the invs require
        that their arrays be of the same length, these invs may occur
        only rarely.

      - It would not find the adjacent element comparisons (sequence is
        sorted by ...) unless we did something special to enable them.
        It seems like it should be possible to do this (and perhaps other
        things as well, by keeping a special 'prev' version of each
        variable (this is missing on the first element).  For example, the
        vars would be:

          b.f3
          b.f4
          b.c_arr.f5
          b.c_arr.f6
          prev(b.c_arr.f5)
          prev(b.c_arr.f6)

        Or be adding special invariants that remember their previous
        value.

    I believe that all of the other invairants could be found and with
    less implementation effort (all of the elt-wise and pairwise invs
    could be eliminated as they would now be found by their scalar
    versions).

Object-User Hierarchy relationships

  Consider the following classes:

    class A {            class B {
      int f1;              int f2;
      B b;                 A a;
    }                    }

    A avar;                 B bvar;

  Applied in a naive manner this results in a circular parent child
  hierarchy relationship between classes A and B.  Note, however, that
  the variable relationships are not circular:

    Child                Parent
    --------             -------------
    B::this.a            A::this
    B::this.a.f1         A::this.f1
    A::b                 B::this
    A::b.f2              B::this.f2

  This, however, does not solve the problem.  Bottom up processing must
  process the leaves of the PPT hierarchy tree first and then merge
  invariants up the tree.  Which PPT (A::Object or B::Object) should
  be processed first?  There doesn't seem to be a choice that will work.

  Perhaps this could be resolved by creating two types of relations.
  The first are direct relations that would not include object-user
  relations between two classes (it would include object user relations
  where the child is a parameter to a method).  These relations would be
  merged in a first pass.  Then in a second pass we would merge the
  object-user relations we missed on the first pass.  Note that on the
  second pass, some variables may be missing (due to depth differences)
  The merge would be restricted (as merges are now) to variables that
  exist at the child.

  A second approach would be to create new ppts for nested classes.
  For example, we would create A.b::Object and B.a::Object program points.
  A.b has two parents: A and B.  Similarly B.a has the same two parents.
  Unfortunately, this does not seem to work either.  Bottom up processing
  presumes that a child always has a superset of the variables of the
  parent.  It won't be possible to find invariants between A::this.f1 and
  A::this.b.f2 via the A.b::Object program point (which doesn't contain
  f1).

  A third approach would be to to not create relations between objects,
  but to instead, create direct ties from the leaves to multiple object
  points.  For example, consider a ppt 'foo()' that is passed a parameter
  of type A.  We would create two object user relations:

    foo():: -> A::
    foo():: -> B::

  The variable relations would be:

    Child                Parents
    --------             -------------
    foo()::a             A::this
    foo()::a.f1          A::this.f1
    foo()::a.b           A::this.b      B::this
    foo()::a.b.f2        A::this.b.f2   B::this.f2
    foo()::a.b.a         A::this        B::this.a
    foo()::a.b.a.f1      A::this.f1     B::this.a.f1

  Two possible problems arise here.  First, is how do we handle children
  with multiple parents.  I don't really think that should be a problem.
  Each parent will merge the results from each of its children.  Having
  a child in two lists should not present a problem.

  Second, is how do we handle multiple child variables for a single
  parent variable (ie, foo()::a and foo()::a.b.a both are related to
  A::this).  This is a little less clear.  I think what would need to
  happen is that when merging, an invariant can be true for 'A::this' only
  if it is true at both of the variables that are children.  I think this
  can work but it would require changes to code that is already a tad
  complex.  The trick will be finding the sets of variables that go
  together (ie, foo()::a and foo()::a.f1 are one set of variables
  attached to A:: and foo()::a.b.a and foo()::a.b.a.f1 are a separate
  set)

  A fourth approach would be to only create object-user relations
  when an object is used as a parameter.  In our example from
  above, only the relations to A:: would be created.  The nested
  occurence of B would not create any object-user relations to B.
  The same would be true at the object level, there would be no relations
  between A:: and B::.  This removes the circular problem while still
  allowing object-user relations in the most obvious case.

  In an object-oriented language its not clear that object-user relations
  are critical at all.  After all, when an object of type A is passed
  to a method, the most likely thing to happen to that object is to have
  a method called on it.  This will provide the check itself.  However,
  in a language such as C, struct program points can only be interesting
  if some version of object-user is implemented.  Otherwise there would
  be no children for a structure and we could not find invariants over
  it.
