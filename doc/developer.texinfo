\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename developer.info
@settitle The Daikon Invariant Detector Developer Manual
@c %**end of header

@c To update all the nodes and menus all at once:   C-u C-c C-u m
@c You shouldn't need to do that, though; the Makefile does it for you.

@macro daikonemail{}
@email{daikon-developers@@lists.csail.mit.edu}
@end macro

@c @setchapternewpage odd

@c avoid black boxes marking overfull hboxes in TeX output
@finalout

@titlepage
@sp 10
@c Could also use @title, @subtitle, @author here.
@center @titlefont{Daikon Invariant Detector Developer Manual}

@sp 2
@center Daikon version 4.6.1

@sp 1
@c Daikon version 4.6.1 date
@center September 1 2009

@sp 5
@c reads daikon-logo.{eps,pdf} (not .txt, .png, or .jpg, because info
@c and HTML don't get the title page)
@image{images/daikon-logo,4in,}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1998-2005
@c Copyright @copyright{} 1998-2001 Michael Ernst
@end titlepage

@html
<img src="images/daikon-logo.gif" alt="Daikon logo">
@end html
@c Why is this here? It duplicates the stuff further down.
@c @html
@c <h1>Daikon Invariant Detector User Manual</h1>
@c
@c This is the developer manual for the Daikon invariant detector.
@c It describes Daikon version 4.6.1, released September 1 2009.
@c @end html

@c Putting this lower in the HTML version looks a little bit strange,
@c but it's acceptable. 
@ifnothtml
@contents
@end ifnothtml

@node    Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifnottex
@c Unfortunately, the Daikon logo doesn't look good in ASCII.
@c @ifinfo
@c @image{images/daikon-logo,4in,}
@c 
@c @end ifinfo
This is the developer manual for the Daikon invariant detector.
It describes Daikon version 4.6.1, released September 1 2009.
@end ifnottex

@menu
* Introduction::                
* Extending Daikon::            
* Debugging Daikon::            
* Daikon internals::            
* Testing::                     
* Historical::                  
* File formats::                
* Index::

@ifhtml
@contents
@end ifhtml
@ifnothtml

@detailmenu
 --- The Detailed Node Listing ---

Extending Daikon

* Compiling Daikon::            
* CVS repository::              
* Using Eclipse::               
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              
* New suppressors::             
* System.exit::                 

New front ends

* Example instrumented Java program::  
* Instrumenting C programs::    

Debugging Daikon

* Track logging::               

Track logging

* Adding track logging::        
* Track log output::            

Daikon internals

* Avoiding work for redundant invariants::  
* Dataflow hierarchy::          
* Equality optimization::       

Testing

* Unit testing::                
* Regression tests::            

Unit testing

* Invariant format testing::    
* Sample Testing::              

Sample Testing

* Assertions::                  
* Example file::                

Regression tests

* Kvasir regression tests::     
* Adding regression tests::     

Analyzing historical versions of Daikon

* Branches::                    

File formats

* Declarations in a separate file::  
* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               
* Version 1 Declarations::      

Declarations

* Declaration-related records::  
* Program point declarations::  
* Variable declarations::       

Declaration-related records

* Declaration version::         
* Input-language declaration::  
* Variable comparability::      
* ListImplementors declaration::  

Data trace records

* Nonsensical values::          
* Variables that do not appear in trace records::  

Example files

* Example declaration file::    
* Example data trace file::     

Version 1 Declarations

* V1 Program point declarations::  
* V1 pptname format::           
* V1 VarComparability declaration::  
* V1 ListImplementors declaration::  

@end detailmenu
@end ifnothtml
@end menu

@node    Introduction, Extending Daikon, Top, Top
@chapter Introduction

This is the developer manual for the 
@uref{http://pag.csail.mit.edu/daikon/, ,Daikon invariant detector}.
For information about using Daikon, see its user manual (@pxref{Top,,Overview,./daikon,Daikon User Manual}).
This manual is intended for those who are already familiar with the use
of Daikon, but wish to customize or extend it.

Additional information can be found in technical papers available from
@uref{http://pag.csail.mit.edu/daikon/pubs/}.


@node    Extending Daikon, Debugging Daikon, Introduction, Top
@chapter Extending Daikon

@cindex extending Daikon
@cindex changing Daikon
@cindex customizing Daikon
@cindex modifying Daikon

This chapter describes how to customize or modify Daikon.


@menu
* Compiling Daikon::            
* CVS repository::              
* Using Eclipse::               
* New invariants::              
* New derived variables::       
* New formatting for invariants::  
* New front ends::              
* New suppressors::             
* System.exit::                 
@end menu

@node    Compiling Daikon, CVS repository, Extending Daikon, Extending Daikon
@section Compiling Daikon
@cindex compiling daikon

To compile Daikon, type @samp{make} in @file{daikon/java/} or any of its
subdirectories.  The distribution includes compiled @file{.class} files,
so you do not need to compile them yourself unless you make changes.

When you compile Daikon, environment variables @env{DAIKONDIR} (or
@env{INV}, whose effect is the same) and @env{JDKDIR} should be set.
This is already done if you source the @file{daikon.bashrc} or
@file{daikon.cshrc} file, as recommended in the installation
instructions (@pxref{Complete installation,,,./daikon,Daikon User Manual}).
When you compile Daikon, environment variable @env{DAIKONCLASS_SOURCES}
should be set (to any value) before your startup file sources file
@file{daikon.bashrc} or @file{daikon.cshrc}.
Thus, a complete @file{.bashrc} or @file{.bash_profile} shell setup file
that would enable you to compile Daikon might look like the following.

@example
  export INV=$HOME/invariants
  export JDKDIR=$HOME/jdk1.5.0_04
  export DAIKONCLASS_SOURCES=1
  source $INV/scripts/daikon.bashrc
  export CLASSPATH=.:$CLASSPATH
@end example

@cindex .jpp files
@cindex jpp files

Daikon is written in Java 1.5 (also known as Java 5).  In order to
compile Daikon, you need a Java 1.5 compiler such as javac on your path.
@cindex Jikes compiler
@cindex javac compiler, overriding
@cindex Java compiler, specifying
To override the default Java compiler (javac), create a
@file{Makefile.user} file in the @file{daikon/} directory and add a line
like the following.
@example
JAVAC ?= jikes -g +E +F
@end example

In order to compile Daikon, you need the C preprocessor
@command{cpp}, which is used to convert each @file{.jpp} file in the
distribution into multiple @file{.java} files, which are then compiled.
If you have a C compiler, you almost certainly have @command{cpp}.
If you do not have @command{cpp} (or @command{gcc}, which can emulate
@command{cpp} via @samp{gcc -E}), you may run @samp{make avoid-jpp}, in
which case changes to @code{.jpp} files will not be reflected in the
@file{.java} files or the compiled @file{.class} files.  (The purpose
of the @file{.jpp} files is to avoid code duplication by placing
common code in a single file, then generating other files that need to
include that common code.)

To make the documentation (via @samp{make -C $inv/doc}), you will need a
recent version of makeinfo.
@c Info as of November 2005
Makeinfo version 4.7 is known to work, but makeinfo version 4.1 is known
to fail.

For more information about compiling Daikon, see the comments in the Makefiles.

@cindex Windows, compiling
To compile Daikon on Windows, the best approach is to install the Cygwin
toolset (available at @uref{http://sources.redhat.com/cygwin/}), which
contains everything you need to compile and run Unix programs under
Windows.  You can install Cygwin by simply running the program found
at @uref{http://sources.redhat.com/cygwin/setup.exe}.

When setting up environment pathname variables under Windows/Cygwin
(such as @command{JDKDIR} or @command{CLASSPATH}) make sure that the
pathname is specified in Unix format (e.g., @samp{/cygdrive/c/daikon}
rather than @samp{C:\daikon}).  Cygwin expects Unix style pathnames
and the Makefile will convert them to Windows pathnames when necessary
(such as when using Windows programs such as Java).  The
@command{CLASSPATH} environment variable should use colons (:) rather
than semicolons (;) as a separator.  Using windows pathnames or
separators is a common source of errors that will result in odd error
messages and build failures.

@cindex MacOSX, compiling
Compiling Daikon on MacOSX is relatively straightforward.  In addition
to the standard settings, add an environment variable that specifies
the location of the Java @samp{classes.jar} file (@samp{classes.jar} performs a
similar function to the more standard @samp{rt.jar}.  Normally the
file is found in @samp{/System/Library/Frameworks} under the appropriate Java
version.  The following example is for the standard install of
Java 1.5 on MacOSX:

@example
  export ORIG_RT=/System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Classes/classes.jar
@end example
  
@node    CVS repository, Using Eclipse, Compiling Daikon, Extending Daikon
@section CVS repository
@cindex CVS repository

The layout of the Daikon CVS repository differs slightly from that of
the distribution.  For example, the top-level directory is named
@file{invariants/} instead of @file{daikon/}, and the subdirectory with
helper programs is named @file{scripts/} instead of @file{bin/}.

For information about obtaining Daikon via CVS, see
@uref{http://groups.csail.mit.edu/pag/daikon/mit/}.


@node    Using Eclipse, New invariants, CVS repository, Extending Daikon
@section Using Eclipse
@cindex Eclipse

[To be improved.]

Here is one way to use Eclipse to edit Daikon.

First, make sure that Daikon builds cleanly from the command line.

File > Import > General > Existing Projects into Workspace

Choose the ``java'' directory of your Daikon checkout

Project > properties > Java build path:
 libraries : ``add external jars'' everything in the lib/ directory,
   plus also the tools.jar file in the lib/ directory of your JDK.
   (I'm not sure why, but ``add jars'' doesn't show all .jar files in the directory.)
  
 Source: 
   add ``Daikon'', remove ``Daikon/src''.
   Default output folder: change from ``Daikon/bin'' to ``Daikon''.


@node    New invariants, New derived variables, Using Eclipse, Extending Daikon
@section New invariants

@cindex new invariants
@cindex adding new invariants

You can easily write your own invariants and have Daikon check them,
in addition to all the other invariants that are already part of Daikon.
Adding a new invariant to Daikon requires writing one Java class, adding
a line to another file to inform Daikon of the new
class, and recompiling Daikon.

The file @file{java/daikon/inv/unary/scalar/Positive.java} in the
Daikon distribution contains a sample invariant.  This invariant is
true if the variable is always positive (greater than zero).  This
invariant is subsumed by other invariants in the system; it is provided
only as a pedagogical example.  To enable the invariant, uncomment the
appropriate line in @code{Daikon.setup_proto_invs()}, then recompile
Daikon.


A Java class defining an invariant is a concrete subclass of one of
the following abstract classes:
@table @code
@item SingleScalar
Invariants over a single numeric (scalar) variable,
such as ``x != 0''.
@item TwoScalar
Invariants over two numeric variables, such as ``y
= abs(x)''.
@item ThreeScalar
Invariants over three numeric variables, such as
``z = ax + by + c''.
@item SingleSequence
Invariants over one sequence (array)
variable, such as ``a[] contains no duplicates''.
@item TwoSequence
Invariants over two sequences, such as ``a[] is a
subsequence of b[]''.
@item SequenceScalar
Invariants over a scalar and a sequence, such
as ``x is a member of a[]''.
@end table
@noindent
A complete list of invariants appears in @samp{Daikon.setup_proto_invs()}.

Daikon's invariants are first instantiated, then are presented samples
(tuples of values for all the variables of interest to the invariant;
this might be a 1-tuple, a 2-tuple, or a 3-tuple) in turn.  If any
sample falsifies the invariant, the invariant destroys itself.  All
remaining invariants at the end of the program run can be reported as
likely to be true.

The key methods of the new invariant class @var{InvName} are
@table @code
@item protected @var{InvName}(PptSlice ppt)
Constructor for class @var{InvName}.  Should only be called from 
@code{instantiate_dyn}.
Its typical implementation is
@example
super(ppt);
@end example

@item protected Invariant instantiate_dyn (PptSlice slice)
Returns an invariant of this class on the specified slice.  Its implementation
is almost always
@example
return new InvName(slice);
@end example

@item public static @var{InvName} get_proto()
Returns the prototype invariant used to create other invariants.  Its
typical implementation is
@example
if (proto == null)
  proto = new InvName (null);
return (proto);
@end example

@item public boolean enabled() 
Returns whether or not this invariant is enabled.  Its implementation is
almost always
@example
return dkconfig_enabled;
@end example

@item public boolean instantiate_ok (VarInfo[] vis)
Returns whether or not it makes sense to instantiate this invariant
over the specified variables.  If not present, the invariant is
created over all comparable variables of the correct types.

@item public InvariantStatus check_modified (..., int count)
Presents a tuple of values to the invariant; these are the first 
N arguments, which have appropriate types for the particular invariant.  
The @code{count} argument indicates how many samples have this value.  
For example, three calls to
@code{check_modified} with a @code{count} parameter of 1 is equivalent to
one call to @code{check_modified} with a @code{count} parameter of 3.
Returns whether or not the sample is consistent with the invariant.
Does not change the state of the invariant.

@item public InvariantStatus add_modified (..., int count)
Similar to @code{check_modified} except that it can change the state
of the invariant if necessary.  If the invariant doesn't have any
state, then simply calls @code{check_modified}.

@item protected double computeConfidence ()
Returns the probability that the observed data could not have happened by
chance alone.  The result usually falls between 0 and 1, where 0 means
the values seen so far certainly happened by chance and 1 means they
could never have happened by chance.  The method may also return one of
the following constants in the @code{Invariant} class (see the class for
documentation): @code{CONFIDENCE_JUSTIFIED},
@code{CONFIDENCE_UNJUSTIFIED}, @code{CONFIDENCE_NEVER}.

For example, suppose your new invariant has a 50% chance of being true
by chance for each sample.  (``x is even'' is an example of such an
invariant.)  Then a reasonable body for @code{computeConfidence} would
be
@example
return 1 - Math.pow(.5, ppt.num_samples());
@end example
@noindent
If 5 values had been seen, then this implementation would return 31/32,
which is the likelihood that all 5 values seen so far were even purely
by chance.  Invariants are only printed if their probabilities are small
enough (by default, less than .01).

@item public String format ()
@itemx public String repr ()
@itemx public String format_using (OutputFormat format)
Returns a high-level printed representation of the
invariant, for user output.  @code{format} produces ``normal'' output, while
the @samp{repr} formatting routine produces low-level, detailed output for 
debugging.  When first writing
an invariant, you can make @code{repr} and @code{format_using}
simply call @code{format}, then fix up the
implementations for the different output formats later as needed.
See also @ref{New formatting for invariants}.
@end table

After the invariant is written, add a call to its @code{get_proto}
method in the @code{Daikon.setup_proto_invs} method.

@node    New derived variables, New formatting for invariants, New invariants, Extending Daikon
@section New derived variables

@cindex derived variable
@cindex variable, derived
@cindex adding new derived variables
@cindex new derived variables

A derived variable is an expression that does not appear in the source
code as a variable, but that Daikon treats as a variable for purposes
of invariant detection.  For instance, if there exists an array
@samp{a} and an integer @samp{i}, then Daikon introduces the derived
variable @samp{a[i]}.  This permits detection of invariants over this
quantity.

(Describing how to create new variety of derived variable is still to
be written.  For now, see the derived variables that appear in the Java
files in directory @file{$DAIKONDIR/java/daikon/derive/}.)


@node    New formatting for invariants, New front ends, New derived variables, Extending Daikon
@section New formatting for invariants

@cindex output format, defining new
@cindex new output formats
@cindex adding new output formats

Daikon can print invariants in multiple formats
(@pxref{Invariant syntax,,,./daikon,Daikon User Manual}).

To support a new output format, you need to do two things:
@itemize @bullet
@item
In @code{daikon.inv.Invariant.OutputFormat}, add a new static final
field and also update the @code{get} method.
@c (if it returns null, then you
@c will get an ``Unknown output format'' error message when you run Daikon.)
@item
In every subclass of @code{Invariant}, edit the
@code{format_using} method to handle the new @code{OutputFormat}.
@end itemize


@node    New front ends, New suppressors, New formatting for invariants, Extending Daikon
@section New front ends

@cindex front end, writing

A front end for Daikon converts data into a form Daikon can process,
producing files in Daikon's input format --- data trace declarations and
records.  For more information about these files, see @ref{File
formats}.

The data traces can be obtained from any source.  For instance, front
ends have been built for stock data, weather forecasts, truck weight
data, and spreadsheet data (@pxref{convertcsv.pl,,,./daikon,Daikon User
Manual}), among others.  More often, users apply a programming language
front end (also called an ``instrumenter'') to a program, causing
executions of the program to write files in Daikon's format.  (For
information about existing front ends, see @ref{Front
ends (instrumentation),,,./daikon,Daikon User Manual}.)  When a general front end is not
available, it is possible to manually instrument a specific program so
that it writes files in Daikon's format.  The resulting instrumented
program is very similar to what an instrumenter would have created, so
this section is relevant to both approaches.

Conceptually, instrumentation is very simple.  For each program point
(say, a line of code or the entry or exit from a procedure) at which you
wish to detect invariants, the front end must arrange to create a
declaration (@pxref{Declarations}) that
lists the variables in scope at that program point, and the front end
must arrange that execution creates a data trace record (@pxref{Data
trace records}) for each execution of that
program point.  Conventionally, the way to create a data trace record is
to insert a @code{printf} (or similar) statement that outputs the current
values of the variables of interest.


@menu
* Example instrumented Java program::  
* Instrumenting C programs::    
@end menu

@node    Example instrumented Java program, Instrumenting C programs, New front ends, New front ends
@subsection Example instrumented Java program

@cindex instrumenting Java programs
@cindex Java programs, instrumenting

This section gives an example of how an instrumenter for Java might
work; other languages are analogous.
Suppose we wish to instrument file @file{Example.java}.
@example
class Example @{
  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    if (b)
      x++;
    return x*x;
  @}
@}
@end example

The @file{.decls} file might look like the following.
@example
DECLARE
Example.squar:::ENTER
x
int
int
1
b
boolean
int
2

DECLARE
Example.squar:::EXIT
x
int
int
1
b
boolean
int
2
return
int
int
1
@end example

The instrumented @file{.java} file might look like the following.
This example does not compute the ``modified bits'', but simply sets
them all to 1, which is a safe default.
@example
class Example @{
  static @{
    daikon.Runtime.setDtraceMaybe("daikon-output/StackAr.dtrace");
  @}

  // Return either the square of x or the square of (x+1).
  int squar(int x, boolean b) @{
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::ENTER");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    if (b)
      x++;

    int daikon_return_value = x*x;
    synchronized (daikon.Runtime.dtrace) @{
      daikon.Runtime.dtrace.println();
      daikon.Runtime.dtrace.println("Example.squar:::EXIT");
      daikon.Runtime.dtrace.println("x");
      daikon.Runtime.dtrace.println(x);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("b");
      daikon.Runtime.dtrace.println(b ? 1 : 0);
      daikon.Runtime.dtrace.println(1);  // modified bit
      daikon.Runtime.dtrace.println("return");
      daikon.Runtime.dtrace.println(daikon_return_value);
      daikon.Runtime.dtrace.println(1);  // modified bit
    @}

    return daikon_return_value;
  @}
@}
@end example


@node    Instrumenting C programs,  , Example instrumented Java program, New front ends
@subsection Instrumenting C programs

@cindex C programs, instrumenting
@cindex instrumenting C programs

Daikon comes with two front ends for the C language:  Kvasir
(@pxref{Kvasir,,,./daikon,Daikon User Manual}) and Mangel-Wurzel
(@pxref{Mangel-Wurzel,,,./daikon,Daikon User Manual}).  Each has its limitations.
Kvasir only works under the Linux operating system, and it works only on
``x86'' (Intel 386-compatible) processors.  Mangel-Wurzel 
lacks some tracing features related to arrays
and nested structs, and requires the user to purchase Purify.

You may wish to infer invariants over C programs running on other
platforms; for instance, you want a robust C front end that works under
Microsoft Windows.  This section will help you to either write such a
front end or to hand-instrument your program to produce output that
Daikon can process.

We welcome additions and corrections to this part of the manual.  And,
if you write a C instrumenter that might be of use to others, please
contribute it back to the Daikon project.


A front end for C (or any other language) performs two tasks.  It
determines the names of all variables that are in scope at a particular
program point, and it prints the values of those variables each time the
program point executes.

Determining the names of the variables is straightforward.  It requires
either parsing source code or parsing a compiled executable.  In the
latter case, the variables can be determined from debugging information
that the compiler places in the executable.

The challenge for C programs is determining the values of variables at
execution time:  for each variable, the front end must determine whether
the variable's value is valid, and how big the value is.

@cindex valid values
@cindex invalid values
@cindex nonsensical values
@cindex uninitialized variables
@cindex deallocated pointers

A front end should print only variables that have @emph{valid} values.
Examples of invalid values are variables that have not yet been
initialized and pointers whose content has been deallocated.  (A pointer
dereference, such as @samp{*p} or @samp{p->field}, can itself
be to uninitialized and/or deallocated memory.)  Invalid values should
be printed as ``nonsensical'' (@pxref{Data trace
records}).

It is desirable to print ``nonsensical'' rather than an invalid value,
for two reasons.  First, outputting nonsense values can degrade
invariant detection; patterns in the valid data may be masked by noise
from invalid values.  Second, an attempt to access an invalid value can
cause the instrumented program to crash!  For instance, suppose that
pointer @samp{p} is not yet initialized --- the pointer value refers to
some arbitrary location in memory, possibly even an address that the
operating system has not allocated to the program.  An attempt to print
the value of @samp{*p} or @samp{p->field} will result in a segmentation
fault when @samp{*p} is accessed.  (If you choose never to dereference a
pointer while performing instrumentation, then you do not need to worry
about invalid references.  However, you will be unable to output any
fields of a pointer to a struct or class, making your front end less
useful.  You will still be able to output fields of a regular variable
to a struct or class, but most interesting uses of structs and classes
in C and C++ are through pointers.)

C relies on the programmer to remember which variables are valid, and
the programmer must take care never to access invalid variables.
Unfortunately, there is no simple automatic way to determine variable
validity for an arbitrary C program.  (Languages with automatic memory
management, such as Java, do not pose these problems.  All variables
always have an initial value, so there is no danger of printing
uninitialized memory, though the initial value may not be particularly
meaningful.  Because pointed-to memory is never deallocated, all
non-null pointers are always valid, so there is no danger of a
segmentation fault.)

An instrumenter needs information about validity of variable values.
This could be obtained from the programmer (which requires work on the
part of the user of Daikon), or obtained automatically by creating a new
run-time system that tracks the information (which requires a more
sophisticated front end).

In addition to determining which variables are uninitialized and which
pointers are to allocated memory, there are additional problems for a C
front end.  For example, given a char pointer @samp{*c}, does it point
to a single character, or to an array of characters?  If it points to an
array of characters, how big is that array?  And for each element of the
array, is that element initialized or not?


The problem of tracking C memory may seem daunting, but it is not
insurmountable.  There exist many tools for detecting or debugging
memory errors in C, and they need to perform exactly the same memory
tracking as a Daikon front end must perform.  Therefore, a Daikon front
end can use the same well-known techniques, and possibly can even be
built on top of such a tool.  For instance, one C front end, named Kvasir, is
built on top of the Valgrind tool (@uref{http://valgrind.org/}),
greatly reducing the implementation effort.  Valgrind only works under
Linux, but a C front end for another platform could build on a similar
tool; many other such tools exist.


There are two basic approaches to instrumenting a C program (or a
program in any other language):  instrument the source code, or
instrument a compiled binary representation of the program.  In each
case, additional code that tracks all memory allocations, deallocations,
writes, and reads must be executed at run time.  Which approach is most
appropriate for you depends on what tools you use when building your C
instrumentation system.


In some cases, it may not be necessary to build a fully general C
instrumentation system.  You may be able to craft a smaller, simpler
extension to an existing program --- enabling that program (only) to
produce files for Daikon to analyze.

For instance, many programs use specialized memory allocation routines
(customized versions of @code{malloc} and @code{free}), in order to
prevent or detect memory errors.  The information that such libraries
collect is often sufficient to determine which variable values should be
printed, and which should be suppressed in favor of printing
``nonsensical'' instead.


The presence of memory errors --- even in a program that @emph{appears}
to run correctly --- makes it much harder to create Daikon's output.
Therefore, as a prerequisite to instrumenting a C program, it is usually
a good idea to run a memory checker on that program and to eliminate any
memory errors.

@c If you don't have a memory checking tool, then what platform are you
@c on??  But you could use some Very simple half-measures such s zeroing
@c out memory when it is allocated (always use @code{calloc}, never
@c @code{malloc}) and when it is deallocated, and zeroing out pointers
@c when they are freed.

@c An example of compiler (not runtime) infrastructure for Microsoft
@c Windows is Phoenix:
@c http://research.microsoft.com/phoenix/




@node New suppressors, System.exit, New front ends, Extending Daikon
@section New suppressors

@cindex adding new suppressors
@cindex new suppressors
@cindex suppressors, adding new

As mentioned in @ref{Daikon internals}, one way to make Daikon more
efficient, and to reduce clutter in output to the user, is to reduce the
number of redundant invariants of various kinds.  This section describes
how to add a new suppressor relation, such that if invariant A implies
B, B is not instantiated or checked as long as A holds, saving time and
space.  Suppression implications use some terminology.  A
@emph{suppressor} (defined in the class @code{NISuppressor}) is one of a
set of invariants (@code{NISuppression}) that imply and suppress a
@emph{suppressee} invariant (@code{NISuppressee}).  The set of all of
the suppressions that suppress a particular suppressee is stored in the
class @code{NISuppressionSet}.

Adding a new suppression is straightforward when the invariants involved 
do not have any state.  Define the suppressee and
each of the suppressions that suppress it using the corresponding
constructors.  Add the method @code{get_ni_suppressions} to the class
of the invariant being suppressed and return the appropriate
suppression set.  Make sure that @code{get_ni_suppressions} always
returns the same suppression set (i.e., that storage to store
the suppressions is only allocated once).  Normally this is
done by defining a static variable to hold the suppression sets
and initializing this variable the first time that @code{get_ni_suppressions}
is called.

The following example defines suppressions for ``x == y'' implies
``x >= y'' and ``x > y'' implies ``x >= y''.

@example
private static NISuppressionSet suppressions = null;

public NISuppressionSet get_ni_suppressions() @{
  if (suppressions == null) @{
    NISuppressee = new NISuppressee (IntGreaterEqual);

    NISuppressor v1_eq_v2 = new NISuppressor (0, 1, IntEqual.class);
    NISuppressor v1_lt_v2 = new NISuppressor (0, 1, IntLessThan.class);

    suppressions = new NISuppressionSet (new NISuppression[] @{
      new NISuppression (v1_eq_v2, suppressee),
      new NISuppression (v1_lt_v2, suppressee),
    @});
  @}
  return (suppressions);
@}
@end example

For suppressions depending on the state of a particular invariant, each @code{Invariant} has an @code{isObviousDynamically(VarInfo[] vis)} method that is called once the state of other invariants has already been determined.  This method returns a non-null value if this invariant is implied by a fact that can be derived from the given @code{VarInfo}s.  

For example, suppose division was not defined for divisors smaller than 1.  The following example defines an obvious check for ``x <= c'' (where c < 1 is a constant) implies ``y % x == 0'', written in the Divides class.

@example
public DiscardInfo isObviousDynamically(VarInfo[] vis) @{
  DiscardInfo di = super.isObviousDynamically(vis);
  if(di != null) @{
    return di;
  @}

  VarInfo var1 = vis[0];

  PptSlice1 ppt_over1 = ppt.parent.findSlice(var1);

  if(ppt_over1 == null) @{
    return null;
  @}

  for(Invariant inv : ppt_over1.invs) @{            
    if(inv instanceof UpperBound) @{
      if(((UpperBound) inv).max() < 1) @{
        return new DiscardInfo(this, DiscardCode.obvious,
                               ``Divides is obvious when divisor less than one'');
      @}
    @}
  @}

  return null;
@}
@end example  

@node    System.exit,  , New suppressors, Extending Daikon
@section System.exit

The Daikon codebase does not call @code{System.exit()}, except in a
dummy main method that catches @code{TerminationMessage}, which is the
standard way that a component of Daikon requests the JVM to shut down.

The reason for this is that calling @code{System.exit()} is usually a
bad idea.  It makes the class un-usable as a subroutine, because it
might kill the calling program.  It can cause deadlock.  And it can
leave data in an inconsistent state (for example, if the program was in
the middle of writing a file, still held non-Java locks, etc.), because
the program has no good way of completing any actions that it was in the
middle of.  Therefore, it is better to throw an exception and let the
program handle it appropriately.  (This is true of instrumentation code
as well.)


@node    Debugging Daikon, Daikon internals, Extending Daikon, Top
@chapter Debugging Daikon

@cindex debugging Daikon

@menu
* Track logging::               
@end menu

This chapter describes some techniques that can be used for debugging
Daikon.  Because Daikon processes large amounts of data, using
a debugger can be difficult.  The following logging techniques provide
alternatives to using a debugger.

Daikon's logging routines are based on the @code{java.util.logging} utilities
(built into Java 1.4 and later).


@node Track logging,  , Debugging Daikon, Debugging Daikon
@section Track logging

@cindex logging
@cindex track logging

Often it is desirable to print information only about one or more specific 
invariants.  This is distinct from general logging because it concentrates
on specific invariant objects rather than a particular class or portion of Daikon.
This is referred to as @emph{Track} logging because it tracks particular
values across Daikon.

The @option{--track @var{class|class|...<var,var,var>@@ppt}} option to Daikon 
(@pxref{Daikon debugging options,,,./daikon,Daikon User Manual})
enables track logging.
The argument to the @option{--track} option supplies three pieces of information: 

@enumerate

@item The class name of the invariant (e.g., @code{IntEqual}).
Multiple class arguments can be specified separated by pipe symbols
(@samp{|}).

@item The variables that are used in the invariant (e.g., @code{return},
@code{size(this.s[])}).  The variables are specified in angle brackets
(@samp{<>}).

@item The program point of interest (e.g., 
@code{DataStructures.StackAr.makeEmpty()V:::ENTER}).  The program point
is preceded by an at sign (@samp{@@}).

@end enumerate

Each item is optional.
For example:
@example
IntEqual<x,y>@@makeEmpty()
LessThan|GreaterThan<return,orig(y)>@@EXIT99
@end example
Multiple @option{--track} switches can be specified. The class, program point,
and each of the variables must match one of the specifications in order
for information concerning the invariant to be printed.

Matching is a simple substring comparison.  The specified item must be
a substring of the actual item.  For instance, @code{LessThan} matches
both @code{IntLessThan} and @code{FloatLessThan}.

Program points and variables are specified exactly as they are seen in
normal Daikon invariant output.  Specifically, @code{Ppt.name} and
@code{VarInfo.name.name()} are used to generate the names for comparisons.

Invariants are not the only classes that can be tracked.  Any class name
is a valid entry.  Thus, for example, to print information about derived
sequence variables from sequence @code{this.theArray[]} and scalar
@code{x} at program point @code{DisjSets.find(int):::EXIT}, the tracking
argument would be:

@example
SequenceScalarSubscriptFactory<x,this.theArray[]>@@DisjSets.find(int):::EXIT
@end example

There are two configuration options that can customize the output.  The
option @option{daikon.Debug.showTraceback} will output a stack trace on
each log statement.  The option @option{daikon.Debug.logDetail} will cause
more detailed (and often voluminous) output to be printed.  For more
information, @ref{Configuration options,,,./daikon,Daikon User Manual}.

Note that all interesting information is not necessarily currently logged.
It will often be necessary to add new logging statements for the specific
information of interest (@pxref{Adding track logging}).
This is covered in the next section.

More detailed information can be found in the Javadoc for
@uref{http://pag.csail.mit.edu/daikon/download/jdoc/daikon/Debug.html,@code{daikon.Debug}}
and
@uref{http://pag.csail.mit.edu/daikon/download/jdoc/daikon/inv/Invariant.html,@code{daikon.inv.Invariant}}.

@menu
* Adding track logging::        
* Track log output::            
@end menu

@node Adding track logging, Track log output, Track logging, Track logging
@subsection Adding track logging

When you add a new invariant, derived variable, or other component to
Daikon, you should ensure that it supports track logging in the same way
that existing components do.  This section describes how to do so.

@emph{Track} logging is based
around the class name, program point name, and variables of interest.
Track logging methods accept these parameters and a string to be printed.
@file{Debug.java} implements the following basic log methods:

@example
log (String)
log (Class, Ppt, String)
log (Class, Ppt, Varinfo[], String)
@end example

The first uses the cached version of the @code{Class}, @code{Ppt}, 
and @code{VarInfo} that
was provided in the constructor.  The second uses the specified
variables and the @code{VarInfo} information from @code{Ppt}.  
The third specifies each variable explicitly.

When logging is not enabled, calling the logging functions can take a 
significant amount of time (because the parameters need to be evaluated and
passed).  To minimize this, a function @code{logOn()} is provided to see 
if logging is enabled.  It is recommended that code of the following form
be used for efficiency:

@example
if (Debug.logOn()) @{
  Debug.log (getClass(), ppt, "Entering routine foo");
@}
@end example

Track logging also can work with other loggers.  Each of the logging
methods has an alternative version that also accepts a logger as the
first argument.  In this case, normal track logging is performed if
the class, ppt, and vars match.  If they don't match, the same
information is logged via the specified logger.  For example:

@example
if (Debug.logOn || logger.isLoggable (Level.FINE)) @{
  Debug.log (logger, getClass(), ppt, "Entering routine foo");
@}
@end example

The above will print if either the tracking information matches or if the
specified logger is enabled.

Convenience methods are available for track logging invariants.  In this
case the class name, ppt, and variable information are all taken from the
invariant.  The available methods are:

@example
logOn()
logDetail()
log (String)
log (Logger, String)
@end example

These correspond to the @code{Debug} methods described above.  They are
the recommended way to log information concerning invariants.

Track logging also provides one additional level of detail.  The function
@code{logDetail()} returns whether or not more detailed information
should be printed.  This should be used for information which is not
normally interesting or especially voluminous output.  Often statements
using @code{logDetail()} should be commented out when not in active use.


@node Track log output,  , Adding track logging, Track logging
@subsection Track log output

Each call to a track log method will produce output in the same basic
format. Space for three variables is always maintained for consistency:

@example
@ daikon.Debug: <class>: <ppt>: <var1>: <var2>: <var3>: <msg>
@end example

If @code{showTrackback} is enabled, the traceback will follow each 
line of debug output.

Unfortunately, in ASCII text, the above can be a little difficult to read
because it normally doesn't line up very well.  A simple translator to
HTML exists that can be used to provide HTML formatted output.  This tool
is not completely tested, but seems to work reasonably well in most
situations.  The following instructions only apply to MIT, but the tool
is shipped in the scripts directory and can easily be setup elsewhere
as well.

@cindex log2html

Use the URL @uref{http://pag.csail.mit.edu/daikon/mit/log2html.php} to
access log2html.
It will ask you for a file of daikon output.  One good way to create this
file is to use the @command{tee} command.  For example:

@example
daikon [daikon args] | tee ~/daikon.out
@end example

Then specify that file to log2html.  Note that when supplying a filename
to log2html, you must expand @samp{~} yourself
since the webserver doesn't know who you are.  The result will contain
tables with the log output in them (all other output is unchanged).  Table
columns are based on the @samp{: } separator in the ASCII output.  If traceback
is enabled, another column is added showing where the log method was
called.  For example, the traceback column might contain:

@example
+PptSlice1.addInvariant
@end example

If you put your cursor over @code{PptSlice1.addInvariant} it will show
the exact line number in the source file where the log method was
called as part of the href.  If you click on the traceback it will
create an output file of type @samp{application/emacs} that contains an
@command{emacsclient} command to edit the related source file.  Most browsers
can be setup to execute a command to process these files (in Mozilla
this is done in the ``Navigator/Helper Applications'' section of
preferences).  The script @command{$inv/scripts/browser_emacs} will
correctly handle files of this type and bring up the appropriate file
in Emacs.  This could easily be changed to support other editors.
Note that as currently implemented this creates a possible security
hole (malicious non-editor commands could be executed) as no checking
is done on the validity of the command.

Clicking on the leading plus of the traceback information will show
the entire traceback.  For example:

@example
-PptSlice1.addInvariant
 PptSlice.flow_and_remove_falsified
 PptSlice1.add
 PptTopLevel.add
 PptTopLevel.add_and_flow
 FileIO.process_sample
 FileIO.read_data_trace_file
 FileIO.read_data_trace_files
 Daikon.process_data
 Daikon.main
@end example

The same capabilities (showing the line number, bringing up the buffer
in emacs) exist on each of the frames in the traceback.  The detailed
traceback can be hidden by clicking on the leading @samp{-} on the first
frame.  Note that the current state of what tracebacks are expanded is
kept in a file named the same as your Daikon output file with
@file{.state} appended.  For example, the state file for
@file{~/daikon.out} is @file{~/daikon.out.state}.  This file must be
world writable for log2html to work correctly.


@node    Daikon internals, Testing, Debugging Daikon, Top
@chapter Daikon internals

@cindex Daikon internals
@cindex efficiency issues
@cindex optimizations

@menu
* Avoiding work for redundant invariants::  
* Dataflow hierarchy::          
* Equality optimization::       
@end menu

This chapter describes some of the techniques used in Daikon to make
it efficient in terms of time and space needed.  These techniques can
be enabled or disabled at the Daikon command line, as described in
@ref{Running Daikon,,Running Daikon,./daikon,Daikon User Manual}.

@node    Avoiding work for redundant invariants, Dataflow hierarchy, Daikon internals, Daikon internals
@section Avoiding work for redundant invariants

@cindex non-instantiation of invariants
@cindex non-checking of invariants
@cindex non-printing of invariants

Daikon reduces runtime and memory by avoiding performing work for
redundant invariants that provide no useful information to the user.
There are three basic types of optimization that can be performed for
uninteresting invariants:  non-instantiation, suppression, and
non-printing.

@emph{Non-instantiation} prevents the creation of an invariant because
the invariant's truth value is statically obvious (from the semantics
of the programming language), no matter what values may be seen at run
time.  Two examples are ``A[i] is an element of A[]'' and ``size(A[])
>= 0''.  Non-instantiation is implemented by the by the
@code{isObviousStatically} method.
With the equality sets optimization (@pxref{Equality optimization}),
non-instantiation can only happen if all equality permutations are
statically obvious.  Note that @code{isObviousStatically} should 
be used only for invariants that are known to be true.  Other code
presumes that any statically obvious invariants are true and can
be safely presumed when determining if other invariants are redundant.

An invariant can be @emph{suppressed} if it is logically implied by some
set of other invariants (referred to as ``suppressors'').  A suppressed
invariant is not instantiated or checked as long as its suppressors
hold.  For example ``x > y'' implies ``x >= y''.  Suppression has some
limitations.  It cannot use as suppressors or suppress sample dependent
invariants (invariants that adapt themselves to the samples they see and
whose equation thus involves a constant such as ``x > 42'').
Suppression also cannot use relationships between variables.  For
example, it cannot suppress ``x[i] = y[j]'' by ``(x[] = y[]) ^ (i =
j)''.  Suppressor invariants can only use variables that are also in the
invariant that is being suppressed.  In this example, only invariants
using the variables ``x[i]'' and ``y[i]'' can be used as a suppressors.
See @ref{New suppressors} for more information.

@emph{Non-printing} is a post-pass that throws out any invariants that
are implied by other true invariants.  It is similar to suppression, but
has none of the limitations of suppression.  But since it is only run as
a post pass, it cannot optimize runtime and memory use as suppression can.
Non-printing should be used only in cases where suppression cannot.
Non-printing is implemented by @code{ObviousFilter}, which calls the
@code{isObviousDynamically} method on invariants.  The
@code{isObviousStatically} method is also used by the non-printing
checks; it can be called at the end without reference to equality sets.

More detail can be found in the paper ``Efficient incremental algorithms
for dynamic detection of likely invariants'' by Jeff H. Perkins and
Michael D. Ernst, published in FSE 2004; the paper is available from
@uref{http://pag.csail.mit.edu/pubs/invariants-incremental-fse2004-abstract.html}.

@node    Dataflow hierarchy, Equality optimization, Avoiding work for redundant invariants, Daikon internals
@section Dataflow hierarchy

@cindex dataflow hierarchy
@cindex hierarchy

Dataflow hierarchy is a means to relate variables in different program
points in a partial ordering.  Variables in program point X are
related to variables in another program point Y by a ``flow'' relation
if every sample seen of X's variables is also meant to be seen at Y.
Y is called a parent program point of X.  For example, all the field
variables in the @code{:::ENTER} program point of a method in class C relate to
the field variables in the @code{:::CLASS} program point of C.  This is because
the state of C, when in context at the entry @code{:::ENTER} program point, is
also in context at the @code{:::CLASS} program point.  Any invariant that holds
true on a parent program point must hold on the child program point.
The purpose of dataflow hierarchy is to reduce the presence of
redundant invariants by only keeping invariants at the highest parent
at which they apply.  This saves both time and space.

There are many ways that program points can be connected.  Daikon
provides for four ways.  First, @code{:::CLASS} program points are parents of
all their method program points.  Second, between two classes that are
related by inheritance, corresponding program points relate --- for
example, @code{java.util.Vector:::CLASS} is a child of
@code{java.util.List:::CLASS}.  Third, when a program point contains
variables of a type whose @code{:::CLASS} program point is also available to
Daikon, the former program point's variables relate to the latter
program point's @code{:::CLASS} method.  For example, if X.y is of type Y, and
Y contains fields a and b, X.y, X.y.a and X.y.b relate to
Y.this, Y.b and Y.a.  Fourth, variables at @code{:::ENTER} program
points are related to the ``orig'' versions at @code{:::EXIT} program points.

When using Daikon, the above four ways of relations in the dataflow
hierarchy will result in some true invariants that are not reported at
some program points.  However, the invariant will be present in some
parent program point.  Dataflow hierarchy is enabled by default, but
can be disabled by the @option{--nohierarchy} flag.  When dataflow is enabled,
the only samples that are examined by Daikon are the @code{:::EXIT} program
points (plus ``orig'' variables) since these contain a complete view of
the data.

@node    Equality optimization,  , Dataflow hierarchy, Daikon internals
@section Equality optimization

@cindex equality optimization

When N variables are equal within a program point there will be
N(N-1)/2 pairwise invariants to represent the equality within the
equal variables, and N copies of every other invariant.  For example,
if a, b, and c are equal, then ``a == b'', ``a == c'', ``b == c'' will be
reported as pairwise invariants, and ``odd(a)'', ``odd(b)'' and ``odd(c)''
will be reported.  If the variables will always be equal, then
reporting N times the invariants is wasteful.  Daikon thus treats
equality specially.

Each group of variables that are equal from the start of inferencing
are placed in @emph{equality sets}.  An equality set can hold an
arbitrary number of variables, and replaces the O(N^2) pairwise
equality invariants.  Every equality set has a leader or
@emph{canonical} representation by a variable in the set.
Non-equality invariants are only instantiated and checked on the
leader.  When printing invariants, Daikon reports only invariants on
the leader.  The user can easily determine that ``odd(a)'' and ``a == b''
imply ``odd(b)''.  Equality optimization can be turned off at the 
command line with the @option{--noequality} flag.


@node    Testing, Historical, Daikon internals, Top
@chapter Testing

@cindex testing Daikon

Daikon has two sets of tests: unit tests (@pxref{Unit testing}) and
regression tests (@pxref{Regression tests}).  If there
are any differences between the expected results and the ones you get,
don't check in your changes until you understand which is the desired
behavior and possibly update the goals.

The Daikon distribution contains unit tests, but not regression tests
(which would make the distribution much larger).  The regression tests
appear in Daikon's CVS repository.

@menu
* Unit testing::                
* Regression tests::            
@end menu

@node    Unit testing, Regression tests, Testing, Testing
@section Unit testing

@cindex unit testing
@cindex new unit tests
@cindex adding new unit tests

The unit tests are found in @file{invariants/java/daikon/test/}; they use
the JUnit unit testing framework.  They take a few seconds to run.  They
are automatically run each time you compile Daikon (by running
@samp{make} in @file{$inv/java} or any of its subdirectories).  You can
also run them explicitly via @samp{make unit}.  When you write new code
or modify old code, please try to add unit tests.

@menu
* Invariant format testing::    
* Sample Testing::              
@end menu

@node    Invariant format testing, Sample Testing, Unit testing, Unit testing
@subsection Invariant format testing

This tests the formatting of invariants with specified input.  The
tests are configured in the file @file{InvariantFormatTest.commands} under
@file{daikon/test/}.  Make sure the @file{InvariantFormatTest.commands} file is
in the classpath when this tester is run or the tester will not work.
(It will just tell you that the file is not in the classpath.)

The file is formatted as follows:
@example
<fully qualified class name> [<instantiate args>]
<type string>
<goal string>+ <- 1 or more goal strings
<sample>* <- 0 or more samples
@end example

The file format should be the same regardless of blank or commented
lines except in the samples area. No blank lines or comments should
appear after the goal string before the first sample or between parts
of samples (these lines are used currently to determine where samples
lists end). This will be remedied in a future version of the tester.

@table @code
@item Instantiate args
These are optional additional arguments to the static
instantiate method of the class.  Each argument consists of the type (boolean
or int) followed by the value.  For example:
@example
    boolean true
    int 37 boolean false
@end example

@item Type string: 
A type string must consist of one or more of the following literals:
@samp{int}, @samp{double}, @samp{string}, @samp{int_array}, 
@samp{double_array}, or @samp{string_array}, separated by spaces. 
This string represents the
types that an invariant is supposed to compare For instance, a binary
integer comparison would have type string @samp{int int}.  A pairwise
sequence comparison would have type string @samp{int_array int_array}.

@item Goal string: 
The goal string must start with the prefix @samp{Goal }, and then 
continue with @samp{(<format type>): },
where format type is the format in which the invariant will
print. After this the representation of the invariant must occur. It
must represent the invariant result exactly as printed, even white
space is significant (as proper formatting should be correct down to
the whitespace). The first variable (the one corresponding to the
first type in the type string) corresponds with @samp{a}, the second with
@samp{b} and so on. Format the type string accordingly. (In samples, the
value of @samp{a} is read first, possibly followed by @samp{b}, and then
possibly @samp{c}, depending on the arity of the invariant.)

@example
Example:
Type string, Goals
 |             |
\|/            |
int           \|/
Goal (daikon): a >= -6
Goal (java): a >= -6
Goal (esc): a >= -6
Goal (ioa): a >= -6
Goal (jml): a >= -6
Goal (simplify): (>= |a| -6)
@end example

Note that the spacing on the goal lines is exact, that is, no extra
spaces are allowed and no spaces are allowed to be missing. So the
exact format is again:
@example
Goal<1 space>(<format name>):<1 space><goal text>
@end example

@item Samples: 
Values formatted according to the type string, one value per
line Make sure that the samples provided are actually instances of that
particular invariant (That is, if the desired invariant is ``a < b'', then
the first number of each sample better be less than the second) 

@c The below is not necessary since we don't check this before formatting
@c 
@c Also be
@c sure to have enough samples to ensure the invariant is apparent (and
@c probable) to Daikon (6-8 will do for most binary integer comparisons,
@c 1-3 for array-based comparisons) Example: Formatting for
@c samples of a binary integer comparison

Arrays and strings must be formatted according to the Daikon dtrace file
convention (for a full description, @pxref{File formats}.  This
states that arrays must be surrounded in brackets (start with @samp{[}, end
with @samp{]}), and entries must be separated by a space.  Strings must be
enclosed in quotes (@samp{"}). Quotes within a string can be represented by the
sequence @samp{\"}.

For example:
@example
[1 2 3 4 5] - an array with the elements 1, 2, 3, 4, 5
"aString" - a string
"a string" - also legal as a string
"\"" - the string with the value "
["a" "b" "c"] - an array of strings

int int        <- type string
Goal: a < b    <- goal string, no comment/blank lines after this
1              <- or before this
2
2              <-|__ Pair of values (a = 2 , b = 3)
3              <-|
@end example

Other examples are in the existing test file 
(@file{InvariantFormatTest.commands}).
@end table

The output of a test run can be converted into goals by using the
@option{--generate_goals} switch to the tester as follows:
@example
java daikon.test.InvariantFormatTester --generate_goals
@end example
Note that this test is included in the set of tests performed by the
master tester, and so it is not necessary to separately run this test
except to generate goal files.

Furthermore, this framework cannot parse complex types from files
unless they contain a @code{public (Object) valueOf(String s)}
function. Otherwise the program has no was of knowing how to create
such an object from a string. All primitives and the String type are
already recognized.

@node    Sample Testing,  , Invariant format testing, Unit testing
@subsection Sample Testing

Sample testing tests various components of Daikon as samples are being
processed.  A file (normally @file{daikon/test/SampleTester.commands}) 
specifies a decls file to use, the samples for each ppt/var, and assertions
about Daikon's state (such as whether or not a particular invariant exists).

Each line of the file specifies exactly one command.  Blank lines and
leading blanks are ignored.  Comments begin with the number sign (@samp{#}) and
extend to the end of the line.  The type of command is specified as the
first token on the line followed by a colon.  The supported commands
are:

@deffn {SampleTester Command} decl: decl-file
This command specifies the declaration file to use.  This is a normal
decls file that should follow the format defined in the user manual.
@end deffn

@deffn {SampleTester Command} ppt: ppt
This command specifies the program point that will be used with following
vars, data, and assert commands.  The program point should be specified 
exactly as it appears in the decls file.
@end deffn

@deffn {SampleTester Command} vars: var1 var2...
Specifies the variables that will be used on following data lines.
Each variable must match exactly a variable in the ppt.  Other
variables will be treated as missing.  
@end deffn

@deffn {SampleTester Command} data: val1 val2...
Specifies the values for each of the previously specified variables.  The
values must match the type of the variables.  A single dash (-) indicates
that a variable is missing.
@end deffn

@deffn {SampleTester Command} assert: assertion
Specifies an assertion that should be true at this point (@pxref{Assertions}).
The negation of an assertion can be specified by adding an exclamation
point before the assertion (for example: @code{!inv("x > y", x, y})).
@end deffn

@menu
* Assertions::                  
* Example file::                
@end menu

@node       Assertions, Example file, Sample Testing, Sample Testing
@subsubsection Assertions

Assertions are formatted like function calls: <name>(arg1, arg2, ...).
The valid assertions for the assert: command are:

@deffn Assertion inv format var1 ...

The inv assertion asserts that the specified invariant exists in the
current ppt.  The @var{format} argument is the result of calling 
@code{format()} on
the invariant.  This is how the invariant is recognized.  The remaining
arguments are the variables that make up the invariants slice.  These
must match exactly variables in the ppt.  The inv assertion returns true
iff the slice exists and an invariant is found within that slice that
matches @var{format}.

Optionally, @var{format} can be replaced by the fully qualified class name of
the invariant.  In this case, it is only necessary for the class to match.
@end deffn

More assertions can easily be added to @file{SampleTester.java} as required.

@node       Example file,  , Assertions, Sample Testing
@subsubsection Example file

The following is an simple example of sample testing.
@example
decl: daikon/test/SampleTesters.decls

ppt: foo.f():::EXIT35
  vars: x y z
  data: 1 1 0
  data: 2 1 0
  assert: inv("x >= y", x, y)
  assert: inv(daikon.inv.binary.twoScalar.IntGreaterEqual,x,y)
  assert: !inv("x <= y", x, y)
@end example

@node    Regression tests,  , Unit testing, Testing
@section Regression tests

@cindex regression tests

The regression tests run Daikon on many different inputs and compare
Daikon's output to expected output.  They take about an hour to run.

The regression tests appear in the @file{$inv/tests/} directory.  Type
@samp{make} in that directory to see a list of makefile targets.  The
most common target is @samp{make diffs}; if any resulting file has
non-zero size, the tests fail.  You do not generally need to do
@samp{make clean}, which forces re-instrumentation (a possibly slow
process) the next time you run the tests.

As when you install or compile Daikon, when you run the tests
environment variables @env{DAIKONDIR} (or @env{INV}, whose effect is
the same) and @env{JDKDIR} should be set.  Additionally, you should set
environment variable @env{JDKDIR} (or, equivalently, @env{JDK5DIR}) to the directory containing the Java
5 JDK@.

You should generally run the regression tests before checking it a
change (especially any non-trivial change).  If any of the regression
test diffs has a non-zero size, then your edits have changed Daikon's
output and you should not check in without carefully determining that
the changes are intentional and desirable (and you should update the
goal output files, so that the diffs are again zero).

There are several subdirectories under @file{$inv/tests/}, testing
different components of the Daikon distribution (such as Kvasir,
@pxref{Kvasir,,,./daikon,Daikon User Manual}).  Tests of the
invariant detection engine itself appear in
@file{$inv/tests/daikon-tests/}.

Each Makefile under @file{$inv/tests/} includes
@file{$inv/tests/Makefile.common}, which contains the logic for all of
the tests.  @file{Makefile.common} is somewhat complicated, if only
because it controls so many types of tests.


@menu
* Kvasir regression tests::     
* Adding regression tests::     
@end menu


@node Kvasir regression tests, Adding regression tests, Regression tests, Regression tests
@subsection Kvasir regression tests


Note on Kvasir tests: The Kvasir (Daikon C front-end) tests appear in the 
@file{$inv/tests/kvasir-tests} directory. These tests run Daikon to ensure 
that the Kvasir output is valid Daikon input. To run them, go to 
@file{$inv/tests/kvasir-tests} or any test sub-directory within here and run 
@samp{make summary-w-daikon}. If any tests return @samp{FAILED}, then
you should look at the appropriate @file{.diff} file. If you feel that the 
failure was actually a result of your Daikon changes and should be in fact 
correct output, then run @samp{make update-inv-goals} to update the Daikon
@file{invs.goal} file.



@node Adding regression tests,  , Kvasir regression tests, Regression tests
@subsection Adding regression tests

@cindex adding new regression tests
@cindex new regression tests

Most Daikon regression tests appear in @file{$inv/tests/daikon-tests}.  Each
test is placed in a separate directory.  That directory contains a
simple makefile and the goal files for the tests.  The source files
for the test are stored in @file{$inv/tests/sources}.  For example,
the @file{StackAr} directory contains the following files in CVS:
@example
Makefile
Stackar.spinfo-static.goal
StackAr.txt-daikon.goal
StackAr.txt-esc.goal
StackAr.txt-jml.goal
StackAr.txt-merge-esc.goal
StackAr.txt-merge-jml.goal
@end example

The @file{Makefile} must contain the following entries.

@table @samp
@item MAIN_CLASS
Dot separated fully qualified name of the class that contains the main
entry point for the test.  For example 
MAIN_CLASS := DataStructures.StackArTester.

@item include ../../Makefile.common
This includes the common portion of the test makefiles that does most
of the work.  See it for more information on the details of regression
testing.

@item instrument-files-revise:
A target that writes the list of files to instrument.  For example,
@example
instrument-files-revise:
    echo "DataStructures/StackAr.java" >| $@{INST_LIST_FILE@}
@end example

@end table

The goal files are the expected results of running daikon and its
associated tools.  The easiest way to create them is to simply create
empty versions of each.  They execute @samp{make diffs} to run the test and
produce results.  When the results are as expected execute 
@samp{make update-goals} to copy the results in to the goal files.  
Release the test by committing the goal files, Makefile, and source files
to the CVS repository.

The common makefile contains a number of other useful targets.  A brief
explanation of each can be found by executing @samp{make} (without a target).

The test can be added into the standard tests (either @samp{everything} or
@samp{quick} by adding the test the appropriate list in 
@file{$inv/tests/daikon-tests/Makefile}.


@node    Historical, File formats, Testing, Top
@chapter Analyzing historical versions of Daikon

@cindex CVS repository

@c Commands to run to distribute CVS:
@c   cd /afs/csail.mit.edu/group/pag/projects/invariants/.CVS/
@c   tar czf ~mernst/www/tmp/inv-cvs.tar.gz invariants
@c This took 40 minutes on 1/7/2005.
@c This took 20 minutes on 5/17/2006.
@c Tell those who receive the repository:
@c   You can find a copy of the Daikon CVS repository at
@c     http://pag.csail.mit.edu/~mernst/tmp/inv-cvs.tar.gz
@c   The compressed repository is about 800 Mbytes in size.
@c   Let me know when you have downloaded it, so I can remove the file.
@c 
@c   Please do not distribute it to anyone else.
@c 
@c   Before using it, carefully read the "Analyzing historical versions of
@c   Daikon" section of the Daikon Developer Manual.  Contact me if you have any
@c   problems, questions, or suggestions, so that I can correct problems both
@c   for you and for other users of Daikon or of the CVS repository.  This can
@c   also avoid misleading results that follow from incorrect assumptions about
@c   the system.
@c 
@c   Please let me know anything interesting you learn about Daikon.  Also point
@c   me at any publications that make use of Daikon, either as a test subject or
@c   as one step in your methodology, both for my own edification and so I can
@c   link to them from http://pag.csail.mit.edu/daikon/pubs/.
@c 
@c   I wish you the best of luck with your research!
@c Some recent distributions:
@c   1/07/2005  Miryung Kim <miryung@cs.washington.edu>
@c   9/19/2005  Barbara Ryder <ryder@cs.rutgers.edu>, Xiaoxia Ren <xren@cs.rutgers.edu>, Frank Tip <ftip@us.ibm.com>
@c   5/17/2006	Harry Xu <xug@cse.ohio-state.edu>
@c   7/26/2006  Gregory Kapfhammer <gkapfham@allegheny.edu>
@c  10/10/2006  Bob Evans <bobevans@agitar.com>
@c   7/29/2007  John Hatcliff <hatcliff@cis.ksu.edu>
@c   9/10/2007  Saurabh Sinha <saurabhsinha@in.ibm.com>, Vibha S Sinha <vibha.sinha@in.ibm.com>
@c   11/19/2007	Kevin Hoffman <kevinjohnhoffman@gmail.com>
@c   12/27/2008 zlmdunk@126.com

This section is intended primarily for researchers who are analyzing
historical versions of Daikon.  A number of researchers (for example, in
the testing community) use Daikon because it contains both a CVS
repository and a set of tests.  (The CVS repository can also be useful
to those making non-trivial changes to the Daikon code base, because the
CVS repository includes regression tests that are more extensive than
the unit tests that are included in the Daikon distribution.  However,
note that the Daikon distribution contains full source code, and we are
always happy to receive bug fixes and patches against the source code.)

If you wish access to the Daikon CVS repository, send mail to
@email{daikon-developers@@lists.csail.mit.edu}.  We appreciate it if you
let us know why you need it and what you want to use it for.  Also, we
request that you keep us appraised of any problems that you encounter or
discoveries that you make, and that you let us know of any publications
so that we can publicize them at
@uref{http://pag.csail.mit.edu/daikon/pubs/#daikon-testsubject}.
Also, please do not redistribute the repository without prior permission
from us.

We typically give you a copy of the CVS repository (about a 1GB download)
rather than remote access to the master CVS
repository.  This protects you from the possibility that our server is
down, or that we someday cut you off from access to the repository; you
are guaranteed to be able to reproduce your results.  It is also less
hassle for us (we don't have to create an account for you), and it is
less load on our servers (since researchers may wish to perform many CVS
operations).

This section points out some pitfalls for such researchers.  Although
these problems are easy to avoid, some previous published work has made
these mistakes; don't let that happen to you!

Recall that Daikon contains two sets of tests (@pxref{Testing}); you
should include both in any analysis of Daikon's tests.
(Or, if you can analyze only one of the two sets of tests, then clearly
explain that the regression tests are the main tests.)
The regression tests use Makefiles to avoid re-doing unnecessary work,
so any description of the time taken to run Daikon's tests should be a
measurement of re-running the tests after they have been run once, not
running them from a clean checkout or after a @samp{make clean} command.

Daikon intentionally does not contain tests for third-party libraries
that are included (sometimes in source form) in the Daikon distribution.
As one example, the @file{java/jtb/} directory
contains an external library.  Therefore, any measurement of Daikon's code
coverage should not include such libraries (or other libraries, some of
which are distributed as @file{.jar} files).

Be sure to see file @file{doc/www/mit/index.html} in the repository for
information about how group members use Daikon.  This file changes from
time to time --- for instance, it changed when a CVS branch was created
and later when development on it ceased (@pxref{Branches}).


@menu
* Branches::                    
@end menu

@node    Branches,  , Historical, Historical
@section Branches

@cindex branches, in CVS repository

The Daikon CVS repository contains two branches:  a main trunk and a
branch (named @samp{ENGINE_V2_PATCHES}) for version 2 of Daikon.

The CVS manual
@ifinfo
(@pxref{Branching and merging,,,cvs,CVS --- Concurrent Versions System})
@end ifinfo
@ifnotinfo
(see section @uref{http://ximbiot.com/cvs/manual/cvs-1.11.18/cvs_5.html,``Branching and merging''} of the manual @emph{CVS --- Concurrent Versions System})
@end ifnotinfo
describes CVS branches:

@quotation
  CVS allows you to isolate changes onto a separate line of development,
  known as a ``branch''.  When you change files on a branch, those changes
  do not appear on the main trunk or other branches.

  Later you can move changes from one branch to another branch (or the
  main trunk) by ``merging''.  Merging involves first running 
  @samp{cvs update -j}, to merge the changes into the working directory.
  You can then commit that revision, and thus effectively copy the
  changes onto another branch.
@end quotation

@c It is important that the following paragraph not contain any substrings
@c matching the regex /(Daikon version )[0-9]+(\.[0-9]+)*/,
@c because such phrases are automatically changed at the time of a release to
@c mention the most recent Daikon version, while the intent of this paragraph
@c is to discuss historical versions.
In early January 2002 (or perhaps in late 2001), we created the
@samp{ENGINE_V2_PATCHES} branch at the @file{invariants/java/daikon level} of
the Daikon CVS repository.  Primary development continued along the CVS
branch @samp{ENGINE_V2_PATCHES}, which we called
``Daikon version @c trick version updater
2''.  We
called the CVS trunk ``Daikon version @c trick version updater
3''; it was experimental, and very
few people ran its code or performed development on it.  Periodically,
all changes made to the branch would be merged into the trunk, as one
large checkin on the trunk.  Later, development on version 3 became more
common, some changes were merged from the trunk to the branch, and
version 2 was finally retired (and no more changes were made to the
branch) in December 2003.

A regular @samp{cvs checkout} gets the trunk.  The @option{-r} flag specifies a
branch.  For example, to get the branch as of June 9, 2002, one could do
@example
cvs -d $pag/projects/invariants/.CVS co -r ENGINE_V2_PATCHES \
    -D 2003/06/09 invariants/java/daikon
@end example

Some warnings about analyzing historical versions of Daikon:
@enumerate
@item
When analyzing 2002 (and at least parts of 2003) you should be careful
to use the branch, not the trunk.  Or, you could analyze both (but as a
single development effort, not as separate efforts).
@item
When a programmer periodically merged changes from the branch to the
trunk (or vice versa), that operation resulted in very large checkins.
The times at which these merges occurred is indicated in file
@file{invariants/java/daikon/merging.txt} in the repository; for
example, this happened 34 times during calendar year 2002.  CVS checkins
for the branch properly attribute and time-stamp the work that appears
as a single large checkin on the trunk.
@item
There may be long periods of time in the branch (respectively, the
trunk) with no checkins, but that does not necessarily indicate a lacuna
in development, as checkins might have occurred in the meanwhile in the
trunk (respectively, the branch).
@end enumerate



@node     File formats, Index, Historical, Top
@appendix File formats

@cindex file formats

This chapter contains information about the file format of Daikon's
input files.  It is of most information to those who wish to write a
front end, also known as an instrumenter (@pxref{Front ends
(instrumentation),,,./daikon,Daikon User Manual}).
A new front end enables Daikon to detect
invariants in another programming language.

Daikon's input is conventionally one or more @file{.dtrace} data trace
files.  (Another, optional type of input file for Daikon is a splitter
info file; @pxref{Splitter info file,,,./daikon,Daikon User Manual}.)
A trace file is a text file that consists of newline-separated
records.  There are two basic types of records that can appear in Daikon's
input:  program point declarations, and trace records.
The declarations describe the structure of the trace records.  The trace
records contain the data on which Daikon operates --- the run-time
values of variables in your program.

Each declaration names an instrumented program point and lists the
variables at that program point.  A program point is a location in the
program, such as a specific line number, or a specific procedure's entry or exit.
An instrumented program point is a place where the instrumenter may emit
a trace record.
A program point declaration
may be repeated, so long as the declarations match exactly (any
declarations after the first one have no effect).

A data trace record (also known as a ``sample'')
represents one execution of a program point.  The
record specifies the program point and gives the runtime values of each
variable.  The list of variables in the data trace record must be
identical to that in the corresponding declaration.  For a given program point,
the declaration must precede the first data trace record for the program
point.  It is not required that all the program point declarations
appear before any of the data trace records.  

There exist some other declaration-related records;
@xref{Declaration-related records}.


@menu
* Declarations in a separate file::  
* Conventions::                 
* Declarations::                
* Data trace records::          
* Example files::               
* Version 1 Declarations::      
@end menu


@node    Declarations in a separate file, Conventions, File formats, File formats
@section Declarations in a separate file


Instead of placing both declarations and data trace records in a single
file, it is permitted to place the declarations in one or more
@file{.decls} ``declaration files'' while leaving the data trace records
in the @file{.dtrace} file.  This can be convenient for tools that
perform a separate instrumentation step, such as dfepl (@pxref{dfepl,,,./daikon,Daikon User Manual})
and Mangel-Wurzel (@pxref{Mangel-Wurzel,,,./daikon,Daikon User Manual}).  Such a tool takes as
input a target program to be analyzed, and produces two outputs:  a
@file{.decls} file and an instrumented program.  Executing the
instrumented program produces a @file{.dtrace} file containing data
trace records for all the program points that appear in the
@file{.dtrace} file.  This approach works fine and is easier to
implement in certain situations, but has a few disadvantages.  It
requires the user to perform at least two steps --- instrumentation and
execution --- and the existence of two versions of the program
(instrumented and uninstrumented) can lead to confusion or extra work.
It is also more convenient to have a single file that contains all
information about a program, rather than multiple @file{.decls} files
that must be associated with the @file{.dtrace} file.


@node    Conventions, Declarations, Declarations in a separate file, File formats
@section File format conventions


Daikon files are textual, to permit easier viewing and editing by humans.
Each record is separated by one or more blank lines.
To permit easier parsing by programs, each piece of information in a record
appears on a separate line.

Outside a record, any line starting with a pound sign (#) or double
slashes (//) is ignored as a comment.  Comments are not permitted
inside a record.

@node Declarations, Data trace records, Conventions, File formats
@section Declarations

@cindex declaration format
@cindex .decls file

The trace file (or declaration file) first states the declaration file format
version number (@pxref{Declaration version}).
It may also specify some other information about the file
(@pxref{Declaration-related records}).
Then, it defines each program point and its variables.

Indentation is ignored, so it may be used to aid readability.
Fields with defaults can be omitted.

As a rule, each line of the declaration file is of the form
@code{<field-name> <field-value>}.

@menu
* Declaration-related records::  
* Program point declarations::  
* Variable declarations::       
@end menu


@node Declaration-related records, Program point declarations, Declarations, Declarations
@subsection Declaration-related records


@menu
* Declaration version::         
* Input-language declaration::  
* Variable comparability::      
* ListImplementors declaration::  
@end menu

@node Declaration version, Input-language declaration, Declaration-related records, Declaration-related records
@subsubsection Declaration version

The declaration version record must be the first record in the file.

The declaration version record is as follows:
@example
decl-version <version>
@end example
The current version is 2.0.

Previous versions (see @ref{Version 1 Declarations}) did not include a
version field and are identified by the lack of this field.


@node Input-language declaration, Variable comparability, Declaration version, Declaration-related records
@subsubsection Input-language declaration

You can specify the language in which the program was written with a
record of the form

@example
input-language <language>
@end example

The language string is arbitrary and is not currently used.


@node Variable comparability, ListImplementors declaration, Input-language declaration, Declaration-related records
@subsubsection Variable comparability

@cindex comparability, for variables
@cindex variable comparability
@cindex units of measurement, see variable comparability

The Variable comparability record indicates how the comparability field
of a variable declaration should be interpreted.

Its format is:
@example
var-comparability <comparability-type>
@end example
The possible values for @var{comparability-type} are @code{implicit} and
@code{none}.

``@code{implicit}'' means ordinary comparability as described in
@ref{Program point declarations}.  (The name @code{implicit} is retained
for historical reasons.)

This record is optional.  The @code{implicit} type is the default.


@node ListImplementors declaration,  , Variable comparability, Declaration-related records
@subsubsection ListImplementors declaration

This declaration indicates classes that implement the
@code{java.util.List} interface, and should be treated as sequences
for the purposes of invariant detection.  The syntax is as follows:

@example
ListImplementors
<classname1>
<classname2>
...
@end example

Each classname is in Java format (for example, ``java.util.LinkedList'').

The @samp{--list_type} command-line option to Daikon can also be used to
specify classes that implement lists; @xref{Options to control invariant
detection,,,./daikon,Daikon User Manual}.



@node Program point declarations, Variable declarations, Declaration-related records, Declarations
@subsection Program point declarations

The format of a program point declaration is:
@example
ppt <ppt-name>
<ppt-info>
<ppt-info>
...
<variable-declaration>
<variable-declaration>
...
@end example

The program point name can include any character.  In the declaration
file,
@c Replacing blanks by \_ isn't important on this line, but is important
@c on other lines.
blanks must be replaced by @code{\_}, and backslashes must be escaped as @code{\\}.
Program point names must be distinct.

The following information about the program point (@code{ppt-info}) can be specified:
@itemize 
@item @code{ppt-type <type>}

Specifies the @var{type} of the program point.  Possible program point
types are @code{point}, @code{class}, @code{object}, @code{enter}, 
@code{exit}, @code{subexit}.

@item @code{flags <flags>}

Specifies one or more flags for this ppt.  The possible flags are:
@code{static}, @code{enter}, @code{exit}, @code{private}, @code{return}.

@item @code{parent <relation-type> <parent-ppt-name> <relation-id>}

Specifies the program point hierarchy (@ref{Dataflow hierarchy}).

In particular, each @code{parent} field names one parent of this program point.  A parent program point
is a point whose samples should include all of the samples at this
program point.  For example, an object program point is a parent of
each of the method program points in that object.

The @var{relation-type} is the type of parent-child relationship in
the hierarchy.  Possible relationship types are @code{parent} and
@code{user}.

The @var{relation-id} is a unique integer that identifies this parent
relation.  They are used when defining the the specific parent
relations for variables.

Multiple parent fields can be specified.

@end itemize

@node Variable declarations,  , Program point declarations, Declarations
@subsection Variable declarations
@cindex declaration file format

The format of a variable declaration is:
@example
variable <name>
  <variable-info>
  <variable-info>
  ...
@end example

The variable name is arbitrary, but for clarity, it should match what is
used in the programming language.  All characters are legal in a name,
but blanks must be represented as @code{\_} and backslashes as
@code{\\}.

If the variable is an array, '@code{..}' marks the location of
array indices within the variable name.  Some examples of names are:
@example
this.theArray
this.theArray[..]
this.stack.getClass()
@end example

The following information about the variable (@code{variable-info}) can be specified:
@itemize

@item @code{var-kind <kind> [<relative-name>]}

Specifies the variable kind.  Possible values are: @code{field}, @code{function},
@code{array}, @code{variable}, @code{return}.  If @code{field} or @code{function}
are specified, the relative name of the field or function must be
specified.  For example, if the variable is @code{this.theArray}, the
relative name is @code{theArray}.  Pointers to arrays are of type
@code{field}.  The arrays themselves (a sequence of values) are of 
type @code{array}.  

@item @code{enclosing-var <enclosing-var-name>}

The variable that contains this variable.  Required for fields and
arrays and optional for functions.  If specified for functions, the
function is an instance method.  If not specified the function is
static.  A variable is specified by its name.  The enclosing-var must
be defined.  If a variable is omitted (e.g., by the omit-var switch),
any variable for which it is the enclosing variable must be omitted as
well.

For example, if the variable is @code{this.theArray}, the
enclosing variable is @code{this}

@item @code{reference-type pointer|offset}

Specifies the kind of reference for variables which are structures or
classes.  The possible values are @code{pointer} or @code{offset}.  In
C, @code{pointer} is used if the variable is a pointer, @code{offset}
is used when the structure is placed inline.  Pointer would be used
for all references to java objects.  Defaults to pointer.

@item @code{array <dim>}

The number of array dimensions inherited or declared by this variable.
The valid values are 0 or 1.  This should be specified for any variable
that has multiple values.  If not specified it defaults to 0.  Future
versions of Daikon may support more levels of arrays.

@item @code{dec-type <language-declaration>}

This is what the programmer used in the declaration of the variable.
Names for standard types should use Java's names (e.g., @code{int},
@code{boolean}, etc.), but names for user-defined or language-specific
types can be arbitrary strings.

@item @code{rep-type <daikon-type>}

This describes what will appear in the data
trace file.  For instance, the declared type might be @code{char[]} but
the representation type might be @code{java.lang.String}.  Or, the declared
type might be @code{Object} but the representation type might be
@code{hashcode}, if the address of the object is written to the data trace
file.

@cindex pointer variables, see ``hashcode'' type
@cindex hashcode type, for variables

The representation type should be one of @code{boolean}, @code{int},
@code{hashcode}, @code{double}, or @code{java.lang.String}; or an
array of one of those (indicated by a @code{[]} suffix, as in Java).

@code{hashcode} is intended for unique object identifiers like memory
addresses (pointers) or the return value of Java's
@code{Object.hashCode} method.  @code{hashcode} is treated like
@code{int}, except that the hashcode values are considered uninteresting
for the purposes of output.  For example, Daikon will print
@samp{@var{var} has only one value} instead of @samp{@var{var} ==
0x38E8A}.


@item @code{flags <flags>}

One or more flags may be specified.  Possible values are: 
@itemize

@item @code{is_param}

Indicates that a given variable is a parameter to a procedure.  Some
procedures reassign parameters -- essentially using them as local
variables.  Such uses are not relevant to the procedure's external
specification.  The @code{is_param} flag causes Daikon not to print
certain invariants, if the variable has been reassigned.

@enumerate
@item
Invariants
that use the parameter variable @code{p} in its post-state form are not
printed.
@item
Invariants that use fields of @code{p} (such as @code{p.x})
are printed only if @code{p} has not changed.
@item
Some immutable
characteristics, such as the size of arrays and data types, are not
printed.  (These can change only if @code{p} is changed, but then, @code{p}
would no longer be interesting.)
@end enumerate

@item @code{no_dups}

Indicates that a collection can not contain duplicates.
If it cannot, Daikon does not check for some invariants that only have
meaning for collections that can contain duplicate elements.

@item @code{not_ordered}

Indicates that the order of a collection does not have meaning.  In
this case, Daikon does not check for element-wise comparisons between
it and other collections.

@item @code{synthetic}

Indicates that the variable was added by the front end and is not
manifest in the input program.  

@item @code{classname} 

Indicates that the variable indicates the classname of its 
enclosing variable.

@item @code{to_string} 

Indicates that the variable is the string representation of its
enclosing variable.

@item @code{non_null}

Indicates that the variable can't take on a null value.  In this
case, Daikon will not check for the NonZero invariant.

@end itemize

@item @code{comparability <comparability-key>}

The @var{comparability-key} indicates which other variables are
comparable to this one.  The information specified here might have been
obtained dynamically, via
type-inference based analysis, or in some other manner.

A comparability for a non-array type is a signed integer.  Two
variables at the same program point are considered comparable if both
integers are the same, or if either integer is negative (that is, a
negative number means ``comparable to every other variable'').  A
comparability for an array type must contain an integer for each index
and for the contents; for instance, @samp{5[22][17]} for a
two-dimensional array.  An array comparison succeeds if comparisons over each
component succeed.

Variables at different program points are never compared to one another.
Use of the same number at different program points does not indicate any
relationship between the variables, and a given variable may have a
different comparability integer at different program points.

As an example, in the following code:
@example
int sum(int len, int[] a) @{
  int sum=0;
  for (int i=0; i++; i<len)
    sum += a[i];
  return sum;
@}
@end example
variables @code{i} and @code{len} are comparable to one another (and
to indices of array @code{a}).  Furthermore, the result is comparable
to the elements of array @code{a}.  The comparability keys for these
variables might look like
@example
len     - comparability 5
a       - comparability 8[5]
return  - comparability 8
@end example

@item @code{parent <parent-ppt> <rel-id> [<parent-variable>]}

Specifies the parent variable of this variable in the program
point/variable hierarchy.  The @var{parent-ppt} is the name of the
parent program point.  The @var{rel-id} must be one of the
relationship ids specified for this program point.  The
@var{parent-variable} is the name of this variable's parent in the
parent program point.  If the names are the same, it can be omitted.

@item @code{constant <value>}

Specifies a constant value for this variable.  If the variable has
compile-time constant value, it must be omitted from the data trace
records.

@item @code{function-args <arg1> <arg2> ...}

Specifies the arguments to a function (if any).  Specified by the
external name of the argument variables.  Multiple arguments are
blank separated.  For example
@example
function-args a.b this.f1
@end example
specifies that the function takes two arguments which are @code{a.b} and
@code{this.f1}.  As with enclosing variables, each of the arguments must
be defined as variables.

@end itemize


@node    Data trace records, Example files, Declarations, File formats
@section Data trace records

@cindex data trace format
@cindex .dtrace file

A data trace record (also known as a ``sample'') contains run-time value
information.  Its format is:
@example
<program-point-name>
this-invocation-nonce
<nonce-string>
<varname-1>
<var-value-1>
<var-modified-1>
<varname2>
<var-value-2>
<var-modified-2>
...
@end example

In other words, the sample record contains:
@itemize @bullet
@item name of the program point

@item
optionally, an arbitrary string (a nonce) used to match up procedure
entries (whose names conventionally end with @code{:::ENTER}) with
procedure exits (whose names conventionally end with @code{:::EXIT}).
This is necessary in concurrent systems because there may
be several invocations of a procedure active at once and they do not
necessarily follow a stack discipline, being exited in the reverse order of
entry.  For non-concurrent systems, this nonce is not necessary, and
both the line @code{this-invocation-nonce} and the nonce value may be
omitted.



@item for each variable:
@itemize @bullet
@item name
@item value
@itemize @bullet
@item    if an integer: sequence of digits, optionally preceded by a minus sign.
Boolean values are written as the number 0 (for false) or the number 1
(for true).  For pointers, the value may be @code{null}.
@item    if a string: characters surrounded by double-quotes.  Internal
double-quotes and backslashes are escaped by a backslash.  Newlines and
carriage returns are represented as @samp{\n} and @samp{\r},
respectively.

@item    if an array: open bracket (@code{[}), elements separated by
spaces, close bracket (@code{]}).  (Also, the array name
should end in @samp{[..]}; use @samp{a[..]} for array contents,
but @samp{a} for the identity of the array itself.)
@end itemize

@cindex nonsensical values for variables
@cindex missing values for variables, see nonsensical values

@c the Daikon code sometimes calls this "missing" rather than "nonsensical".
The value may also be the string @code{nonsensical}; @xref{Nonsensical
values}.
A string or array value is never @code{null}.  A reference to a
string or array may be @code{null}, in which case the string or array is
@code{nonsensical}.

@item modified? (0, 1, or 2).
@cindex modified bit
This value is 0 if the variable has not been assigned to since the
last time this program point was executed, and 1 if the variable has
been assigned to since then.  It is safe for an implementation to
always set it to 1.  It is also safe to always set it to 0, because
Daikon corrects obviously incorrect modification bits (such as 0 for a
never-before-seen value).

The special value 2 should be used only (and always) when the value
field is @code{nonsensical}.

@end itemize

The variables should appear in the same order as they did in the
declaration of the program point, without omissions or additions.
@end itemize

@cindex nonce, invocation
@cindex this_invocation_nonce


@menu
* Nonsensical values::          
* Variables that do not appear in trace records::  
@end menu

@node    Nonsensical values, Variables that do not appear in trace records, Data trace records, Data trace records
@subsection Nonsensical values for variables

Some trace variables and derived variables may not have a value because
the expression that computes it cannot be evaluated.  In such a
circumstance, the value is said to be nonsensical, it is written in the
trace file as @code{nonsensical}, and its modified field must be 2.
Examples include
@itemize
@item
@code{x} when @code{x} is uninitialized or deallocated,
@item
@code{x.y} when @code{x} is null (or uninitialized or deallocated)
@item
@code{a[i]} when @code{i} is outside the bounds of @code{a} (or
uninitialized or deallocated, or @code{a} is null, uninitialized, or
deallocated)
@end itemize
@noindent
For trace variables, it is the responsibility of the front end to
perform a check at run time whenever a variable's value is about to be
output to the trace, and to output the value ``nonsensical''
(@pxref{Nonsensical values}) rather than crashing the program or
outputting an uninitialized or meaningless value.  (Determining when an
expression's value is meaningless is the most challenging part of
writing an instrumenter for a language like C, since it requires
tracking memory allocation and initialization.)  For derived variables
created by Daikon, Daikon does the same thing, setting values to
``nonsensical'' when appropriate.  For controlling Daikon's output in
the presence of nonsensical values, see the
@option{daikon.Daikon.guardNulls} configuration option (@pxref{General
configuration options,,,./daikon,Daikon User Manual}).


@node    Variables that do not appear in trace records,  , Nonsensical values, Data trace records
@subsection Variables that do not appear in trace records

A trace record should contain exactly the same variables as in the
corresponding declaration.  There is one exception:  for efficiency,
compile-time constants (e.g., static final variables in Java) are
omitted from the trace record, since they would have the same value
every time.

Neither the declarations nor the trace records contains derived
variables (@pxref{Variable names,,,./daikon,Daikon User Manual}).



@node    Example files, Version 1 Declarations, Data trace records, File formats
@section Example files

Here are portions of two files @file{StackArTester.decls} and
@file{StackArTester.dtrace}, for a Java class that implements a stack of
integers using an array as the underlying data structure.  You can see
many more examples by simply running an existing front end on some Java,
C, or Perl programs and viewing the resulting files.

@menu
* Example declaration file::    
* Example data trace file::     
@end menu


@node    Example declaration file, Example data trace file, Example files, Example files
@subsection Example declaration file

This is part of the file @file{StackArTester.decls}, a declaration file for
the @file{StackAr.java} program (@pxref{StackAr example,,,./daikon,Daikon User Manual}).

@example
ppt DataStructures.StackAr.push(java.lang.Object):::ENTER
ppt-type enter
parent parent DataStructures.StackAr:::OBJECT 1
  variable this
    var-kind variable 
    dec-type DataStructures.StackAr
    rep-type hashcode
    flags is_param
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray
    var-kind field theArray
    enclosing-var this
    dec-type java.lang.Object[]
    rep-type hashcode
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray.getClass()
    var-kind function getClass()
    enclosing-var this.theArray
    dec-type java.lang.Class
    rep-type java.lang.String
    flags synthetic classname
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray[..]
    var-kind array 
    enclosing-var this.theArray
    array 1
    dec-type java.lang.Object[]
    rep-type hashcode[]
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray[..].getClass()
    var-kind function getClass()
    enclosing-var this.theArray[..]
    array 1
    dec-type java.lang.Class[]
    rep-type java.lang.String[]
    flags synthetic classname
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.topOfStack
    var-kind field topOfStack
    enclosing-var this
    dec-type int
    rep-type int
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable x
    var-kind variable 
    dec-type java.lang.Object
    rep-type hashcode
    flags is_param
    comparability 22
  variable x.getClass()
    var-kind function getClass()
    enclosing-var x
    dec-type java.lang.Class
    rep-type java.lang.String
    flags synthetic classname
    comparability 22

ppt DataStructures.StackAr.push(java.lang.Object):::EXIT99
ppt-type subexit
parent parent DataStructures.StackAr:::OBJECT 1
  variable this
    var-kind variable 
    dec-type DataStructures.StackAr
    rep-type hashcode
    flags is_param
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray
    var-kind field theArray
    enclosing-var this
    dec-type java.lang.Object[]
    rep-type hashcode
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray.getClass()
    var-kind function getClass()
    enclosing-var this.theArray
    dec-type java.lang.Class
    rep-type java.lang.String
    flags synthetic classname
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray[..]
    var-kind array 
    enclosing-var this.theArray
    array 1
    dec-type java.lang.Object[]
    rep-type hashcode[]
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.theArray[..].getClass()
    var-kind function getClass()
    enclosing-var this.theArray[..]
    array 1
    dec-type java.lang.Class[]
    rep-type java.lang.String[]
    flags synthetic classname
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable this.topOfStack
    var-kind field topOfStack
    enclosing-var this
    dec-type int
    rep-type int
    comparability 22
    parent DataStructures.StackAr:::OBJECT 1
  variable x
    var-kind variable 
    dec-type java.lang.Object
    rep-type hashcode
    flags is_param
    comparability 22
  variable x.getClass()
    var-kind function getClass()
    enclosing-var x
    dec-type java.lang.Class
    rep-type java.lang.String
    flags synthetic classname
    comparability 22

ppt DataStructures.StackAr:::OBJECT
ppt-type object
  variable this
    var-kind variable 
    dec-type DataStructures.StackAr
    rep-type hashcode
    flags is_param
    comparability 22
  variable this.theArray
    var-kind field theArray
    enclosing-var this
    dec-type java.lang.Object[]
    rep-type hashcode
    comparability 22
  variable this.theArray.getClass()
    var-kind function getClass()
    enclosing-var this.theArray
    dec-type java.lang.Class
    rep-type java.lang.String
    flags synthetic classname
    comparability 22
  variable this.theArray[..]
    var-kind array 
    enclosing-var this.theArray
    array 1
    dec-type java.lang.Object[]
    rep-type hashcode[]
    comparability 22
  variable this.theArray[..].getClass()
    var-kind function getClass()
    enclosing-var this.theArray[..]
    array 1
    dec-type java.lang.Class[]
    rep-type java.lang.String[]
    flags synthetic classname
    comparability 22
  variable this.topOfStack
    var-kind field topOfStack
    enclosing-var this
    dec-type int
    rep-type int
    comparability 22

@end example


@node    Example data trace file,  , Example declaration file, Example files
@subsection Example data trace file

This is part of file @file{StackArTester.dtrace}, which you can create by
running the instrumented @file{StackAr.java} program (@pxref{StackAr
example,,,./daikon,Daikon User Manual}).  This excerpt contains only the first two calls to
@code{push} and the first return from @code{push}, along with the
associated object program point records; omitted records are indicated
by ellipses.


@example
...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
55
x
1217030
1
x.getClass()
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

...

StackAr.push(java.lang.Object):::EXIT96
this_invocation_nonce
55
x
1217030
1
x.getClass()
"DataStructures.MyInteger"
1
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].getClass()
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

StackAr:::OBJECT
this.theArray
3852104
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[1217030]
1
this.theArray[].getClass()
["DataStructures.MyInteger"]
1
this.topOfStack
0
1

...

StackAr.push(java.lang.Object):::ENTER
this_invocation_nonce
94
x
1482257
1
x.getClass()
"DataStructures.StackAr"
1
this.theArray
350965
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

StackAr:::OBJECT
this.theArray
350965
1
this.theArray.getClass()
"java.lang.Object[]"
1
this.theArray[]
[null]
1
this.theArray[].getClass()
[null]
1
this.topOfStack
-1
1

...
@end example

@node    Version 1 Declarations,  , Example files, File formats
@section Version 1 Declarations

@cindex .decls file (version 1)

This section describes the original version (1.0) of declaration
records.  These are now obsolete and should not be used.

A declarations file can contain program point declarations,
@code{VarComparability} declarations, and @code{ListImplementors declarations}.

@menu
* V1 Program point declarations::  
* V1 pptname format::           
* V1 VarComparability declaration::  
* V1 ListImplementors declaration::  
@end menu

@node    V1 Program point declarations, V1 pptname format, Version 1 Declarations, Version 1 Declarations
@subsection V1 Program point declarations

The format of a program point declaration is:
@example
DECLARE
program-point-name
varname1
declared-type1 [# auxiliary-information1]
representation-type1 [= constant-value1]
comparable1
varname2
declared-type2 [# auxiliary-information2]
representation-type2 [= constant-value2]
comparable2
...
@end example

Program point information includes:
@itemize @bullet
@item
name (``tag'') of this program point, an arbitrary string containing no
tab or newline characters.  This name contains information such as the
class name or method name; what information is contained depends on
which instrumenter is being used.  @xref{V1 pptname format}, for a full
specification of the naming format.


@item
for each variable:
@itemize @bullet
@item
name: a string containing no tabs or newlines.  @xref{Variable names,,,./daikon,Daikon User Manual}.

@item
declared type: this is what the programmer used in the declaration of
the variable.  Array types must be suffixed by the proper number of
@samp{[]} to indicate their dimensionality.  Names for standard types
should use Java's names (e.g., @code{int}, @code{boolean}, etc.), but names for
user-defined or language-specific types can be arbitrary strings.

@item
auxiliary information: optionally, Daikon can be given information
about the meaning of the variable to help it better interpret the
values it later sees.  Information is provided as a comma-separated
list of items, with each item in the form of @samp{key = value}.  Unrecognized
keys are silently ignored.  All values are
either @samp{true} or @samp{false}.  Mainly, this information is used for
collections, which are presented to Daikon as arrays.  Valid keys are:

@table @code

@item hasDuplicates
Whether a collection can contain duplicates.  If it
cannot, Daikon does not check for some invariants that only have
meaning for collections that can contain duplicate elements.

@item hasOrder
Whether order has meaning for a collection.  If order does
not have meaning in a collection, then Daikon does not check for
element-wise comparisons between it and other collections.

@item hasNull
Whether zero has the special meaning null for the variable or
collection.  If it does, then Daikon checks for whether a value or the
elements in a collection are null.

@item nullTerminated
Whether a collection has a value (usually null) that
ends its representation.  If it does, then Daikon looks at the
collection's size and at the collection's size-1 as ``interesting''
values.  If it does not, then Daikon only looks at the collection's
size.

@item isParam
Whether a given variable is a parameter to a method.  If a
variable is a parameter, Daikon avoids printing some information that
would be considered uninteresting for parameters.  First, invariants
that use the parameter variable @code{p} in its post-state form are not
printed.  Second, invariants that use fields of @code{p} (such as @code{p.x})
are printed only if @code{p} has not changed.  Lastly, some immutable
characteristics, such as the size of arrays and data types are not
printed (both can be changed if @code{p} is changed, but then, @code{p}
would no longer be interesting).

@end table

@item
representation type:  this describes what will appear in the data
trace file.  For instance, the declared type might be @code{char[]} but
the representation type might be @code{java.lang.String}.  Or, the declared
type might be @code{Object} but the representation type might be
@code{hashcode}, if the address of the object is written to the data trace
file.

The representation type should be one of @code{boolean}, @code{int},
@code{hashcode}, @code{double}, or @code{java.lang.String}; or an
array of one of those (indicated by a @code{[]} suffix, as in Java).
Hashcodes are treated like integers, except that their actual values
are considered uninteresting for the purposes of output; they are
intended for unique object identifiers like memory addresses or the
return value of Java's @code{Object.hashCode} method.

The representation type may optionally be followed by an equals
sign and a value; in that case, the variable is known to have a
compile-time constant value and should be omitted from the data
trace file.
@end itemize
@item
@cindex comparability, for variables (decls format version 1)
@cindex variable comparability (decls format version 1)
comparable variables.  This information indicates
which other variables are comparable to this one.

The point of comparability is that Daikon should not compare unrelated
quantities.  For example, each person's height in centimeters may always
be less than their birth year, but it is not helpful for Daikon to
output @samp{height < birthyear}, because they are measuring
incomparable quantities.  (In this case, the variables use different
units of measurement.)

Variable comparability information helps Daikon to avoid computing
information over unrelated variables.  This saves time and (more
importantly) improves the quality of Daikon's output.  For more details,
see the paper
@uref{http://www.cs.washington.edu/homes/mernst/pubs/invariants-relevance-icse2000-abstract.html,
, ``Quickly detecting relevant program invariants''}.

Variable comparability information may be obtained dynamically
(@pxref{Dynamic abstract type inference (DynComp),,,./daikon,Daikon User Manual}), via
type-inference based analysis, or in some other manner.  In any event,
Daikon reads it from the variable declarations.

A comparability for a non-array type is a signed integer.  Two variables
at the same program point
are considered comparable if both integers are the same, @emph{or} if either
integer is negative.
A comparability for an array type must contain an
integer for each index and for the contents; for instance, @samp{5[22][17]}
for a two-dimensional array.  Comparisons succeed if comparisons over
each component succeed.

Regardless of comparability, variables at different program points are
never compared to one another.  Use of the same comparability integer at
different program points does not indicate any
relationship between the variables, and a given variable may have a
different comparability integer at different program points.

As an example, in the following code:
@example
int sum(int len, int[] a) @{
  int sum=0;
  for (int i=0; i++; i<len)
    sum += a[i];
  return sum;
@}
@end example
variables @code{i} and @code{len} are comparable to one another (and
to indices of array @code{a}).  Furthermore, the result is comparable
to the elements of array @code{a}.  A declaration file for these
variables might look like
@example
len
int
int
5
a
int[]
int[]
8[5]
return
int
int
8
@end example

@end itemize

@c Future enhancements may include:
@c @itemize @bullet
@c @item
@c permit variables to be omitted if they haven't changed (but always
@c outputting the bit permits us to write a sanity checker)
@c @item
@c permit variables to appear in any order (not sure this is so worthwhile)
@c @item
@c specify which @file{.decl} files should be used (including their pathnames
@c and/or MD5 hashes)
@c @end itemize

@node    V1 pptname format, V1 VarComparability declaration, V1 Program point declarations, Version 1 Declarations
@subsection Program point name format specification

Instrumenting code creates a @file{.decls} file that contains program
point names such as:

@example
DataStructures.StackAr.push(java.lang.Object):::ENTER
DataStructures.StackAr.push(java.lang.Object):::EXIT99
PolyCalc.RatNum.RatNum(int, int):::ENTER
PolyCalc.RatNum.RatNum(int, int):::EXIT55
PolyCalc.RatNum.RatNum(int, int):::EXIT67
@end example

This section describes the format of these program point names.  Someone
writing an instrumenter for a new language must be sure to follow this
format specification.

A program point name is a string with no tabs or newlines in it.  The basic
format is @samp{@var{topLevel}.@var{bottomLevel}:::@var{pptInfo}}.
For the first example given above, the top level of the hierarchy would
be @code{DataStructures.StackAr}, the bottom level would be
@code{push(java.lang.Object)}, and the
program point information would be @code{ENTER}.

@var{topLevel} may contain any number of periods (@samp{.}). @var{bottomLevel}
and @var{pptInfo} may not contain any periods.  The string @samp{:::} may only
appear once.

@var{topLevel} and @var{pptInfo} are required (i.e., they must be non-empty),
as are the period to the right of @var{topLevel} and the colons to the
left of @var{pptInfo}.  However, @var{bottomLevel} is optional.

By convention, for Java @var{topLevel} consists of the class name, and
@var{bottomLevel} consists of the method name and method signature.

For C, @var{topLevel} consists of a filename (or a single period for
global functions), and @var{bottomLevel}
could consist of a function name and signature.
More precisely, names of C program points follow these conventions:

@itemize @bullet
@item
Names of program points for file-static functions are prefixed with the name
of the source file, with @samp{.} characters mapped to @samp{_},
followed by a @samp{.}.

@item Names of program points for
file-scope functions with external linkage are prefixed with @samp{..}.
For example, a global function program point might be named
@samp{..main():::ENTER}., the first period denoting that it is global in
scope and the second denoting the separator between the @var{toplevel}
and @var{bottomlevel} parts of the name.

@item
Names of C++ functions that are class or namespace members are prefixed
with the name(s) of their classes or namespaces, with the C++ @samp{::}
syntax mapped onto the Java @samp{.} syntax used by Daikon.
@end itemize

For IOA, @var{topLevel} consists of an Automaton name and
@var{bottomLevel} consists of information for a transition state.



By convention, the entry and exit points for a function have names of
a special form so that they can be associated with one another.
(Currently, those names end with @code{:::ENTER} and @code{:::EXIT}.)  This
convention permits Daikon to generate pre-state variables
(@pxref{Variable names,,,./daikon,Daikon User Manual}) automatically at procedure exit points, so
front ends need not output them explicitly.  When there
are multiple exit points, then each one should be suffixed by a number
(such as a line number, for example, @code{foo::EXIT22}).  Daikon produces
the main (non-numbered) @code{:::EXIT} point automatically.  All the
numbered exits should contain the same set of variables; in general,
this means that local variables are not included at exit points.
Daikon currently requires that declarations for @code{:::ENTER} program
points appear before any declarations for matching @code{:::EXIT} program
points.

Another convention is to have another program point whose
@var{bottomLevel} is empty and whose @var{pptInfo} is  @code{OBJECT}:
for example, @code{StackAr:::OBJECT}.  This contains the
representation invariant (sometimes called the object invariant) of a
class.  This program point is created automatically by Daikon; it need
not appear in a trace file.

@c This program point is not created automatically by Daikon, because
@c there isn't a way to know whether a particular method is a private
@c helper method or not --- that is, whether the representation
@c invariants should hold on entry to and exit from it.



@node V1 VarComparability declaration, V1 ListImplementors declaration, V1 pptname format, Version 1 Declarations
@subsection V1 VarComparability declaration

There is a special @code{VarComparability} declaration that controls how
the comparability field in program point declarations is interpreted.
The default @code{VarComparability} is @code{implicit}, which means
ordinary comparability as described in @ref{Program point declarations}.
(The name @code{implicit} is retained for historical reasons.)
You can override it as
follows:
@example
VarComparability
none
@end example
@noindent
As with all records in Daikon input files, a
blank line is required between this record and the next one.

@node V1 ListImplementors declaration,  , V1 VarComparability declaration, Version 1 Declarations
@subsection V1 ListImplementors declaration

This declaration indicates classes that implement the
@code{java.util.List} interface, and should be treated as sequences
for the purposes of invariant detection.  The syntax is as follows:

@example
ListImplementors
<classname1>
<classname2>
...
@end example

Each classname is in Java format (for example, ``java.util.LinkedList'').

The @samp{--list_type} command-line option to Daikon can also be used to
specify classes that implement lists; @xref{Options to control invariant detection,,,./daikon,Daikon User Manual}.


@node     Index,  , File formats, Top
@unnumbered Index

@printindex cp


@bye


@c  LocalWords:  texinfo setfilename settitle daikonemail setchapternewpage sp
@c  LocalWords:  hboxes finalout titlepage titlefont daikon eps pdf txt png jpg
@c  LocalWords:  vskip pt filll html img src alt ifnothtml dir ifnottex ifinfo
@c  LocalWords:  ifhtml detailmenu uref cindex java jpp cpp javac jikes proto
@c  LocalWords:  invs samp SingleScalar TwoScalar abs ThreeScalar TwoSequence
@c  LocalWords:  SingleSequence SequenceScalar noindent Daikon's InvName ppt ok
@c  LocalWords:  PptSlice dyn dkconfig VarInfo computeConfidence num repr esc
@c  LocalWords:  DAIKONDIR IOA JML var newtype OutputFormat PrintInvariants int
@c  LocalWords:  decls dtrace squar emph NISuppressor NISuppression suppressee
@c  LocalWords:  NISuppressee NISuppressionSet ni IntGreaterEqual eq IntEqual
@c  LocalWords:  lt IntLessThan makeEmpty LessThan GreaterThan orig theArray TR
@c  LocalWords:  FloatLessThan DisjSets SequenceScalarSubscriptFactory pxref co
@c  LocalWords:  Javadoc Varinfo logOn getClass foo vars isLoggable logDetail
@c  LocalWords:  msg showTrackback args webserver addInvariant href emacsclient
@c  LocalWords:  inv PptTopLevel FileIO php isObviousStatically LCS Nimmer's cp
@c  LocalWords:  isObviousDynamically Toh Win's nohierarchy noequality diffs pl
@c  LocalWords:  diff InvariantFormatTest classpath ioa jml aString valueOf val
@c  LocalWords:  deffn SampleTester decl subsubsection arg iff testsubject ajax
@c  LocalWords:  jtb cvs checkin smallexample checkins printindex Dataflow gcc
@c  LocalWords:  convertcsv Mangel Wurzel malloc TerminationMessage un Mozilla FSE cd
@c  LocalWords:  dataflow czf mernst pag calloc Mbytes Miryung ifnotinfo env di
@c  LocalWords:  JDKDIR bashrc cshrc DAIKONCLASS makeinfo InvariantStatus itemx
@c  LocalWords:  ObviousFilter StackAr DataStructures structs StackArTester Ren
@c  LocalWords:  INST Xiaoxia regex printf DiscardInfo instanceof UpperBound Xu
@c  LocalWords:  DiscardCode Kapfhammer GB ListImplementors pptname MacOSX rt
@c  LocalWords:  VarComparability instrumenter struct Hatcliff Sinha Vibha xref
@c  LocalWords:  dfepl uninstrumented classname subexit inline dec hashcode len
@c  LocalWords:  hashCode param dups NonZero rel varname topOfStack MyInteger
@c  LocalWords:  hasDuplicates hasOrder hasNull nullTerminated isParam DynComp
@c  LocalWords:  Hashcodes birthyear topLevel bottomLevel pptInfo toplevel
@c  LocalWords:  bottomlevel namespace namespaces
