// ***** This file is automatically generated from Quant.java.jpp and QuantBody.java.jpp.

package daikon;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.AbstractCollection;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;

import org.plumelib.util.ArraysPlume;
import org.plumelib.util.Intern;
import org.plumelib.util.FuzzyFloat;

import org.checkerframework.checker.interning.qual.Interned;
import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.nullness.qual.PolyNull;
import org.checkerframework.checker.signedness.qual.Signed;
import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.dataflow.qual.SideEffectFree;

/**
 * The Quant library provides routines that operate on arrays and collections.
 *
 * <p>These routines are used by the Java family of output formats. This allows invariants to be
 * output as snippets of executable (Java) code. For example, an invariant like
 * <pre>a[] elements &ge; 1</pre>
 * is output (in the Java, JML, and DBC formats) as something like
 *
 * <pre>daikon.Quant.eltsGTE(a, 1)</pre>
 *
 * <h2>Naming</h2>
 *
 * The library methods have names of the following forms, where OP indicates an operation: Equal,
 * NotEqual, GT (greater than), GTE (greater than or equal to), LT, LTE.
 * <ul>
 * <li>pairwiseOP. Apply OP to corresponding elements of two arrays:
 *     a[0] OP b[0], a[1] OP b[1], etc.
 * <li>eltsOP. Apply OP to each element of one array, and a scalar:
 *     a[0] OP x, a[1] OP x, etc.
 * <li>eltwiseOP: Apply OP to adjacent elements of one array:
 *     a[0] OP a[1], a[1] OP a[2], etc.
 * <li>lexOP: Determine lexical ordering:
 *     compare two arrays pairwise, stopping as soon as the result is known.
 * <li>eltsOPindex: Apply op to array elements and their indices:
 *     a[0] OP 0, a[1] OP 1, etc.
 * </ul>
 *
 * <h2>Equality semantics</h2>
 *
 * <p>Whenever a method involves comparing two elements for equality, this is always "==" equality
 * (even for Objects and Strings).
 *
 * <h2>No exceptions thrown</h2>
 *
 * <p>The library strives not to throw exceptions, even if illegal arguments are passed to the
 * routines. This has two consequences.
 *
 * <p>First, each predicate (boolean method) returns false when invoked on an illegal argument such
 * as a null collection (array or Collection).
 *
 * <p>Second, each accessor method returns a default "bad" value if inovked on an illegal argument.
 * For example, the default value for the double type is Double.NaN.
 *
 * <p>The rationale for the decision to never throw exceptions is that we wish to be able to invoke
 * the Quant methods at run time without distrubing execution of a program, and without forcing
 * clients to write a try .. catch block around each invocation.
 *
 * <p>A downside of the decision is that if the default value is returned, it may be impossible for
 * a client to determine whether the method really returned that value, or whether the invocation
 * involved an illegal argument. To avoid this problem, it is generally better to use a Quant
 * library predicate rather than returning a value and then testing it externally.
 */
public final class Quant {
  private Quant() { throw new Error("do not instantiate"); }

  public static FuzzyFloat fuzzy = new FuzzyFloat();

  /**
   * Returns the size of the array or collection. If the argument is null or not an array or
   * collection, returns a default value (Integer.MAX_VALUE). Thus, for an array a, this never
   * throws an exception, though a.length may.
   */
  // Not called from Quant; provided only for external use.
  @Pure
  public static int size(Object o) {
    if (o == null) {
      return Integer.MAX_VALUE; // return default value
    }
    java.lang.Class<?> c = o.getClass();
    if (c.isArray()) {
      return java.lang.reflect.Array.getLength(o);
    } else if (o instanceof Collection<?>) {
      return ((Collection<?>)o).size();
    } else {
      return Integer.MAX_VALUE; // return default value
    }
  }

  /** Returns the size of the collection.
   * If the argument is null, returns a default value (Integer.MAX_VALUE).
   */
  // Not called from Quant; provided only for external use.
  @Pure
  public static int size(Collection<?> o) {
    if (o == null) {
      return Integer.MAX_VALUE; // return default value
    }
    return o.size();
  }

  /** True iff the sequence contains no null elements. */
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean eltsNonNull(Object[] seq1) {
    if (seq1 == null) {
      return false;
    }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (seq1[i] == null) {
        return false;
      }
    }
    return true;
  }

#define BOOLEAN
#include "daikon/QuantBody.java.jpp"
#undef BOOLEAN

#define BYTE
#include "daikon/QuantBody.java.jpp"
#undef BYTE

#define CHAR
#include "daikon/QuantBody.java.jpp"
#undef CHAR

#define DOUBLE
#include "daikon/QuantBody.java.jpp"
#undef DOUBLE

#define FLOAT
#include "daikon/QuantBody.java.jpp"
#undef FLOAT

#define INT
#include "daikon/QuantBody.java.jpp"
#undef INT

#define LONG
#include "daikon/QuantBody.java.jpp"
#undef LONG

#define SHORT
#include "daikon/QuantBody.java.jpp"
#undef SHORT

#define OBJECT
#include "daikon/QuantBody.java.jpp"
#undef OBJECT

#define STRING
#include "daikon/QuantBody.java.jpp"
#undef STRING

  // ///////////////////////////////////////////////////////////////////////////
  // Collection methods (dispatch to array methods)
  //

  // These methods handle calls to quant methods that instead of passing an
  // Object[] array, pass a Collection.  Each method handles arrays or
  // Collections.  They convert any Collection to an array, then invoke the
  // Object[] version of the method.

  /**
   * See {@link #noDups(Object[])}.
   * @see #noDups(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean noDups(Object seq) {
    if (seq == null) {
      return false;
    }
    return noDups(toObjArray(seq));
  }

  /**
   * See {@link #typeArray(Object[])}.
   * @see #typeArray(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1"})*/
  /* pure */ public static String @PolyNull [] typeArray(@PolyNull Object seq) {
    if (seq == null) {
      return null;
    }
    return typeArray(toObjArray(seq));
  }

  /**
   * See {@link #eltwiseEqual(Object[])}.
   * @see #eltwiseEqual(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean eltwiseEqual(Object seq) {
    if (seq == null) {
      return false;
    }
    return eltwiseEqual(toObjArray(seq));
  }

  /**
   * See {@link #eltwiseNotEqual(Object[])}.
   * @see #eltwiseNotEqual(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean eltwiseNotEqual(Object seq) {
    if (seq == null) {
      return false;
    }
    return eltwiseNotEqual(toObjArray(seq));
  }

  /**
   * See {@link #concat(Object[], Object[])}.
   * @see #concat(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  @SideEffectFree
  public static java.lang.Object @PolyNull [] concat(@PolyNull Object seq1, @PolyNull Object seq2) {
    if (seq1 == null) {
      return null;
    }
    if (seq2 == null) {
      return null;
    }
    return concat(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #union(Object[], Object[])}.
   * @see #union(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  @SideEffectFree
  public static java.lang.Object @PolyNull [] union(@PolyNull Object seq1, @PolyNull Object seq2) {
    if (seq1 == null) {
      return null;
    }
    if (seq2 == null) {
      return null;
    }
    return union(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #intersection(Object[], Object[])}.
   * @see #intersection(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  @SideEffectFree
  public static java.lang.Object @PolyNull [] intersection(@PolyNull Object seq1, @PolyNull Object seq2) {
    if (seq1 == null) {
      return null;
    }
    if (seq2 == null) {
      return null;
    }
    return intersection(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #setDiff(Object[], Object[])}.
   * @see #setDiff(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  @SideEffectFree
  public static java.lang.Object @PolyNull [] setDiff(@PolyNull Object seq1, @PolyNull Object seq2) {
    if (seq1 == null) {
      return null;
    }
    if (seq2 == null) {
      return null;
    }
    return setDiff(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #setEqual(Object[], Object[])}.
   * @see #setEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @Pure
  public static boolean setEqual(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return setEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #isReverse(Object[], Object[])}.
   * @see #isReverse(Object[], Object[])
   */
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @SuppressWarnings("interning")  // cast from Object
  @Pure
  public static boolean isReverse(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return isReverse(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #pairwiseEqual(Object[], Object[])}.
   * @see #pairwiseEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @Pure
  public static boolean pairwiseEqual(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return pairwiseEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #pairwiseNotEqual(Object[], Object[])}.
   * @see #pairwiseNotEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @Pure
  public static boolean pairwiseNotEqual(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return pairwiseNotEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #lexEqual(Object[], Object[])}.
   * @see #lexEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @Pure
  public static boolean lexEqual(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return lexEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #lexNotEqual(Object[], Object[])}.
   * @see #lexNotEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression={"#1","#2"})
  @Pure
  public static boolean lexNotEqual(@Nullable Object seq1, @Nullable Object seq2) {
    if (seq1 == null) {
      return false;
    }
    if (seq2 == null) {
      return false;
    }
    return lexNotEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /**
   * See {@link #memberOf(Object, Object[])}.
   * @see #memberOf(Object, Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression="#2")
  @Pure
  public static boolean memberOf(Object elt, @Nullable Object arr) {
    if (arr == null) {
      return false;
    }
    return memberOf(elt, toObjArray(arr));
  }

  /**
   * See {@link #slice(Object[], int, int)}.
   * @see #slice(Object[], int, int)
   */
  @SuppressWarnings("interning")  // cast from Object
  /*TODO: @AssertNonNullIfNonNull("#1")*/
  @SideEffectFree
  public static Object @PolyNull [] slice(@PolyNull Object seq, int start, int end) {
    if (seq == null) {
      return null;
    }
    return slice(toObjArray(seq), start, end);
  }

  /**
   * See {@link #eltsEqual(Object[], Object)}.
   * @see #eltsEqual(Object[], Object)
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean eltsEqual(@Nullable Object arr, Object elt) {
    if (arr == null) {
      return false;
    }
    return eltsEqual(toObjArray(arr), elt);
  }

  /**
   * See {@link #eltsNotEqual(Object[], Object)}.
   * @see #eltsNotEqual(Object[], Object)
   */
  @SuppressWarnings("interning")  // cast from Object
  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean eltsNotEqual(@Nullable Object arr, Object elt) {
    if (arr == null) {
      return false;
    }
    return eltsNotEqual(toObjArray(arr), elt);
  }

  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean isIntegralType(@Nullable Class<?> c) {
    if (c == null) {
      return false;
    }
    return
      (c.equals(Byte.TYPE)
       || c.equals(Short.TYPE)
       || c.equals(Integer.TYPE)
       || c.equals(Long.TYPE));
  }

  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean isRealType(@Nullable Class<?> c) {
    if (c == null) {
      return false;
    }
    return
      (c.equals(Float.TYPE)
       || c.equals(Double.TYPE));
  }

  @EnsuresNonNullIf(result=true, expression="#1")
  @Pure
  public static boolean isNumericType(Class<?> c) {
    if (c == null) {
      return false;
    }
    return isIntegralType(c) || isRealType(c);
  }

  /** Returns an Object[] array, either by casting or by conversion from an
   * AbstractCollection.
   */
  /*TODO: @AssertNonNullIfNonNull("#1")*/
  public static Object @PolyNull [] toObjArray(@PolyNull Object o) {
    if (o == null) {
      return null;
    }
    if (o instanceof java.util.AbstractCollection<?>) {
      @SuppressWarnings({"unchecked"})
        AbstractCollection<Object> ac = (AbstractCollection<Object>)o;
      Object [] result = ac.toArray(new java.lang.Object []{});
      return result;
    } else if (o.getClass().isArray()) {
      return (Object[])o;
    } else {
      throw new IllegalArgumentException("not an array or collection: " + o);
    }
  }
}
