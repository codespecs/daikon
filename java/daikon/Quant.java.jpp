// ***** This file is automatically generated from Quant.java.jpp and QuantBody.java.jpp.

package daikon;

import java.util.*;
import java.lang.reflect.*;

/*>>>
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import org.checkerframework.framework.qual.PolyAll;
*/

/**
 * The Quant library provides routines that operate on arrays and
 * collections.
 *
 * These routines are used by the Java family of output
 * formats. This allows invariants to be output as snippets of
 * executable (Java) code. For example, an invariant like
 * <pre>
 *  a[] elements &ge; 1
 * </pre>
 * is output (in the Java, JML, and DBC formats) as something like
 * <pre>
 *  daikon.Quant.eltsGTE(a, 1)
 * </pre>
 *
 * <h3>Naming</h3>
 *
 * The library methods have names of the following forms, where OP
 * indicates an operation:  Equal, NotEqual, GT (greater than), GTE
 * (greater than or equal to), LT, LTE.
 * <ul>
 * <li>pairwiseOP.  Apply OP to corresponding elements of two arrays:
 *     a[0] OP b[0], a[1] OP b[1], etc.
 * <li>eltsOP.  Apply OP to each element of one array, and a scalar:
 *     a[0] OP x, a[1] OP x, etc.
 * <li>eltwiseOP:  Apply OP to adjacent elements of one array:
 *     a[0] OP a[1], a[1] OP a[2], etc.
 * <li>lexOP:  Determine lexical ordering:
 *     compare two arrays pairwise, stopping as soon as the result is known.
 * <li>eltsOPindex:  Apply op to array elements and their indices:
 *     a[0] OP 0, a[1] OP 1, etc.
 * </ul>
 *
 * <h3>Equality semantics</h3>
 *
 * Whenever a method involves comparing two elements for equality, this is
 * always "==" equality (even for Objects and Strings).
 *
 * <h3>No exceptions thrown</h3>
 *
 * The library strives not to throw exceptions, even if illegal arguments
 * are passed to the routines.  This has two consequences.<p>
 *
 * First, each predicate (boolean method) returns false when invoked on an
 * illegal argument such as a null collection (array or Collection).<p>
 *
 * Second, each accessor method returns a default "bad" value if inovked on
 * an illegal argument.  For example, the default value for the double type
 * is Double.NaN.<p>
 *
 * The rationale for the decision to never throw exceptions is that we wish
 * to be able to invoke the Quant methods at run time without distrubing
 * execution of a program, and without forcing clients to write a try
 * .. catch block around each invocation.<p>
 *
 * A downside of the decision is that if the default value is returned, it
 * may be impossible for a client to determine whether the method really
 * returned that value, or whether the invocation involved an illegal
 * argument.  To avoid this problem, it is generally better to use a Quant
 * library predicate rather than returning a value and then testing it
 * externally.
 */
public final class Quant {
  private Quant() { throw new Error("do not instantiate"); }

  public static plume.FuzzyFloat fuzzy = new plume.FuzzyFloat();

  /** Returns the size of the array or collection.
   * If the argument is null or not an array or collection, returns a
   * default value (Integer.MAX_VALUE).
   * Thus, for an array a, this never throws an exception, though a.length may.
   */
  // Not called from Quant; provided only for external use.
  /*@Pure*/ public static int size(Object o) {
    if (o == null) { return Integer.MAX_VALUE; } // return default value
    java.lang.Class<?> c = o.getClass();
    if (c.isArray()) {
      return java.lang.reflect.Array.getLength(o);
    } else if (o instanceof Collection<?>) {
      return ((Collection<?>)o).size();
    } else {
      return Integer.MAX_VALUE; // return default value
    }
  }

  /** Returns the size of the collection.
   * If the argument is null, returns a default value (Integer.MAX_VALUE).
   */
  // Not called from Quant; provided only for external use.
  /*@Pure*/ public static int size(Collection<?> o) {
    if (o == null) { return Integer.MAX_VALUE; } // return default value
    return o.size();
  }

  /** True iff the sequence contains no null elements. */
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean eltsNonNull(final Object[] seq1) {
    if (seq1 == null) { return false; }
    for (int i = 0 ; i < seq1.length ; i++) {
      if (seq1[i] == null) {
        return false;
      }
    }
    return true;
  }

#define BOOLEAN
#include "daikon/QuantBody.java.jpp"
#undef BOOLEAN

#define BYTE
#include "daikon/QuantBody.java.jpp"
#undef BYTE

#define CHAR
#include "daikon/QuantBody.java.jpp"
#undef CHAR

#define DOUBLE
#include "daikon/QuantBody.java.jpp"
#undef DOUBLE

#define FLOAT
#include "daikon/QuantBody.java.jpp"
#undef FLOAT

#define INT
#include "daikon/QuantBody.java.jpp"
#undef INT

#define LONG
#include "daikon/QuantBody.java.jpp"
#undef LONG

#define SHORT
#include "daikon/QuantBody.java.jpp"
#undef SHORT

#define OBJECT
#include "daikon/QuantBody.java.jpp"
#undef OBJECT

#define STRING
#include "daikon/QuantBody.java.jpp"
#undef STRING


  ///////////////////////////////////////////////////////////////////////////
  /// Collection methods (dispatch to array methods)
  //

  // These methods handle calls to quant methods that instead of passing an
  // Object[] array, pass a Collection.  Each method handles arrays or
  // Collections.  They convert any Collection to an array, then invoke the
  // Object[] version of the method.

  /** @see #noDups(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean noDups(final Object seq) {
    if (seq == null) { return false; }
    return noDups(toObjArray(seq));
  }

  /** @see #typeArray(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1"})*/
  /* pure */ public static String /*@PolyNull*/ [] typeArray(/*@PolyNull*/ Object seq) {
    if (seq == null) { return null; }
    return typeArray(toObjArray(seq));
  }

  /** @see #eltwiseEqual(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean eltwiseEqual(final Object seq) {
    if (seq == null) { return false; }
    return eltwiseEqual(toObjArray(seq));
  }

  /** @see #eltwiseNotEqual(Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean eltwiseNotEqual(final Object seq) {
    if (seq == null) { return false; }
    return eltwiseNotEqual(toObjArray(seq));
  }

  /** @see #concat(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  /*@SideEffectFree*/ public static java.lang.Object /*@PolyNull*/ [] concat(/*@PolyNull*/ Object seq1, /*@PolyNull*/ Object seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return concat(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #union(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  /*@SideEffectFree*/ public static java.lang.Object /*@PolyNull*/ [] union(/*@PolyNull*/ Object seq1, /*@PolyNull*/ Object seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return union(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #intersection(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  /*@SideEffectFree*/ public static java.lang.Object /*@PolyNull*/ [] intersection(/*@PolyNull*/ Object seq1, /*@PolyNull*/ Object seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return intersection(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #setDiff(Object[], Object[])
   */
  @SuppressWarnings("interning") // cast from Object
  /*TODO: @AssertNonNullIfNonNull({"#1","#2"})*/
  /*@SideEffectFree*/ public static java.lang.Object /*@PolyNull*/ [] setDiff(/*@PolyNull*/ Object seq1, /*@PolyNull*/ Object seq2) {
    if (seq1 == null) { return null; }
    if (seq2 == null) { return null; }
    return setDiff(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #setEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  /*@Pure*/ public static boolean setEqual(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return setEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #isReverse(Object[], Object[])
   */
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  @SuppressWarnings("interning")  // cast from Object
  /*@Pure*/ public static boolean isReverse(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return isReverse(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #pairwiseEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  /*@Pure*/ public static boolean pairwiseEqual(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #pairwiseNotEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  /*@Pure*/ public static boolean pairwiseNotEqual(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return pairwiseNotEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #lexEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  /*@Pure*/ public static boolean lexEqual(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return lexEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #lexNotEqual(Object[], Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression={"#1","#2"})*/
  /*@Pure*/ public static boolean lexNotEqual(/*@Nullable*/ Object seq1, /*@Nullable*/ Object seq2) {
    if (seq1 == null) { return false; }
    if (seq2 == null) { return false; }
    return lexNotEqual(toObjArray(seq1), toObjArray(seq2));
  }

  /** @see #memberOf(Object, Object[])
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#2")*/
  /*@Pure*/ public static boolean memberOf(Object elt, /*@Nullable*/ Object arr) {
    if (arr == null) { return false; }
    return memberOf(elt, toObjArray(arr));
  }

  /** @see #slice(Object[], int, int)
   */
  @SuppressWarnings("interning")  // cast from Object
  /*TODO: @AssertNonNullIfNonNull("#1")*/
  /*@SideEffectFree*/ public static Object /*@PolyNull*/ [] slice(final /*@PolyNull*/ Object seq, int start, int end) {
    if (seq == null) { return null; }
    return slice(toObjArray(seq), start, end);
  }

  /** @see #eltsEqual(Object[], Object)
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean eltsEqual(final /*@Nullable*/ Object arr, Object elt) {
    if (arr == null) { return false; }
    return eltsEqual(toObjArray(arr), elt);
  }

  /** @see #eltsNotEqual(Object[], Object)
   */
  @SuppressWarnings("interning")  // cast from Object
  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean eltsNotEqual(final /*@Nullable*/ Object arr, Object elt) {
    if (arr == null) { return false; }
    return eltsNotEqual(toObjArray(arr), elt);
  }

  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean isIntegralType(final /*@Nullable*/ Class<?> c) {
    if (c == null) { return false; }
    return
      (c.equals(Byte.TYPE) ||
       c.equals(Short.TYPE) ||
       c.equals(Integer.TYPE) ||
       c.equals(Long.TYPE));
  }

  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean isRealType(final /*@Nullable*/ Class<?> c) {
    if (c == null) { return false; }
    return
      (c.equals(Float.TYPE) ||
       c.equals(Double.TYPE));
  }

  /*@EnsuresNonNullIf(result=true, expression="#1")*/
  /*@Pure*/ public static boolean isNumericType(final Class<?> c) {
    if (c == null) { return false; }
    return isIntegralType(c) || isRealType(c);
  }

  /** Returns an Object[] array, either by casting or by conversion from an
   * AbstractCollection.
   */
  /*TODO: @AssertNonNullIfNonNull("#1")*/
  public static Object /*@PolyNull*/ [] toObjArray(final /*@PolyNull*/ Object o) {
    if (o == null) { return null; }
    if (o instanceof java.util.AbstractCollection<?>) {
      @SuppressWarnings({"unchecked", "interning"})
        AbstractCollection<Object> ac = (AbstractCollection<Object>)o;
      @SuppressWarnings("interning") // generics bug in checker?
      Object [] result
        = ac.toArray(new java.lang.Object []{});
      return result;
    } else if (o.getClass().isArray()) {
      return (Object[])o;
    } else {
      throw new IllegalArgumentException("not an array or collection: " + o);
    }
  }

}
