#if 0
  // Do not attempt to compile this file with a Java compiler such as javac.
  // You first need to preprocess it with cpp, the C preprocessor.
  // The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME FunctionBinary
  #define PROTOCLASSNAME @Prototype FunctionBinary
  #define SUPERCLASS ThreeScalar
  #define PRIMITIVE long
  #define PRIMITIVE_CNAME Long
  #define EQUAL(a,b) (a == b)
  #define IS_INTEGRAL isIntegral()
  #define POW MathPlume.pow
  #define EQUALITY IntEqual
  #define LESS_EQUAL IntLessEqual
  #define LESS_THAN  IntLessThan
  #define EQUAL_ZERO RangeInt.EqualZero
  #define EQUAL_ONE  RangeInt.EqualOne
  #define BOUND0_63 RangeInt.Bound0_63
  #define BOOLEAN  RangeInt.BooleanVal
  #define GTE_0 RangeInt.GreaterEqualZero
  #define EVEN RangeInt.Even
  #define POWER2 RangeInt.PowerOfTwo
  #define TRACK_0 NumericInt.ZeroTrack
  #define BW_AND_0 NumericInt.BitwiseAndZero
  #define NONZERO NonZero
  #define GTE_64 RangeInt.GreaterEqual64
  #define SHIFT_0 NumericInt.ShiftZero
  #define DIVIDES NumericInt.Divides
  #define BW_SUBSET NumericInt.BitwiseSubset
#elif defined(TYPEDOUBLE)
  #define CLASSNAME FunctionBinaryFloat
  #define PROTOCLASSNAME @Prototype FunctionBinaryFloat
  #define SUPERCLASS ThreeFloat
  #define PRIMITIVE double
  #define PRIMITIVE_CNAME Double
  #define EQUAL(a,b) Global.fuzzy.eq(a, b)
  #define IS_INTEGRAL isFloat()
  #define POW Math.pow
  #define EQUALITY FloatEqual
  #define LESS_EQUAL FloatLessEqual
  #define LESS_THAN FloatLessThan
  #define EQUAL_ZERO RangeFloat.EqualZero
  #define EQUAL_ONE  RangeFloat.EqualOne
  #define GTE_0 RangeFloat.GreaterEqualZero
  #define TRACK_0 NumericInt.ZeroTrack
  #define NONZERO NonZeroFloat
  #define GTE_64 RangeInt.GreaterEqual64
#else
  #error "bad def"
#endif

#define PERM_XYZ 1
#define PERM_YXZ 2
#define PERM_ZXY 3
#define PERM_XZY 4
#define PERM_YZX 5
#define PERM_ZYX 6

#define FTYPE_BitwiseAnd 1
#define FTYPE_BitwiseOr 2
#define FTYPE_BitwiseXor 3
#define FTYPE_Division 4
#define FTYPE_Gcd 5
#define FTYPE_LogicalAnd 6
#define FTYPE_LogicalOr 7
#define FTYPE_LogicalXor 8
#define FTYPE_Lshift 9
#define FTYPE_Maximum 10
#define FTYPE_Minimum 11
#define FTYPE_Mod 12
#define FTYPE_Multiply 13
#define FTYPE_Power 14
#define FTYPE_RshiftSigned 15
#define FTYPE_RshiftUnsigned 16

#if 0
  // CNAME macro builds the class name from the function, Primitive type,
  // and permutation.
#endif
#define CNAME(func, permute) func ## PRIMITIVE_CNAME ## permute

// ***** This file is automatically generated from FunctionBinary.java.jpp
// ***** (and files it recursively includes).

package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.derive.unary.*;
import daikon.inv.*;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.unary.scalar.*;
import daikon.suppress.*;
import java.lang.reflect.*;
import java.util.*;
import java.util.logging.Logger;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.dataflow.qual.SideEffectFree;
import org.plumelib.util.ArraysPlume;
import org.plumelib.util.MathPlume;
import typequals.prototype.qual.NonPrototype;
import typequals.prototype.qual.Prototype;

/**
 * Base class for each of the CLASSNAME functions and permutatons. Most of the work is done
 * here. The subclasses basically define the function and return information describing the function
 * and permutation to these methods.
 */
@SuppressWarnings("UnusedVariable")  // generated code, complex rules for when var is used
public abstract class CLASSNAME extends SUPERCLASS {
  static final long serialVersionUID = 20031030L;

  /** Boolean. True if CLASSNAME invariants should be considered. */
  public static boolean dkconfig_enabled = false;

  public static Logger debug =
    Logger.getLogger("daikon.inv.ternary.threeScalar.#CLASSNAME");

  static final int[][] var_indices;
  static {
    var_indices = new int[7][];
    var_indices[PERM_XYZ] = new int[] { 0, 1, 2 };
    var_indices[PERM_YXZ] = new int[] { 1, 0, 2 };
    var_indices[PERM_ZXY] = new int[] { 2, 0, 1 };
    var_indices[PERM_XZY] = new int[] { 0, 2, 1 };
    var_indices[PERM_YZX] = new int[] { 1, 2, 0 };
    var_indices[PERM_ZYX] = new int[] { 2, 1, 0 };
  }

  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  protected @Prototype CLASSNAME() {
    super();
  }

  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  @Override
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

    // Make sure that each variable is integral (not boolean or hashcode)
    if (!vis[0].file_rep_type.IS_INTEGRAL
        || !vis[1].file_rep_type.IS_INTEGRAL
        || !vis[2].file_rep_type.IS_INTEGRAL)
      return false;

    return true;
  }

  // check_modified relies on func having no side effects.
  abstract PRIMITIVE func(PRIMITIVE arg1, PRIMITIVE arg2);
  @Pure
  abstract boolean is_symmetric();
  abstract String[] get_method_name(@GuardSatisfied CLASSNAME this);
  abstract int get_var_order(@GuardSatisfied CLASSNAME this);
  abstract void set_function_id(int function_id);
  abstract int get_function_id();

  /**
   * Map from function name (eg, MultiplyLong, MinimumFloat) to an array of instances (one for each
   * valid permutation) for that function.
   */
  private static Map<String,@Prototype CLASSNAME[]> functions = new LinkedHashMap<>();

  /**
   * A list indexed by function number to an array of instances (one for each valid permutation) for
   * that function. The array is the same one as is stored in the functions Map. This provides a
   * faster access mechanism once we have the function id (which are calculated the first time
   * through).
   */
  private static List<@Prototype CLASSNAME[]> func_list = new ArrayList<>();

  private static void build_func_list() {

    // Reflection seems to confuse clover
    // CLOVER:OFF

    // Build the map of functions to array of instances for that function
    debug.fine("Processing " + #CLASSNAME);
    functions = new LinkedHashMap<>();
    @SuppressWarnings("unchecked")
    Class<@Prototype CLASSNAME>[] subclasses = (Class<@Prototype CLASSNAME>[]) CLASSNAME.class.getDeclaredClasses();
    for (int ii = 0; ii < subclasses.length; ii++) {
      Class<@Prototype CLASSNAME> subc = subclasses[ii];
      String function = subc.getName();
      if (function.indexOf("CLOVER") >= 0) {
        continue;
      }
      function = function.replaceFirst(".*FunctionBinary\\$", "");
      function = function.replaceFirst("_.*", "");
      if (function.equals("SubClass")) {
        continue;
      }
      @Prototype CLASSNAME[] fb_arr = functions.get(function);
      if (fb_arr == null) {
        fb_arr = new @Prototype CLASSNAME[7];
        functions.put(function, fb_arr);
        func_list.add(fb_arr);
      }
      int func_id = func_list.indexOf(fb_arr);
      @SuppressWarnings({"nonprototype"})
      @Prototype CLASSNAME fb;
      try {
        Constructor<@Prototype CLASSNAME> con = subc.getDeclaredConstructor(new Class<?>[] {});
        fb = con.newInstance(new Object[] {});
      }  catch (Exception e) {
        throw new Error(" can't create instance for " + subc.getName()
                        + ": '" + e + "' ii = " + ii);
      }
      assert fb_arr[fb.get_var_order()] == null;
      fb_arr[fb.get_var_order()] = fb;
      fb.set_function_id(func_id);
      debug.fine("Adding " + function + " " + fb.getClass().getName()
                  + " " + fb.get_var_order() + " " + fb.get_function_id());
    }
    // CLOVER:ON
  }

#if 0
  // JHP: remove this
  /**
   * Returns a list of all of the CLASSNAME invariants setup for the specified slice. Any invariants
   * are NI suppressed are not included. These are instantiated when their suppressors are
   * falsified.
   */
  public static List<Invariant> instantiate_all(PptSlice slice) {

    // If this is the first call
    if (functions.isEmpty()) {
      build_func_list();
    }

    // Instantiate all of the subclasses and return them
    List<Invariant> result = new ArrayList<>();
    for (@Prototype CLASSNAME[] fb_arr : func_list) {
      for (int jj = 1; jj < fb_arr.length; jj++) {
        @Prototype CLASSNAME fb = fb_arr[jj];
        if (fb != null) {
          if (NIS.dkconfig_enabled) {
            NISuppressionSet ss = fb.get_ni_suppressions();
            // System.out.println ("attempting instantiation of " + fb.getClass());
            if ((ss == null) || !ss.suppressed(slice)) {
              Invariant inv = fb.instantiate_dyn(slice);
              if (Debug.logOn() && (inv != null)) {
                inv.log("instantiated non-suppressed invariant %s", inv.format());
              }
              result.add(inv);
            }
          } else /* NIS not enabled */ {
            result.add(fb.instantiate_dyn(slice));
          }
        }
      }
    }

    return result;
  }
#endif

  /** Returns a list of all of the CLASSNAME prototype invariants. */
  public static List<@Prototype Invariant> get_proto_all() {

    List<@Prototype Invariant> result = new ArrayList<>();

    // If this is the first call
    if (functions.isEmpty()) {
      build_func_list();
    }

    // Get the proto invariant for all of the subclasses and return them
    for (@Prototype CLASSNAME[] fb_arr : func_list) {
      for (int jj = 1; jj < fb_arr.length; jj++) {
        @Prototype CLASSNAME fb = fb_arr[jj];
        if (fb != null) {
          result.add(fb);
        }
      }
    }
    return result;
  }

  /** Permuted result var. */
  public VarInfo resultVar() {
    return ppt.var_infos[var_indices[get_var_order()][0]];
  }

  /** Permuted arg1 var. */
  public VarInfo argVar1() {
    return ppt.var_infos[var_indices[get_var_order()][1]];
  }

  /** Permuted arg2 var. */
  public VarInfo argVar2() {
    return ppt.var_infos[var_indices[get_var_order()][2]];
  }

  /**
   * Apply the specified sample to the function, returning the result. The caller is responsible
   * for permuting the arguments.
   */
  public InvariantStatus check_ordered(PRIMITIVE result, PRIMITIVE arg1,
                                      PRIMITIVE arg2, int count) {
    // This implementation relies on func having no side effects.
    try {
      if (!EQUAL(result, func(arg1, arg2))) {
        return InvariantStatus.FALSIFIED;
      }
    } catch (Exception e) {
        return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   * Apply the specified sample to the function, returning the result. The caller is responsible
   * for permuting the arguments.
   */
  public InvariantStatus add_ordered(PRIMITIVE result, PRIMITIVE arg1,
                                      PRIMITIVE arg2, int count) {
    return check_ordered(result, arg1, arg2, count);
  }

  /**
   * Reorganize our already-seen state as if the variables had shifted order underneath us
   * (re-arrangement given by the permutation). We accomplish this by returning the class that
   * corresponds to the new permutation.
   */
  @Override
  protected Invariant resurrect_done(int[] permutation) {

    assert permutation.length == 3;
    assert ArraysPlume.fnIsPermutation(permutation);

    int[] new_order = new int[3];
    int[] old_order = var_indices[get_var_order()];

    // "permutation" is a permutation on the var_info array. old_order
    // was the permutation that took the formatted invariant to the
    // var_info array, so old_order^-1 is the permutation from the
    // var_info array to the old formatted invariant. We want to find
    // a new_order so that when we first do "permutation", then
    // apply the new permutation from the var_info array to the
    // formatted invariant, we get the same formatted invariant.
    // What we want, then. is:
    //    new_order^-1 o permutation = old_order^-1
    // rearranging, this is equivalent to
    //    new_order = permutation o old_order
    new_order[0] = permutation[old_order[0]];
    new_order[1] = permutation[old_order[1]];
    new_order[2] = permutation[old_order[2]];

    // Force symmetric functions into a canonical form so that
    // we can match them when necessary and they always print the same.
    // For example, order of 0, 1, 2 and 0, 2, 1 represent the same
    // invariant for a symmetric function.  This forces them to always
    // be represented as 0, 1, 2
    if (is_symmetric()) {
      if (new_order[2] < new_order[1]) {
        int tmp = new_order[2];
        new_order[2] = new_order[1];
        new_order[1] = tmp;
      }
    }

    // Look for the new order in the list of possible orders
    int var_order = -1;
    for (int i = 0; i < var_indices.length; i++) {
      if (Arrays.equals(new_order, var_indices[i])) {
        var_order = i;
        break;
      }
    }
    assert var_order != -1;

    // If the var order hasn't changed, we don't need to do anything
    if (var_order == get_var_order()) {
      return this;
    }

    // Find the class that corresponds to the new order
    if (functions.isEmpty()) {
      build_func_list();
    }
    int func_id = get_function_id();
    @Prototype CLASSNAME[] fb_arr = func_list.get(func_id);
    assert fb_arr != null;
    for (int ii = 0; ii < fb_arr.length; ii++) {
      if ((fb_arr[ii] != null) && (fb_arr[ii].get_var_order() == var_order)) {
        return fb_arr[ii].instantiate_dyn(ppt);
      }
    }

    throw new Error("Could not find new ordering");
  }

  @Override
  public String repr(@GuardSatisfied CLASSNAME this) {
    return format();
  }

  @SideEffectFree
  @Override
  public String format_using(@GuardSatisfied CLASSNAME this, OutputFormat format) {
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }
    if (format == OutputFormat.CSHARPCONTRACT) {
      return format_csharp_contract();
    }

    int var_order = get_var_order();
    String[] methodname = get_method_name();

    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];

    String argresult_name = argresultvi.name_using(format);
    String arg1_name = arg1vi.name_using(format);
    String arg2_name = arg2vi.name_using(format);

    if (format == OutputFormat.DAIKON) {
      return argresult_name + " == (" + methodname[0] + arg1_name
        + methodname[1] + arg2_name + methodname[2] + ")";
    }

    if (format.isJavaFamily()) {
      if (methodname[1].equals(" || ") || methodname[1].equals(" && ")) {
        return "(" +  argresult_name + " != 0) == ((" + methodname[0] + arg1_name + " != 0)"
          + methodname[1] + "(" + arg2_name + methodname[2] + " != 0))";
      } else {
        return argresult_name + " == (" + methodname[0] + arg1_name
          + methodname[1] + arg2_name + methodname[2] + ")";
      }
    }

    return format_unimplemented(format);
  }

  public String format_simplify(@GuardSatisfied CLASSNAME this) {
    int var_order = get_var_order();
    String[] methodname = get_method_name();
    VarInfo[] vis = ppt.var_infos;

    String result = vis[var_indices[var_order][0]].simplifyFixedupName();
    String arg1 = vis[var_indices[var_order][1]].simplifyFixedupName();
    String arg2 = vis[var_indices[var_order][2]].simplifyFixedupName();
    String func = null;
    if (methodname[1].equals(" * ")) {
      func = "*";
    } else if (methodname[1].equals(" | ")) {
      func = "|java-bitwise-or|";
    } else if (methodname[1].equals(" || ")) {
      func = "|java-logical-or|";
    } else if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min(")) {
        func = "min";
      } else if (methodname[0].equals("java.lang.Math.max(")) {
        func = "max";
      } else if (methodname[0].equals("org.plumelib.util.MathPlume.gcd(")) {
        func = "gcd";
      } else if (methodname[0].equals("java.lang.Math.pow(")) {
        func = "pow";
      } else if (methodname[0].equals("org.plumelib.util.MathPlume.logicalXor(")) {
        func = "|java-logical-xor|";
      }
    } else {
      assert methodname[0].equals("");
      assert methodname[2].equals("");
      func = "|java-" + methodname[1].trim() + "|";
    }
    if (func == null) {
      return "format_simplify_contract() doesn't know function " + methodname[0] + "-"
        + methodname[1] + "-" + methodname[2];
    }
    return "(EQ " + result + " (" + func + " " + arg1 + " " + arg2 + "))";
  }

  public String format_csharp_contract(@GuardSatisfied CLASSNAME this) {
    int var_order = get_var_order();
    String[] methodname = get_method_name();

    VarInfo argresultvi = ppt.var_infos[var_indices[var_order][0]];
    VarInfo arg1vi = ppt.var_infos[var_indices[var_order][1]];
    VarInfo arg2vi = ppt.var_infos[var_indices[var_order][2]];
    String result = argresultvi.csharp_name();
    String arg1 = arg1vi.csharp_name();
    String arg2 = arg2vi.csharp_name();
    String operator = null;

    if (methodname[1].equals(" * ")) {
      operator = "*";
    } else if (methodname[1].equals(" | ")) {
      operator = "|";
    } else if (methodname[1].equals(" & ")) {
      operator = "&";
    } else if (methodname[1].equals(" / ")) {
      operator = "/";
    } else if (methodname[1].equals(" ^ ")) {
      operator = "^";
    } else if (methodname[1].equals(" % ")) {
      operator = "%";
    } else if (methodname[1].equals(" && ")) {
      operator = "&&";
    } else if (methodname[1].equals(" || ")) {
      operator = "||";
    } else if (methodname[1].equals(" >> ")) {
      operator = ">>";
    } else if (methodname[1].equals(" >>> ")) {
      return result + " == " + arg1 + ".UnsignedRightShift(" + arg2 + ")";
      //return result + " == CSharpDaikonLib.Extensions.UnsignedRightShift(" + arg1 + ", " + arg2 + ")";
    } else if (methodname[1].equals(" << ")) {
      operator = "<<";
    }

    if (operator != null) {
      return result + " == (" + arg1 + " " + operator + " " + arg2 + ")";
    }

    String func = null;
    if (methodname[1].equals(", ")) {
      if (methodname[0].equals("java.lang.Math.min(")) {
        func = "Math.Min";
      } else if (methodname[0].equals("java.lang.Math.max(")) {
        func = "Math.Max";
      } else if (methodname[0].equals("org.plumelib.util.MathPlume.gcd(")) {
        return result + " == CSharpDaikonLib.Extensions.GCD(" + arg1 + ", " + arg2 + ")";
      } else if (methodname[0].equals("java.lang.Math.pow(")) {
        return result + " == " + arg1 + ".Pow(" + arg2 + ")";
      } else if (methodname[0].equals("org.plumelib.util.MathPlume.logicalXor(")) {
        return result + " == (" + arg1 + " ^ " + arg2 + ")";
      }
    } else {
      assert methodname[0].equals("");
      assert methodname[2].equals("");
      func = "|" + methodname[1].trim() + "|";
    }

    if (func == null) {
      return "format_csharp_contract() doesn't know function " + methodname[0] + "-" + methodname[1] + "-" + methodname[2];
    }
    return result + " == " + func + "(" + arg1 + ", " + arg2 + ")";
  }

  // If our classes match, we must match
  @Pure
  @Override
  public boolean isSameFormula(Invariant other) {
    return true;
  }
  @Override
  public double computeConfidence() {
    if (logOn()) {
      VarInfo v1 = ppt.var_infos[0];
      VarInfo v2 = ppt.var_infos[1];
      VarInfo v3 = ppt.var_infos[2];
      log("computeConfidence(%s: num_values = %s, num_values(%s)=%s, num_values(%s)=%s, num_values(%s)=%s",
          format(), ppt.num_values(),
          v1.name(), ppt.parent.num_values(v1),
          v2.name(), ppt.parent.num_values(v2),
          v3.name(), ppt.parent.num_values(v3));
    }
    return Invariant.conf_is_ge(ppt.num_values(), 5);
  }

  /** If the arg is a sequence size, return the sequence; otherwise return null. */
  private @Nullable VarInfo sized_sequence(VarInfo size) {
    if (size.derived instanceof SequenceLength) {
      return ((SequenceLength)size.derived).base;
    }
    return null;
  }

  @Pure
  @Override
  public @Nullable DiscardInfo isObviousDynamically(VarInfo[] vis) {

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    // Discard if any two of the three variables are the sizes of the
    // same arrays.
    VarInfo arr1 = sized_sequence(vis[0]);
    VarInfo arr2 = sized_sequence(vis[1]);
    VarInfo arr3 = sized_sequence(vis[2]);
    if (((arr1 != null) && (arr1 == arr2))
        || ((arr1 != null) && (arr1 == arr3))
        || ((arr2 != null) && (arr2 == arr3))) {
      return new DiscardInfo(this, DiscardCode.obvious,
                    "two are sizes of same array:  "
                    + vis[0].name() + " "
                    + vis[1].name() + " "
                    + vis[2].name());
    }

    return null;
  }

#if 0
  // Each of the functions is defined below.  Each must define the following
  // preprocessor variables:
  //
  //    FUNCTION    - Name of the function to be included in the classname
  //    FUNC        - Binary function to perform.  Must return a result
  //    METHOD_NAME - Initialization for a 3 element string array used to
  //                  print the invariants.  Invariants are formatted as:
  //
  //         'result = method_name[1] arg1 method_name[2] arg2 method_name[3]'
  //
  // There are also several optional variables that can be defined:
  //
  //    EQUALITY_SUPPRESS           - suppresses the invariant if all of its
  //                                  arguments are equal
  //    EQUALITY_MIN_MAX_SUPPRESS   - EQUALITY_SUPPRESS plus a suppression
  //                                  of min and max invariants when the
  //                                  result equals one of the args and
  //                                  is always greater than or less than
  //                                  the other argument.
  //    ARG1_BOUND                  - Specifies the lower and upper bound
  //                                  (inclusive) for arg1.  If the bound
  //                                  is violated, the invariant is destroyed
  //    ARG2_BOUND                  - Specifies the lower and upper bound
  //                                  (inclusive) for arg2.  If the bound
  //                                  is violated, the invariant is destroyed
  //    BOOLEAN_ARGS                - Specifies each argument is boolean.
  //                                  Any value other than 0 or 1 will
  //                                  destroy the invariant.
  //
  // After defining the appropriate variables, include
  // FunctionBinarySymmetric.java.jpp for symmetric functions or
  // FunctionBinaryNonSymmetric.java.jpp for non-symmetric functions.
#endif

#define FUNCTION Multiply
#define FTYPE FTYPE_Multiply
#define FUNC(arg1,arg2) arg1 * arg2
#define METHOD_NAME {"", " * ", ""}
#define EXACT
#define EXTRA_INV_DOC
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Minimum
#define FTYPE FTYPE_Minimum
  // #define EQUALITY_MIN_MAX_SUPPRESS
#define FUNC(arg1, arg2) Math.min(arg1, arg2)
#define METHOD_NAME {"java.lang.Math.min(", ", ", ")"}
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Maximum
#define FTYPE FTYPE_Maximum
  // #define EQUALITY_MIN_MAX_SUPPRESS
#define FUNC(arg1, arg2) Math.max(arg1, arg2)
#define METHOD_NAME {"java.lang.Math.max(", ", ", ")"}
#include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

#define FUNCTION Division
#define FTYPE FTYPE_Division
#define FUNC(arg1, arg2) (arg1 / arg2)
#define METHOD_NAME {"", " / ", ""}
#define EXACT
#include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#define FUNCTION Power
#define FTYPE FTYPE_Power
#define FUNC(arg1, arg2) POW(arg1, arg2)
#define METHOD_NAME {"java.lang.Math.pow(", ", ", ")"}
#define EXACT
#include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#if defined(TYPELONG)

  #define FUNCTION BitwiseAnd
  #define FTYPE FTYPE_BitwiseAnd
  // #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) (arg1 & arg2)
  #define METHOD_NAME {"", " & ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalAnd
  #define FTYPE FTYPE_LogicalAnd
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) && (arg2 != 0)) ? 1 : 0)
  #define METHOD_NAME {"", " && ", ""}
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC For logical operations, Daikon treats 0 as false and all other values as true.
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC

  #define FUNCTION BitwiseXor
  #define FTYPE FTYPE_BitwiseXor
  #define FUNC(arg1,arg2) (arg1 ^ arg2)
  #define METHOD_NAME {"", " ^ ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalXor
  #define FTYPE FTYPE_LogicalXor
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) ^ (arg2 != 0)) ? 1 : 0)
  // #define METHOD_NAME {"", " ^ ", ""}
  #define METHOD_NAME {"org.plumelib.util.MathPlume.logicalXor(", ", ", ")"}
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC For logical operations, Daikon treats 0 as false and all other values as true.
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC

  #define FUNCTION BitwiseOr
  #define FTYPE FTYPE_BitwiseOr
  // #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) (arg1 | arg2)
  #define METHOD_NAME {"", " | ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION LogicalOr
  #define FTYPE FTYPE_LogicalOr
  #define BOOLEAN_ARGS 1
  #define FUNC(arg1,arg2) (((arg1 != 0) || (arg2 != 0)) ? 1 : 0)
  #define METHOD_NAME {"", " || ", ""}
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC For logical operations, Daikon treats 0 as false and all other values as true.
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"
  #undef EXTRA_INV_DOC
  #define EXTRA_INV_DOC

  #define FUNCTION Gcd
  #define FTYPE FTYPE_Gcd
  // #define EQUALITY_SUPPRESS 1
  #define FUNC(arg1,arg2) MathPlume.gcd(arg1, arg2)
  #define METHOD_NAME {"org.plumelib.util.MathPlume.gcd(", ", ", ")"}
  #include "daikon/inv/ternary/threeScalar/FunctionBinarySymmetric.java.jpp"

  #define FUNCTION Mod
  #define FTYPE FTYPE_Mod
  #define FUNC(arg1,arg2) (arg1 % arg2)
  #define METHOD_NAME {"", " % ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION Lshift
  #define FTYPE FTYPE_Lshift
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 << arg2)
  #define METHOD_NAME {"", " << ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION RshiftSigned
  #define FTYPE FTYPE_RshiftSigned
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 >> arg2)
  #define METHOD_NAME {"", " >> ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

  #define FUNCTION RshiftUnsigned
  #define FTYPE FTYPE_RshiftUnsigned
  #define ARG2_BOUND {0, 63}
  #define FUNC(arg1,arg2) (arg1 >>> arg2)
  #define METHOD_NAME {"", " >>> ", ""}
  #include "daikon/inv/ternary/threeScalar/FunctionBinaryNonSymmetric.java.jpp"

#endif
}
