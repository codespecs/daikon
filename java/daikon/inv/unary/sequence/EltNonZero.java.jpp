#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define EQUAL(a,b) ((a) == (b))
  #define CLASSNAME EltNonZero
  #define CLASSSTRING "EltNonZero"
  #define SUPERCLASS SingleScalarSequence
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define DOUBLE_CAST(x) (double)(x)
  #define BASEISTYPE baseIsIntegral()
  #define PRIMITIVEVALUE longValue()
  #define ELTONEOF EltOneOf
  #define ELTLOWERBOUND EltLowerBound
  #define ELTUPPERBOUND EltUpperBound
  #define SEQUENCESCALARSUBSEQUENCE SequenceScalarSubsequence
  #define SEQUENCESCALARARBITRARYSUBSEQUENCE SequenceScalarArbitrarySubsequence
  #define EQUAL_ONE EltRangeInt.EqualOne
  #define EQUAL_MINUS_ONE EltRangeInt.EqualMinusOne
  #define VALUE_SET ValueSet.ValueSetScalarArray
#elif defined(TYPEDOUBLE)
  #define EQUAL(a,b) (Global.fuzzy.eq (a, b))
  #define CLASSNAME EltNonZeroFloat
  #define CLASSSTRING "EltNonZeroFloat"
  #define SUPERCLASS SingleFloatSequence
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define DOUBLE_CAST(x) (x)
  #define BASEISTYPE baseIsFloat()
  #define PRIMITIVEVALUE doubleValue()
  #define ELTONEOF EltOneOfFloat
  #define ELTLOWERBOUND EltLowerBoundFloat
  #define ELTUPPERBOUND EltUpperBoundFloat
  #define SEQUENCESCALARSUBSEQUENCE SequenceFloatSubsequence
  #define SEQUENCESCALARARBITRARYSUBSEQUENCE SequenceFloatArbitrarySubsequence
  #define EQUAL_ONE EltRangeFloat.EqualOne
  #define EQUAL_MINUS_ONE EltRangeFloat.EqualMinusOne
  #define VALUE_SET ValueSet.ValueSetFloatArray
#endif

// ***** This file is automatically generated from EltNonZero.java.jpp

package daikon.inv.unary.sequence;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.binary.twoSequence.*;
import daikon.inv.ValueSet;
import daikon.suppress.*;

import plume.*;

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.*;

/*>>>
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import typequals.*;
*/



/**
 * Represents the invariant "x != 0" where x represents all of the elements
 * of a sequence of PRIMITIVE.  Prints as <code>x[] elements != 0</code>.
 */

public final class CLASSNAME
  extends SUPERCLASS
{
  /**
   * Debug tracer.
   */
  public static final Logger debug =
    Logger.getLogger("daikon.inv.unary.sequence." + CLASSSTRING);


  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff EltNonZero invariants should be considered.
   */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  public CLASSNAME(PptSlice ppt) {
    super(ppt);
  }

  public /*@Prototype*/ CLASSNAME() {
    super();
  }

  private static /*@Prototype*/ CLASSNAME proto = new /*@Prototype*/ CLASSNAME ();

  /** Returns the prototype invariant for CLASSNAME */
  public static /*@Prototype*/ CLASSNAME get_proto() {
    return proto;
  }

  /** returns whether or not this invariant is enabled */
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** instantiate an invariant on the specified slice */
  protected CLASSNAME instantiate_dyn (/*>>> @Prototype CLASSNAME this,*/ PptSlice slice) {
    return new CLASSNAME (slice);
  }

  /**
   * Returns whether or not the variable is a pointer.
   */
  /*@Pure*/
  private boolean is_pointer(/*>>>@GuardSatisfied CLASSNAME this*/) {
    return (!ppt.var_infos[0].type.BASEISTYPE);
  }

  public String repr(/*>>>@GuardSatisfied CLASSNAME this*/) {
    return CLASSSTRING + varNames() + ": "
      + !falsified;
  }

  /*@SideEffectFree*/
  public String format_using(/*>>>@GuardSatisfied CLASSNAME this,*/ OutputFormat format) {
    if (format.isJavaFamily()) return format_java_family(format);

    if (format == OutputFormat.DAIKON) return format_daikon();
    if (format == OutputFormat.ESCJAVA) return format_esc();
    if (format == OutputFormat.CSHARPCONTRACT) return format_csharp_contract();
    if (format == OutputFormat.SIMPLIFY) return format_simplify();

    return format_unimplemented(format);
  }

  public String format_daikon(/*>>>@GuardSatisfied CLASSNAME this*/) {
    return var().name() + " elements " + "!=" + " "
           + (is_pointer() ? "null" : "0");
  }

  // We are a special case where a ghost field can actually talk about
  // array contents.
  /*@Pure*/
  public boolean isValidEscExpression() {
    return true;
  }

  public String format_esc(/*>>>@GuardSatisfied CLASSNAME this*/) {
    // If this is an entire array or Collection (not a slice), then
    //  * for arrays: use \nonnullelements(A)
    //  * for Collections: use collection.containsNull == false
    //    (the latter also requires that ghost field to get set)

    // if (var().isDerivedSubSequenceOf() == null) {
    if (var().is_direct_non_slice_array()) {
      VarInfo term = var().get_enclosing_var();
      String esc_name = null;
      if (term == null) {
        // Only happenes in internal format tests
        esc_name = var().name().replace ("[]", "");
      } else {
        // System.out.printf ("term = %s, var = %s%n", term.name, var().name);
        esc_name = term.esc_name();
      }
      if (var().type.isArray()) {
        return "\\nonnullelements(" + esc_name + ")";
      } else {
        return esc_name + ".containsNull == false";
      }
    }

    // If this is just part of an array or Collection (var is a
    // slice), then calling viname.esc_name() will always throw an
    // exception, since var() is certainly a sequence.  So use the
    // standard quantification.

    String[] form = VarInfo.esc_quantify (var());
    return form[0] + "(" + form[1] + " != "
           + (is_pointer() ? "null" : "0") + ")" + form[2];
  }

  public String format_java_family(/*>>>@GuardSatisfied CLASSNAME this,*/ OutputFormat format) {
    String retval =
      "daikon.Quant.eltsNotEqual(" + var().name_using(format)
      + (is_pointer() ? ", null" : ", 0") + ")";

    return retval;
  }

  public String format_csharp_contract(/*>>>@GuardSatisfied CLASSNAME this*/) {
    String[] split = var().csharp_array_split();
    return "Contract.ForAll(" + split[0] + ", x => x" + split[1] + " != " + (is_pointer() ? "null" : "0") + ")";
  }

  public String format_simplify(/*>>>@GuardSatisfied CLASSNAME this*/) {
    String[] form = VarInfo.simplify_quantify (var());
    return form[0] + "(NEQ " + form[1] + " "
      + (is_pointer() ? "null" : "0") + ")" + form[2];
  }

  public InvariantStatus check_modified(PRIMITIVE /*@Interned*/ [] a, int count) {
    for (int ai=0; ai<a.length; ai++) {
      PRIMITIVE v = a[ai];

      if (EQUAL(v, 0)) {
        return InvariantStatus.FALSIFIED;
      }
    }
    return InvariantStatus.NO_CHANGE;
  }

  public InvariantStatus add_modified(PRIMITIVE /*@Interned*/ [] a, int count) {

    //if (logOn()) {
    //  VALUE_SET vs = (VALUE_SET) ppt.var_infos[0].get_value_set();
    //  log ("max=" + vs.max() + " array=" + ArraysMDE.toString (a));
    //}

    return (check_modified (a, count));
  }

  protected double computeConfidence() {
    // Maybe just use 0 as the min or max instead, and see what happens:
    // see whether the "nonzero" invariant holds anyway.  (Perhaps only
    // makes sense to do if the {Lower,Upper}Bound invariant doesn't imply
    // the non-zeroness.)  In that case, do still check for no values yet
    // received.
    VALUE_SET vs = (VALUE_SET) ppt.var_infos[0].get_value_set();
    // log ("is_pointer()=" + is_pointer() + " vs.min=" + vs.min()
    //       + " vs.max=" + vs.max());
    if (!is_pointer() && ((vs.min() > 0) || (vs.max() < 0))) {
      return Invariant.CONFIDENCE_UNJUSTIFIED;
    } else {
      double probability_one_elt_nonzero = 1 - confidence_one_elt_nonzero();
      double result
        = 1 - Math.pow(probability_one_elt_nonzero, ppt.num_samples());
      // if ((result < 0) || (result > 1))
      //  System.err.println ("bad result: vs.max=" + vs.max() + " vs.min="
      //                      + vs.min() + " conf="
      //                      + confidence_one_elt_nonzero() + " range="
      //                      + (vs.max() - vs.min() + 1)/ 1);
      return result;
    }
  }

  private double confidence_one_elt_nonzero() {
    double range;
    if (is_pointer()) {
      range = 3;
    } else {
      int modulus = 1;

      // I need to come back and make this work.
      // {
      //   for (Invariant inv : ppt.invs) {
      //     if ((inv instanceof Modulus) && inv.enoughSamples()) {
      //       modulus = ((Modulus) inv).modulus;
      //       break;
      //     }
      //   }
      // }

      // Perhaps I ought to check that it's possible (given the modulus
      // constraints) for the value to be zero; otherwise, the modulus
      // constraint implies non-zero.
      VALUE_SET vs = (VALUE_SET) ppt.var_infos[0].get_value_set();
      range = (DOUBLE_CAST(vs.max()) - vs.min() + 1) / modulus;
    }
    return 1.0/range;
  }


  /*@Pure*/
  public boolean isSameFormula(Invariant other) {
    assert other instanceof CLASSNAME;
    return true;
  }

  /*@Pure*/
  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof ELTONEOF) {
      ELTONEOF eoo = (ELTONEOF) other;
      if ((eoo.num_elts() == 1) && (((NUMWRAPPER)eoo.elt()).PRIMITIVEVALUE == 0)) {
        return true;
      }
    }
    return false;
  }

  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousStatically(VarInfo[] vis) {
    // This test doesn't seem right: the invariant is obvious if the
    // elements don't have null, not if the collection doesn't have null.
    if (!vis[0].aux.hasNull()) {
      // If it's not a number and null doesn't have special meaning...
      return new DiscardInfo(this, DiscardCode.obvious, "'null' has no special meaning for " + vis[0].name());
    }
    return super.isObviousStatically (vis);
  }


  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v1 = vis[0];

    // (a[] == []) ==> a[] != 0
    if (ppt.parent.is_empty (v1)) {
      return new DiscardInfo (this, DiscardCode.obvious, v1 + "is empty");
    }

    // (a[] > 0) v (a[] < 0) ==> a[] != 0
    ELTLOWERBOUND lb = (ELTLOWERBOUND) ppt.parent.find_inv_by_class
                                                    (vis, ELTLOWERBOUND.class);
    if ((lb != null) && (lb.min() > 0)) {
      return new DiscardInfo (this, DiscardCode.obvious, v1 + " > " + lb.min());
    }
    ELTUPPERBOUND ub = (ELTUPPERBOUND) ppt.parent.find_inv_by_class
                                                    (vis, ELTUPPERBOUND.class);
    if ((ub != null) && (ub.max() < 0)) {
      return new DiscardInfo (this, DiscardCode.obvious, v1 + " < " + ub.max());
    }

    // For every other EltNonZero at this program point, see if there is a
    // subsequence relationship between that array and this one.

    if (debug.isLoggable(Level.FINE)) {
      debug.fine ("Testing isObviousDynamically for " + vis[0].name());
    }

    PptTopLevel parent = ppt.parent;
    for (Iterator<Invariant> itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = itor.next();
      if ((inv instanceof CLASSNAME) && (inv != this) && inv.enoughSamples()) {
        VarInfo v2 = inv.ppt.var_infos[0];
        if (debug.isLoggable(Level.FINE)) {
          debug.fine ("  Have to test: " + inv.repr());
        }

        if (Debug.logOn()) {
          Daikon.current_inv = this;
        }
        if (parent.is_subsequence (v1, v2)) {
          return new DiscardInfo (this, DiscardCode.obvious, v1.name() +
                                  " is a subsequence of " + v2.name());
        }
      }
    }

    return null;
  }

  // Look up a previously instantiated invariant.
  public static /*@Nullable*/ CLASSNAME find(PptSlice ppt) {
    assert ppt.arity() == 1;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof CLASSNAME) {
        return (CLASSNAME) inv;
      }
    }
    return null;
  }

  /** NI suppressions, initialized in get_ni_suppressions() */
  private static /*@Nullable*/ NISuppressionSet suppressions = null;

  /** returns the ni-suppressions for CLASSNAME */
  /*@Pure*/
  public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
    if (suppressions == null) {
      NISuppressee suppressee = new NISuppressee (CLASSNAME.class, 1);

      // suppressor definitions (used in suppressions below)
      NISuppressor v_eq_one = new NISuppressor (0, EQUAL_ONE.class);
      NISuppressor v_eq_minus_one = new NISuppressor (0, EQUAL_MINUS_ONE.class);

      suppressions = new NISuppressionSet (new NISuppression[] {
          // v == 1 ==> v != 0
          new NISuppression (v_eq_one, suppressee),
          // v == -1 ==> v != 0
          new NISuppression (v_eq_minus_one, suppressee),
        });
    }

    return suppressions;
  }

}
