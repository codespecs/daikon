#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SCALAR) || defined(STRING) || defined(FLOAT) \
      || defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(FLOATSEQUENCE) \
      || defined(ELT) || defined(ELTSTRING) || defined(ELTFLOAT))
  #error "One of SCALAR, STRING, FLOAT, SEQUENCE, STRINGSEQUENCE, FLOATSEQUENCE, ELT, ELTSTRING, or ELTFLOAT must be defined"
#endif

#if defined(SCALAR) || defined(STRING) || defined(FLOAT)
  #define IS_SCALAR
  #if defined(SCALAR) || defined(FLOAT)
    #define IS_NUMERIC
  #endif
#elif defined(SEQUENCE) || defined(STRINGSEQUENCE) || defined(FLOATSEQUENCE)
  #define IS_SEQUENCE
  #if defined(SEQUENCE) || defined(FLOATSEQUENCE)
    #define IS_SEQUENCE_NUMERIC
  #endif
#elif defined(ELT) || defined(ELTSTRING) || defined(ELTFLOAT)
  #define IS_ELT
  #if defined(ELT) || defined(ELTFLOAT)
    #define IS_ELT_NUMERIC
  #endif
#else
  #error "Impossible"
#endif

#if defined(SCALAR) || defined(SEQUENCE) || defined(ELT)
  #define BASE_INT
  #define BASE_NUMERIC
#elif defined(FLOAT) || defined(FLOATSEQUENCE) || defined(ELTFLOAT)
  #define BASE_FLOAT
  #define BASE_NUMERIC
#elif defined(STRING) || defined(STRINGSEQUENCE) || defined(ELTSTRING)
  #define BASE_STRING
#else
  #error "Impossible"
#endif


#define EQUALS(a,b) ((a) == (b))
#define JAVA_EQUALS_STRING(x) " == " + x

#if defined(SCALAR)
  #define SCALARPKG scalar
  #define INT long
  #define INTARRAY long[]
  #define INTARRAY_UNINTERNED long[]
  #define INT_PRINTED long
  #define ONEOFSCALAR OneOfScalar
  #define ONEOFSCALAR_STRING "OneOfScalar"
  #define SINGLESCALAR SingleScalar
  #define NUMWRAPPER Long
  #if 0
     TOSTRING is never called for hashcodes: we never print actual values.
  #endif
  #define TOSTRING(x) ((Integer.MIN_VALUE <= x && x <= Integer.MAX_VALUE) ? String.valueOf(x) : (String.valueOf(x) + "L"))
  #define TOSTRING_SIMPLIFY(x) simplify_format_long(x)
  #define NAME var().name()
  #define NONZERO NonZero
  #define ELTONEOF EltOneOf
  #define LOWERBOUND LowerBound
  #define UPPERBOUND UpperBound
#elif defined(FLOAT)
  #undef EQUALS
  #define EQUALS(a,b) (Global.fuzzy.eq(a, b) || (Double.isNaN(a) && Double.isNaN(b)))
  #undef JAVA_EQUALS_STRING
  #define JAVA_EQUALS_STRING(x) ".equals(" + x + ")"
  #define SCALARPKG scalar
  #define INT double
  #define INTARRAY double[]
  #define INTARRAY_UNINTERNED double[]
  #define INT_PRINTED double
  #define ONEOFSCALAR OneOfFloat
  #define ONEOFSCALAR_STRING "OneOfFloat"
  #define SINGLESCALAR SingleFloat
  #define NUMWRAPPER Double
  #define TOSTRING(x) (Double.isNaN(x) ? "Double.NaN" : String.valueOf(x))
  #define TOSTRING_SIMPLIFY(x) simplify_format_double(x)
  #define NAME var().name()
  #define NONZERO NonZeroFloat
  #define ELTONEOF EltOneOfFloat
  #define LOWERBOUND LowerBoundFloat
  #define UPPERBOUND UpperBoundFloat
#elif defined(STRING)
  #define COMMENT No "EQUALS(a,b)" because we intern and so can use equality tests
  #undef JAVA_EQUALS_STRING
  #define JAVA_EQUALS_STRING(x) ".equals(" + x + ")"
  #define SCALARPKG string
  #define INT /*@Interned*/ String
  #define INTARRAY /*@Interned*/ String[]
  #define INTARRAY_UNINTERNED String[]
  #define INT_PRINTED String
  #define ONEOFSCALAR OneOfString
  #define ONEOFSCALAR_STRING "OneOfString"
  #define SINGLESCALAR SingleString
  #define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.escapeNonASCII(x) + "\"")
  #define TOSTRING_SIMPLIFY(x) simplify_format_string(x)
  #define NAME var().name()
#elif defined(SEQUENCE)
  #define SCALARPKG sequence
  #define INT long /*@Interned*/ []
  #define INTARRAY long[] /*@Interned*/ []
  #define INTARRAY_UNINTERNED long[][]
  #define INT_PRINTED long[]
  #define ONEOFSCALAR OneOfSequence
  #define ONEOFSCALAR_STRING "OneOfSequence"
  #define SINGLESCALAR SingleScalarSequence
  #define TOSTRING(x) ArraysMDE.toString(x)
  #define TOSTRINGELEMENT(x) ((Integer.MIN_VALUE <= x && x <= Integer.MAX_VALUE) ? String.valueOf(x) : (String.valueOf(x) + "L"))
  #define TOSTRING_SIMPLIFY(x) simplify_format_long(x)
  #define ELT_EQUALS(a,b) ((a) == (b))
  #define NAME var().name()
#elif defined(FLOATSEQUENCE)
  #define SCALARPKG sequence
  #define INT double /*@Interned*/ []
  #define INTARRAY double[] /*@Interned*/ []
  #define INTARRAY_UNINTERNED double[][]
  #define INT_PRINTED double[]
  #define ONEOFSCALAR OneOfFloatSequence
  #define ONEOFSCALAR_STRING "OneOfSequenceFloat"
  #define SINGLESCALAR SingleFloatSequence
  #define TOSTRING(x) ArraysMDE.toString(x)
  #define TOSTRINGELEMENT(x) (Double.isNaN(x) ? "Double.NaN" : String.valueOf(x))
  #define TOSTRING_SIMPLIFY(x) simplify_format_double(x)
  #define ELT_EQUALS(a,b) (((a) == (b)) || (Double.isNaN(a) &&Double.isNaN(b)))
  #define NAME var().name()
#elif defined(STRINGSEQUENCE)
  #define SCALARPKG stringsequence
  #define INT /*@Interned*/ String /*@Interned*/ []
  #define INTARRAY /*@Interned*/ String[] /*@Interned*/ []
  #define INTARRAY_UNINTERNED /*@Interned*/ String[][]
  #define INT_PRINTED String[]
  #define ONEOFSCALAR OneOfStringSequence
  #define ONEOFSCALAR_STRING "OneOfStringSequence"
  #define SINGLESCALAR SingleStringSequence
  #define TOSTRING(x) ArraysMDE.toString(x)
  #define TOSTRINGELEMENT(x) ((x==null) ? "null" : "\"" + UtilMDE.escapeNonASCII(x) + "\"")
  #define TOSTRING_SIMPLIFY(x) simplify_format_string(x)
  #define ELT_EQUALS(a,b) ((a) == (b))
  #define NAME var().name()
#elif defined(ELT)
  #define SCALARPKG sequence
  #define INT long
  #define INTARRAY long[]
  #define INTARRAY_UNINTERNED long[]
  #define INT_PRINTED long
  #define NUMWRAPPER Long
  #define ONEOFSCALAR EltOneOf
  #define ONEOFSCALAR_STRING "EltOneOf"
  #define SINGLESCALAR SingleScalarSequence
  #define TOSTRING(x) (((x == 0) && (var().file_rep_type == ProglangType.HASHCODE_ARRAY)) ? "null" : ((Integer.MIN_VALUE <= x && x <= Integer.MAX_VALUE) ? String.valueOf(x) : (String.valueOf(x) + "L")))
  #define TOSTRING_SIMPLIFY(x) (((x == 0) && (var().file_rep_type == ProglangType.HASHCODE_ARRAY)) ? "null" : simplify_format_long(x))
  #define NAME var().name() + " elements"
  #define NONZERO EltNonZero
  #define LOWERBOUND LowerBound
  #define UPPERBOUND UpperBound
#elif defined(ELTFLOAT)
  #undef EQUALS
  #define EQUALS(a,b) (Global.fuzzy.eq(a, b) || (Double.isNaN(a) && Double.isNaN(b)))
  #define SCALARPKG sequence
  #define INT double
  #define INTARRAY double[]
  #define INTARRAY_UNINTERNED double[]
  #define INT_PRINTED double
  #define NUMWRAPPER Double
  #define ONEOFSCALAR EltOneOfFloat
  #define ONEOFSCALAR_STRING "EltOneOfFloat"
  #define SINGLESCALAR SingleFloatSequence
  #define TOSTRING(x) (Double.isNaN(x) ? "Double.NaN" : String.valueOf(x))
  #define TOSTRING_SIMPLIFY(x) simplify_format_double(x)
  #define NAME var().name() + " elements"
  #define NONZERO EltNonZeroFloat
  #define LOWERBOUND LowerBoundFloat
  #define UPPERBOUND UpperBoundFloat
#elif defined(ELTSTRING)
  #define SCALARPKG stringsequence
  #define INT /*@Interned*/ String
  #define INTARRAY /*@Interned*/ String[]
  #define INTARRAY_UNINTERNED String[]
  #define INT_PRINTED String
  #define ONEOFSCALAR EltOneOfString
  #define ONEOFSCALAR_STRING "EltOneOfString"
  #define SINGLESCALAR SingleStringSequence
  #define TOSTRING(x) ((x==null) ? "null" : "\"" + UtilMDE.escapeNonASCII(x) + "\"")
  #define TOSTRING_SIMPLIFY(x) simplify_format_string(x)
  #define NAME var().name() + " elements"
#else
  #error "One of SCALAR, STRING, FLOAT, SEQUENCE, STRINGSEQUENCE, FLOATSEQUENCE, ELT, ELTSTRING, or ELTFLOAT must be defined"
#endif

// ***** This file is automatically generated from OneOf.java.jpp

package daikon.inv.unary.SCALARPKG;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.OneOf;
#ifdef IS_NUMERIC
  import daikon.derive.unary.*;
  import daikon.inv.unary.sequence.*;
  import daikon.inv.binary.sequenceScalar.*;
#endif
#ifdef IS_ELT_NUMERIC
  import daikon.inv.unary.scalar.*;
  import daikon.inv.binary.twoSequence.SubSequence;
#endif

import plume.*;

import java.io.*;
import java.util.logging.Logger;
import java.util.logging.Level;
#if defined(BASE_STRING)
  import java.util.regex.*;
#endif
import java.util.*;

/*>>>
import org.checkerframework.checker.initialization.qual.*;
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import org.checkerframework.framework.qual.*;
import typequals.*;
*/

// This subsumes an "exact" invariant that says the value is always exactly
// a specific value.  Do I want to make that a separate invariant
// nonetheless?  Probably not, as this will simplify implication and such.

#if defined (SCALAR)
  /**
   * Represents long scalars that take on only a few distinct values.  Prints
   * as either <code>x == c</code> (when there is only one value),
   * <code>x one of {c1, c2, c3}</code> (when there are multiple values),
   * or <code>x has only one value</code> (when <code>x</code> is
   * a hashcode (pointer) - this is because the numerical value of the
   * hashcode (pointer) is uninteresting).
   */
#elif defined (IS_SCALAR) || defined (IS_SEQUENCE)
  /**
   * Represents INT_PRINTED variables that take on only a few distinct
   * values. Prints as either
   * <code>x == c</code> (when there is only one value)
   * or as <code>x one of {c1, c2, c3}</code> (when there are multiple values).
   */
#else
  /**
   * Represents sequences of INT_PRINTED values where the elements of the sequence
   * take on only a few distinct values.  Prints as either
   * <code>x[] == c</code> (when there is only one value), or as
   * <code>x[] one of {c1, c2, c3}</code> (when there are multiple values).
   */
#endif

public final class ONEOFSCALAR
  extends SINGLESCALAR
  implements OneOf
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  /**
   * Debugging logger.
   */
  public static final Logger debug
    = Logger.getLogger (ONEOFSCALAR.class.getName());

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff OneOf invariants should be considered.
   */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  /**
   * Positive integer.  Specifies the maximum set size for this type
   * of invariant (x is one of <code>size</code> items).
   */
#if defined(STRINGSEQUENCE)
  public static int dkconfig_size = 2;
#else
  public static int dkconfig_size = 3;
#endif

#ifdef BASE_INT
  /**
   * Boolean.  If true, invariants describing hashcode-typed variables
   * as having any particular value will have an artificial value
   * substituted for the exact hashhode values.  The artificial values
   * will stay the same from run to run even if the actual hashcode
   * values change (as long as the OneOf invariants remain the same).
   * If false, hashcodes will be formatted as the application of a
   * hashcode uninterpreted function to an integer representing the
   * bit pattern of the hashcode.  One might wish to omit the exact
   * values of the hashcodes because they are usually uninteresting;
   * this is the same reason they print in the native Daikon format,
   * for instance, as <code>var has only one value</code> rather than
   * <code>var == 150924732</code>.
   */
  public static boolean dkconfig_omit_hashcode_values_Simplify = false;
#endif

  // Probably needs to keep its own list of the values, and number of each seen.
  // (That depends on the slice; maybe not until the slice is cleared out.
  // But so few values is cheap, so this is quite fine for now and long-term.)

  /*@Unused(when=Prototype.class)*/
  private INTARRAY elts;
  /*@Unused(when=Prototype.class)*/
  private int num_elts;


  public /*@Prototype*/ ONEOFSCALAR () {
    super();
  }

  public ONEOFSCALAR (PptSlice slice) {
    super (slice);
#if defined(SEQUENCE)
    // Elements are interned, so can test with ==
    // (in the general online case, it's not worth interning).
    elts = new long[dkconfig_size] /*@Interned*/ [];
#elif defined(FLOATSEQUENCE)
    // Elements are interned, so can test with == (except that NaN != NaN)
    // (in the general online case, it's not worth interning).
    elts = new double[dkconfig_size] /*@Interned*/ [];
#elif defined(STRINGSEQUENCE)
    // Elements are interned, so can test with ==
    // (in the general online case, it's not worth interning).
    elts = new /*@Interned*/ String [dkconfig_size] /*@Interned*/ [];
#else
    elts = new INT[dkconfig_size];
#endif
    num_elts = 0;

#if defined(IS_ELT) || defined(IS_SEQUENCE)
    // var() is initialized by the super constructor
    assert var().is_array() :
      String.format ("In %s constructor, var %s (type=%s, rep_type=%s) should be an array",
                     ONEOFSCALAR_STRING, var().name(), var().type, var().rep_type);
#endif
  }

  private static /*@Prototype*/ ONEOFSCALAR proto = new /*@Prototype*/ ONEOFSCALAR ();

  /** Returns the prototype invariant for ONEOFSCALAR */
  public static /*@Prototype*/ ONEOFSCALAR get_proto() {
    return proto;
  }

  /** returns whether or not this invariant is enabled */
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** instantiate an invariant on the specified slice */
  public ONEOFSCALAR instantiate_dyn (/*>>> @Prototype ONEOFSCALAR this,*/ PptSlice slice) {
    return new ONEOFSCALAR(slice);
  }

#if defined(SCALAR)
  /*@Pure*/
  public boolean is_boolean(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
     return (var().file_rep_type == ProglangType.BOOLEAN);
  }
  /*@Pure*/
  public boolean is_hashcode(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return (var().file_rep_type == ProglangType.HASHCODE);
  }
#else
  /*@Pure*/
  public boolean is_boolean(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return (var().file_rep_type.elementType() == ProglangType.BOOLEAN);
  }
  /*@Pure*/
  public boolean is_hashcode(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return (var().file_rep_type.elementType() == ProglangType.HASHCODE);
  }
#endif

  @SuppressWarnings("interning") // clone method re-does interning
  /*@SideEffectFree*/
  public ONEOFSCALAR clone(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    ONEOFSCALAR result = (ONEOFSCALAR) super.clone();
    result.elts = elts.clone();
#ifdef IS_SEQUENCE
    for (int i=0; i < num_elts; i++) {
      result.elts[i] = Intern.intern(elts[i].clone());
    }
#endif
    result.num_elts = this.num_elts;
    return result;
  }

  public int num_elts() {
    return num_elts;
  }

  public Object elt() {
    return elt(0);
  }

  public Object elt(int index) {
    if (num_elts <= index) {
      throw new Error("Represents " + num_elts + " elements, index " + index + " not valid");
    }
#if defined(SCALAR) || defined(ELT)
    // Not sure whether interning is necessary (or just returning an Integer
    // would be sufficient), but just in case...
    return Intern.internedLong(elts[index]);
#elif defined(FLOAT) || defined(ELTFLOAT)
    return Intern.internedDouble(elts[index]);
#else
    return elts[index];
#endif
  }

  @SuppressWarnings("interning") // generics bug in (at least interning) checker
#if defined(STRING) || defined(ELTSTRING)
  static Comparator<String> comparator = new UtilMDE.NullableStringComparator();
  #define COMPARATOR_ARG , comparator
#elif defined(SEQUENCE)
  static Comparator<long[]> comparator = new ArraysMDE.LongArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(FLOATSEQUENCE)
  static Comparator<double[]> comparator = new ArraysMDE.DoubleArrayComparatorLexical();
#define COMPARATOR_ARG , comparator
#elif defined(STRINGSEQUENCE)
  static Comparator<String[]> comparator = new ArraysMDE.ComparableArrayComparatorLexical<String>(); // need to figure out proper generic type -MDE
  #define COMPARATOR_ARG , comparator
#else
  #define COMPARATOR_ARG
#endif

  private void sort_rep(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    Arrays.sort(elts, 0, num_elts COMPARATOR_ARG);
  }

  public INT min_elt() {
    if (num_elts == 0) {
      throw new Error("Represents no elements");
    }
    sort_rep();
    return elts[0];
  }

  public INT max_elt() {
    if (num_elts == 0) {
      throw new Error("Represents no elements");
    }
    sort_rep();
    return elts[num_elts-1];
  }

  // Assumes the other array is already sorted
  public boolean compare_rep(int num_other_elts, INTARRAY other_elts) {
    if (num_elts != num_other_elts) {
      return false;
    }
    sort_rep();
    for (int i=0; i < num_elts; i++)
      if (! EQUALS(elts[i],other_elts[i])) // elements are interned
        return false;
    return true;
  }

  private String subarray_rep(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    // Not so efficient an implementation, but simple;
    // and how often will we need to print this anyway?
    sort_rep();
    StringBuffer sb = new StringBuffer();
    sb.append("{ ");
    for (int i=0; i<num_elts; i++) {
      if (i != 0) {
        sb.append(", ");
      }

#if defined(SCALAR) || defined(ELT) || defined(SEQUENCE) || defined(STRING) || defined(ELTSTRING)
      if (PrintInvariants.dkconfig_static_const_infer) {
        boolean curVarMatch = false;
        PptTopLevel pptt = ppt.parent;
        for (VarInfo vi : pptt.var_infos) {
          if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
            Object constantVal = vi.constantValue();
            if (constantVal.equals(elts[i])) {
              sb.append(vi.name());
              curVarMatch = true;
            }
          }
        }

        if (curVarMatch == false) {
          sb.append(TOSTRING(elts[i]));
        }
      } else {
        sb.append(TOSTRING(elts[i]));
      }
#elif defined(FLOAT) || defined(ELTFLOAT)
      if (PrintInvariants.dkconfig_static_const_infer) {
        boolean curVarMatch = false;
        PptTopLevel pptt = ppt.parent;
        for (VarInfo vi : pptt.var_infos) {
          if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
            // If variable is a double, then use fuzzy comparison
            if (vi.rep_type == ProglangType.DOUBLE) {
              Double constantVal = (Double)vi.constantValue();
              if (Global.fuzzy.eq(constantVal, elts[i]) || (Double.isNaN(constantVal) && Double.isNaN(elts[i]))) {
                sb.append(vi.name());
                curVarMatch = true;
              }
            }
            // Otherwise just use the equals method
            else {
              Object constantVal = vi.constantValue();
              if (constantVal.equals(elts[i])) {
                sb.append(vi.name());
                curVarMatch = true;
              }
            }
          }
        }

        if (curVarMatch == false) {
          sb.append(TOSTRING(elts[i]));
        }
      } else {
        sb.append(TOSTRING(elts[i]));
      }
#else
      sb.append(TOSTRING(elts[i]));
#endif
    }
    sb.append(" }");
    return sb.toString();
  }

  public String repr(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return ONEOFSCALAR_STRING + varNames() + ": "
      + "falsified=" + falsified
      + ", num_elts=" + num_elts
      + ", elts=" + subarray_rep();
  }

#if defined(IS_SEQUENCE_NUMERIC)
  private boolean all_nulls(/*>>>@GuardSatisfied ONEOFSCALAR this,*/ int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] != 0) {
        return false;
      }
    }
    return true;
  }
  private boolean no_nulls(/*>>>@GuardSatisfied ONEOFSCALAR this,*/ int value_no) {
    INT seq = elts[value_no];
    for (int i=0; i<seq.length; i++) {
      if (seq[i] == 0) {
        return false;
      }
    }
    return true;
  }
#endif

#if (defined(IS_SCALAR))
  public INT[] getElts() {
    INT[] temp = new INT[elts.length];
    for (int i=0; i < elts.length; i++) {
      temp[i] = elts[i];
    }
    return temp;
  }
#endif

  /*@SideEffectFree*/
  public String format_using(/*>>>@GuardSatisfied ONEOFSCALAR this,*/ OutputFormat format) {
    sort_rep();

    if (format.isJavaFamily()) {
      return format_java_family(format);
    }

    if (format == OutputFormat.DAIKON) {
      return format_daikon();
    } else if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    } else if (format == OutputFormat.ESCJAVA) {
      String result = format_esc();
      return result;
    } else if (format == OutputFormat.CSHARPCONTRACT) {
      return format_csharp_contract();
    } else {
      return format_unimplemented(format);
    }
  }

  public String format_daikon(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    String varname = NAME;
    if (num_elts == 1) {
      #if defined(SCALAR) || defined(ELT)
        if (is_boolean()) {
          if ((elts[0] != 0) && (elts[0] != 1)) {
              System.out.println ("WARNING:: Variable "
              + varname + " is of type boolean, but has non boolean value: "
              + elts[0]);
          }
          return varname + " == " + ((elts[0] == 0) ? "false" : "true");
        } else if (is_hashcode()) {
          if (elts[0] == 0) {
            return varname + " == " + "null";
          } else {
            return varname + " has only one value"
              // + " (hashcode=" + elts[0] + ")"
              ;
          }
        } else {
          if (PrintInvariants.dkconfig_static_const_infer) {
            PptTopLevel pptt = ppt.parent;
            for (VarInfo vi : pptt.var_infos) {
              if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
                Object constantVal = vi.constantValue();
                if (constantVal.equals(elts[0])) {
                  return varname + " == " + vi.name();
                }
              }
            }
          }
          return varname + " == " + TOSTRING(elts[0]);
        }
      #elif defined(SEQUENCE)
        if (is_hashcode()) {
          // we only have one value, because add_modified dies if more
          assert num_elts == 1;
          INT value = elts[0];
          if (value.length == 0) {
            return varname + " == []";
          } else if ((value.length == 1) && (value[0] == 0)) {
            return varname + " == [null]";
          } else if (no_nulls(0)) {
            return varname + " contains no nulls and has only one value, of length " + value.length;
          } else if (all_nulls(0)) {
            return varname + " contains only nulls and has only one value, of length " + value.length;
          } else {
            return varname + " has only one value, of length " + value.length;
          }
        } else {
          if (PrintInvariants.dkconfig_static_const_infer) {
            PptTopLevel pptt = ppt.parent;
            for (VarInfo vi : pptt.var_infos) {
              if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
                Object constantVal = vi.constantValue();
                if (constantVal.equals(elts[0])) {
                  return varname + " == " + vi.name();
                }
              }
            }
          }
          return varname + " == " + TOSTRING(elts[0]);
        }
      #elif defined(STRING) || defined(ELTSTRING)
        boolean is_type = is_type();
        if (! is_type) {
          return varname + " == " + TOSTRING(elts[0]);
        } else {
          // It's a type
          String str = elts[0];
          if ((str == null) || "null".equals(str)) {
            return varname + " == " + "null";
          } else {
            if (str.startsWith("[")) {
              str = UtilMDE.fieldDescriptorToBinaryName(str);
            }
            if (PrintInvariants.dkconfig_static_const_infer) {
              PptTopLevel pptt = ppt.parent;
              for (VarInfo vi : pptt.var_infos) {
                if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
                  Object constantVal = vi.constantValue();
                  if (constantVal.equals(str)) {
                    return varname + " == " + vi.name();
                  }
                }
              }
            }
            // ".class" (which is a suffix for a type name) and not
            // getClassSuffix (which is a suffix for an expression).
            return varname + " == " + str + ".class";
          }
        }
      #elif defined(FLOAT) || defined(ELTFLOAT)
        if (PrintInvariants.dkconfig_static_const_infer) {
          PptTopLevel pptt = ppt.parent;
          for (VarInfo vi : pptt.var_infos) {
            if (vi.isStaticConstant() && VarComparability.comparable(vi, var())) {
              if (vi.rep_type == ProglangType.DOUBLE) {
                Double constantVal = (Double)vi.constantValue();
                if (Global.fuzzy.eq(constantVal, elts[0]) || (Double.isNaN(constantVal) && Double.isNaN(elts[0]))) {
                  return varname + " == " + vi.name();
                }
              } else {
                Object constantVal = vi.constantValue();
                if (constantVal.equals(elts[0])) {
                  return varname + " == " + vi.name();
                }
              }
            }
          }
        }
        return varname + " == " + TOSTRING(elts[0]);
       #else
          return varname + " == " + TOSTRING(elts[0]);
       #endif
    } else {
      return varname + " one of " + subarray_rep();
    }
  }


#if defined(STRING) || defined(ELTSTRING)
  /*@Pure*/
  private boolean is_type(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return var().has_typeof();
  }
#endif



#if defined(BASE_STRING)
  private static Pattern dollar_char_pat = Pattern.compile("\\$([A-Za-z])");

  private static String format_esc_string2type(String str) {
    if ((str == null) || "null".equals(str)) {
      return "\\typeof(null)";
    }
    String type_str;
    if (str.startsWith("[")) {
      type_str = UtilMDE.fieldDescriptorToBinaryName(str);
    } else {
      type_str = str;
      if (type_str.startsWith("\"") && type_str.endsWith("\"")) {
        type_str = type_str.substring(1, type_str.length()-1);
      }
    }

    // Inner classes
    // type_str = type_str.replace('$', '.');
    // For named inner classes, convert "$" to ".".
    // For anonymous inner classes, leave as "$".
    Matcher m = dollar_char_pat.matcher(type_str);
    type_str = m.replaceAll(".$1");

    return "\\type(" + type_str + ")";
  }
#endif

#if defined(ELTSTRING) || defined(STRINGSEQUENCE)
  /*@Pure*/
  public boolean isValidEscExpression() {
    // format_esc will look at the particulars and decide
    return true;
  }
#endif

  public String format_esc(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    sort_rep();
#if defined(IS_ELT)
    String[] form = VarInfo.esc_quantify (var());
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname = var().esc_name();
#endif
    String result;
#if defined(ELTSTRING)
    // We cannot say anything about Strings in ESC, just types (which
    // Daikon stores as Strings).
    if (is_type() && (num_elts == 1)) {
      VarInfo base = var().get_enclosing_var();
      if ((base == null) || base.type.isArray()) {
        result = varname + " == " + format_esc_string2type(elts[0]);
      } else { // base is not an array, presume it is a collection
        VarInfo collection = base.get_enclosing_var();
        assert collection != null : "no enclosing var for " + base.name();
        assert collection != null : "@AssumeAssertion(nullness)";
        result = collection.esc_name() + ".elementType == "
            + format_esc_string2type(elts[0]);
        // Do not use the \forall, return this directly
        return result;
      }
    } else {
      result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      // Return immediately?  There is little point in wrapping "unimplemented".
    }
#elif defined(STRING)
    // We cannot say anything about Strings in ESC, just types (which
    // Daikon stores as Strings).
    if (! is_type()) {
      result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
    } else {
      // Format   \typeof(theArray) = "[Ljava.lang.Object;"
      //   as     \typeof(theArray) == \type(java.lang.Object[])
      // ... but still ...
      // format   \typeof(other) = "package.SomeClass;"
      //   as     \typeof(other) == \type(package.SomeClass)

      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + format_esc_string2type(elts[i]);
      }
    }
#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
  #if defined(SCALAR) || defined(ELT)
    if (is_boolean()) {
      assert num_elts == 1;
      assert (elts[0] == 0) || (elts[0] == 1);
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode()) {
      if (num_elts == 1) {
        if (elts[0] == 0) {
          result = varname + " == " + "null";
        } else {
          // This seems wrong, because there is already a "!= null" invariant.
          // This invariant (ONEOFSCALAR) just shouldn't print for ESC format.
          result = varname + " != null";
          // varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
        }
      } else if (num_elts == 2) {
        // add_modified allows two elements iff one is null
        assert elts[0] == 0;
        assert elts[1] != 0;
        return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      } else if (num_elts == 0) {
        // Do nothing
        return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      } else {
        throw new Error ("Contains more than 2 elements");
      }
    } else
  #endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }
        result += varname + " == " + TOSTRING(elts[i]);
      }
    }
#elif defined(IS_SEQUENCE_NUMERIC)
    String length = null;
    String forall = null;
  #if defined(SEQUENCE)
    if (is_hashcode()) {
      // we only have one value, because add_modified dies if more
      assert num_elts == 1;
      INT value = elts[0];
      if (var().isArray()) {
        length = null;
        if (!var().isSlice()) {
          length = var().get_length().esc_name() + " == " + value.length;
        }
        String[] form = VarInfo.esc_quantify (var());
        if (no_nulls(0)) {
          forall = form[0] + "(" + form[1] + " != null)" + form[2];
        } else if (all_nulls(0)) {
          forall = form[0] + "(" + form[1] + " == null)" + form[2];
        }
      }
    }
  #endif
    if (length == null) {
      if (forall == null) {
        return format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
      } else {
        result = forall;
      }
    } else {
      if (forall == null) {
        result = length;
      } else {
        result = "(" + length + ") && (" + forall + ")";
      }
    }
#elif defined(STRINGSEQUENCE)
    // If the variable expression is a raw sequence, examine its
    // element type(s).
    if (var().is_typeof()) {

      @SuppressWarnings("nullness")
      /*@NonNull*/ VarInfo sequence = var().get_enclosing_var();
      @SuppressWarnings("nullness")
      /*@NonNull*/ String varname = sequence.get_enclosing_var().esc_name();
      String type = null;
      boolean consistent = true;
      for (int i=0; consistent && i<num_elts; i++) {
        String[] elt = elts[i];
        for (int j=0; consistent && j<elt.length; j++) {
          String maybe = format_esc_string2type(elt[j]);
          if (type == null) {
            type = maybe;
          } else {
            consistent &= type.equals(maybe);
          }
        }
      }
      if (consistent && (type != null)) {
        if (sequence.type.isArray()) {
          return "\\elemtype(" + varname + ") == " + type;
        } else {
          return varname + ".elementType == " + type;
        }
      }
    }

    result = format_unimplemented(OutputFormat.ESCJAVA); // "needs to be implemented"
#endif
#if defined(IS_ELT)
    result = form[0] + "(" + result + ")" + form[2];
#endif
    return result;
  }

public String format_csharp_contract(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {

    /*@NonNull @NonRaw @Initialized*/ // UNDONE: don't understand why needed (markro)
    String result;

#if defined(IS_ELT)

    #if defined(ELT)
    String equalsString = " == ";
    String endString = "";
    #elif defined(ELTFLOAT)
    String equalsString = " == ";
    String endString = "";
    #elif defined(ELTSTRING)
    String equalsString = ".Equals(";
    String endString = ")";
    #endif

    String[] split = var().csharp_array_split();
    List<String> args_list = new ArrayList<String>();
    // Construct the array that unary value will be compared against.
    for (int i = 0; i < num_elts; i++) {
    #if defined(ELTSTRING)
      /*@NonNull @NonRaw @Initialized*/ // UNDONE: don't understand why needed (markro)
      String arg = is_type() ? "typeof(" + elts[i] + ")" : TOSTRING(elts[i]);
      args_list.add(arg);
    #else
      args_list.add(TOSTRING(elts[i]));
    #endif
    }
    String args = UtilMDE.join(args_list, ", ");

    if (num_elts == 0) { // If there are no elements, length must be 0.
      String varname = var().csharp_name();
      return varname + ".Count() == 0";
    } else if (num_elts == 1) {
    #if defined(BASE_INT)
      if (is_boolean()) {
        String bool_str = (elts[0] == 0) ? "false" : "true";
        result = "Contract.ForAll(" + split[0] + ", x => x" + split[1] + " == " + bool_str + ")";
      } else if (is_hashcode()) {
        String null_str = elts[0] == 0 ? " == null" : " != null"; // interned
        result = "Contract.ForAll(" + split[0] + ", x => x" + split[1] + null_str + ")";
      } else
    #endif
      {
        result = "Contract.ForAll(" + split[0] + ", x => x" + split[1] + equalsString + args + endString + ")";
      }
    } else {
      assert num_elts > 1;
      result = "Contract.ForAll(" + split[0] + ", x => " + "x" + split[1] + ".OneOf(" + args + "))";
    }

#elif defined(IS_SCALAR)

  String[] split = var().csharp_array_split();
  String varname = var().csharp_name();
  #if defined(IS_NUMERIC)

    #if defined(BASE_INT)

    if (is_boolean()) {
      assert num_elts == 1;
      assert (elts[0] == 0) || (elts[0] == 1);
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode()) {
      if (num_elts == 1) {
        if (elts[0] == 0) {
          result = varname + " == " + "null";
        } else {
          result = varname + " != null";
        }
      } else { // num_elts == 2
        // I have never observed this case happening.
        // Daikon: does not handle this case
        // ESC: returns unimplemented
        // Java: returns "true"
        // Probably safe to safe we do not need to worry about this.
        assert elts[0] == 0;
        assert elts[1] != 0;
        return format_unimplemented(OutputFormat.CSHARPCONTRACT);
      }
    } else

    #endif

      if (num_elts == 1) {
        result = varname + " == " + elts[0];
      } else {
        List<String> e = new ArrayList<String>();
        for (int i=0; i<num_elts; i++) {
          e.add(TOSTRING(elts[i]));
        }
        String exp = UtilMDE.join(e, ", ");

        if (var().is_array() && !var().isDerived()) {
            result = "Contract.ForAll(" + split[0] + ", x => x" + split[1] + ".OneOf(" + exp + "))";
        } else {
          result = varname + ".OneOf(" + exp + ")";
        }
      }

  #elif defined(STRING)

    if (is_type()) {
        List<String> names = new ArrayList<String>();
        for (int i=0; i<num_elts; i++) {
             String str = elts[i];
             if ((str == null) || "null".equals(str)) {
                 names.add(varname + " == null");
             } else {
                 names.add(varname + " == typeof(" + str + ")");
             }
        }
        result = UtilMDE.join(names, " || ");
    } else if (num_elts == 1) {
        String str = elts[0];
        result = (str == null || "null".equals(str))
               ? (varname + " == null")
               : (varname + ".Equals(" + TOSTRING(str) + ")");
    } else {
        List<String> names = new ArrayList<String>();
        for (int i=0; i<num_elts; i++) {
            String str = elts[i];
            names.add((str == null) ? "null" : TOSTRING(str));
        }
        result = varname + ".OneOf(" + UtilMDE.join(names, ", ") + ")";
    }

  #endif

#elif defined(IS_SEQUENCE)
  result = "(\"oneOf.java.jpp: SEQUENCE unimplemented\" != null)"; // "interned"
#endif

    return result;
  }

  public String format_java_family(/*>>>@GuardSatisfied ONEOFSCALAR this,*/ OutputFormat format) {

    String result;

#if !defined(SEQUENCE)
    // Setting up the name of the unary variable
    String varname = var().name_using(format);
#endif

#if defined(ELTSTRING)
    if ((var().rep_type == ProglangType.CHAR_ARRAY_ARRAY)
        && varname.endsWith("[]")) {
      varname = varname.substring(0, varname.length()-2);
    }
#endif

#if defined(IS_ELT)

    // Constructing the array that unary val will be compared against
  #if defined(ELT)
    String oneOfArray = "new long[] { ";
  #elif defined(ELTFLOAT)
    String oneOfArray = "new double[] { ";
  #elif defined(ELTSTRING)
    String oneOfArray = "new String[] { ";
  #endif
    for (int i = 0 ; i < num_elts ; i++) {
      if (i != 0) { oneOfArray += ", "; }
      oneOfArray = oneOfArray + TOSTRING(elts[i]);
    }
    oneOfArray += " }";

    // Calling quantification method
    if (num_elts == 1) {

    #if defined(BASE_INT)
      if (is_boolean()) {
        result = "daikon.Quant.eltsEqual(" + varname + ", "
          + ((elts[0] == 0) ? "false" : "true") + ")";
      } else if (is_hashcode()) {
        result =
          ((elts[0] == 0)
           ? ("daikon.Quant.eltsEqual(" + varname + ", null)")
           : ("daikon.Quant.eltsNotEqual(" + varname + ", null)"));
      } else
    #endif
        {
          result = "daikon.Quant.eltsEqual(" + varname + ", "
            + TOSTRING(elts[0]) + ")";
        }
    } else {
      assert num_elts > 1;
      // eltsOneOf == subsetOf
      result = "daikon.Quant.subsetOf(" + varname + ", " + oneOfArray + ")";
    }

#elif defined(IS_SCALAR)

  #if defined(IS_NUMERIC)

    #if defined(BASE_INT)

    if (is_boolean()) {
      assert num_elts == 1;
      assert (elts[0] == 0) || (elts[0] == 1);
      result = varname + " == " + ((elts[0] == 0) ? "false" : "true");
    } else if (is_hashcode()) {
      if (num_elts == 2) {
        return "true";          // one elt is null, the other is non-null
      } else if (elts[0] == 0) {
        result = varname + " == " + "null";
      } else {
        result = varname + " != null";
          // varname + " has only one value"
          // + " (hashcode=" + elts[0] + ")"
      }
    } else

    #endif

    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        if (i != 0) { result += " || "; }

        #if defined(FLOAT)
        result += "daikon.Quant.fuzzy.eq(" + varname + ", " + TOSTRING(elts[i]) + ")";
        #else
        result += varname + " == " + TOSTRING(elts[i]);
        #endif
      }
    }

  #elif defined(STRING)

    result = "";
    boolean is_type = is_type();
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }
      String str = elts[i];
      if (!is_type) {
        result += varname + JAVA_EQUALS_STRING(TOSTRING(str));
      } else {
        // It's a type
        if ((str == null) || "null".equals(str)) {
          result += varname + " == " + "null";
        } else {
          if (str.startsWith("[")) {
            str = UtilMDE.fieldDescriptorToBinaryName(str);
          }
          // ".class" (which is a suffix for a type name) and not
          // getClassSuffix (which is a suffix for an expression).
          // we need ".class.getName()" to make result a string
          result += varname + " == " + str + ".class.getName()";
        }
      }
    }

  #endif

#elif defined(IS_SEQUENCE)

  #if defined(SEQUENCE)

    result = "(\"oneOf.java.jpp: SEQUENCE unimplemented\" != null)"; // "interned"

  #else

    result = "";
    for (int i=0; i<num_elts; i++) {
      if (i != 0) { result += " || "; }

    #if defined(STRINGSEQUENCE)
      String seq = "new String[] { ";
    #elif defined(FLOATSEQUENCE)
      String seq = "new double[] { ";
    #endif
      for (int j = 0 ; j < elts[i].length ; j++) {
        if (j != 0) { seq += ", "; }
        seq = seq + TOSTRINGELEMENT(elts[i][j]);
      }
      seq += " }";

      result += "daikon.Quant.pairwiseEqual(" + varname + ", " + seq + ")";
    }
  #endif

#endif

    return result;
  }

  public String format_simplify(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
#ifdef BASE_INT
    // if (is_hashcode() && dkconfig_omit_hashcode_values_Simplify)
    //   return "(AND)";
#endif
    sort_rep();
#if defined(IS_ELT)
    String[] form = VarInfo.simplify_quantify (var());
    String varname = form[1];
#elif defined(IS_SCALAR)
    String varname =
      var().simplifyFixup(var().name_using(OutputFormat.SIMPLIFY));
#endif
    String result;
#if defined(STRING) || defined(ELTSTRING)
    result = "";
    boolean is_type = is_type();
    for (int i=0; i<num_elts; i++) {
      String value = elts[i];
      if (is_type) {
        if (value == null) {
          // do nothing
        } else if (value.startsWith("[")) {
          value = UtilMDE.fieldDescriptorToBinaryName(value);
        } else if (value.startsWith("\"") && value.endsWith("\"")) {
          value = value.substring(1, value.length()-1);
        }
        value = "|T_" + value + "|";
      } else {
        value = TOSTRING_SIMPLIFY(value);
      }
      result += " (EQ " + varname + " " + value + ")";
    }
    if (num_elts > 1) {
      result = "(OR" + result + ")";
    } else if (num_elts == 1) {
      // chop leading space
      result = result.substring(1);
    } else if (num_elts == 0) {
      return format_too_few_samples(OutputFormat.SIMPLIFY, null);
    }
#elif defined(SCALAR) || defined(ELT) || defined(FLOAT) || defined(ELTFLOAT)
  #if defined(SCALAR) || defined(ELT)
    if (is_boolean()) {
      assert num_elts == 1;
      assert (elts[0] == 0) || (elts[0] == 1);
      result = "(EQ " + varname + " " + ((elts[0] == 0) ? "|@false|" : "|@true|") + ")";
    } else if (is_hashcode()) {
      if (num_elts == 1) {
        long hashcode_val = get_hashcode_val (elts[0]);
        result = "(EQ " + varname + " " +
          ((elts[0] == 0) ? "null" :
           ("(hashcode " + simplify_format_long(hashcode_val) + ")")) + ")";
      } else if (num_elts == 2) {
        // add_modified allows two elements iff one is null
        assert elts[0] == 0;
        assert elts[1] != 0;
        long hashcode_val = get_hashcode_val (elts[1]);
        result = "(OR (EQ " + varname + " null) (EQ " + varname
          + "(hashcode " + simplify_format_long(hashcode_val) + ")))";
      } else if (num_elts == 0) {
        return format_too_few_samples(OutputFormat.SIMPLIFY, null);
      } else {
        throw new Error ("Contains more than 2 elements");
      }
    } else
  #endif
    {
      result = "";
      for (int i=0; i<num_elts; i++) {
        result += " (EQ " + varname + " " + TOSTRING_SIMPLIFY(elts[i]) + ")";
      }
      if (num_elts > 1) {
        result = "(OR" + result + ")";
      } else if (num_elts == 1) {
        // chop leading space
        result = result.substring(1);
      } else {
        // Haven't actually seen any data, so we're vacuously true
        return format_too_few_samples(OutputFormat.SIMPLIFY, null);
      }
    }
#elif defined(IS_SEQUENCE)
    StringBuffer resultBuf = new StringBuffer();
    for (int i=0; i<num_elts; i++) {
      INT seq = elts[i];
      String offset = null;
      String contents = null;
      String[] bounds_name;
      String length = var().get_simplify_size_name();
      // if ((length == null) && var().name.isApplySizeSafe())
      //  System.out.printf ("var %s, type %s, is_array %b%n", var().name(),
      //                     var().type, var().type.isArray());
      if (length != null) {
        length = "(EQ " + length + " "+ simplify_format_long(seq.length) + ")";
      } else if ((bounds_name = var().get_simplify_slice_bounds()) != null) {
        String size = "(+ 1 (- " + bounds_name[1] +" " + bounds_name[0] + "))";
        length = "(EQ " + size + " " + simplify_format_long(seq.length) + ")";
        offset = bounds_name[0];
      }

#ifdef SEQUENCE
      if (is_hashcode()) {
        String[] form = VarInfo.simplify_quantify (var());
        if (no_nulls(i)) {
          contents = form[0] + "(NEQ " + form[1] + "  null)" + form[2];
        } else if (all_nulls(i)) {
          contents = form[0] + "(EQ " + form[1] + "  null)" + form[2];
        }
      } else
#endif
      {
        StringBuffer contentsBuf = new StringBuffer();
        for (int j = 0; j < seq.length; j++) {
          if (j + 3 < seq.length &&
              ELT_EQUALS(seq[j], seq[j+1]) &&
              ELT_EQUALS(seq[j], seq[j+2]) &&
              ELT_EQUALS(seq[j], seq[j+3])) {
            // Compress a sequence of adjacent values
            int k = j + 4;
            for (; k < seq.length; k++)
              if (!ELT_EQUALS(seq[j], seq[k])) {
                break;
              }
            k--;
            String index_name = VarInfo.get_simplify_free_index (var());
            String cond_left, cond_right;
            if (offset == null) {
              cond_left  = "(<= " + j + " " + index_name + ")";
              cond_right = "(<= " + index_name + " " + k + ")";
            } else {
              cond_left = "(<= (+ " + offset + " " + j + ") "
                + index_name + ")";
              cond_right = "(>= (+ " + offset + " " + k + ") "
                + index_name + ")";
            }
            String cond = "(AND " + cond_left + " " + cond_right + ")";
            String nth = var().get_simplify_selectNth (index_name, true, 0);
            String eq = "(EQ " + nth + " " + TOSTRING_SIMPLIFY(seq[j]) + ")";
            String implies = "(IMPLIES " + cond + " " + eq + ")";
            String forall = "(FORALL (" + index_name + ") " + implies + ")";
            contentsBuf.append(" " + forall);
            j = k;
          } else {
            // Output a single value
            String nth = var().get_simplify_selectNth_lower (j);
            if (nth == null) {
              String classname = this.getClass().toString().substring(6);
              result = "warning: method " + classname
                + ".format_simplify() needs to fix selectNth(): " + format();
              return result;
            }
            String value = TOSTRING_SIMPLIFY(seq[j]);
            contentsBuf.append(" (EQ " + nth + " " + value + ")");
            // if (nth.contains ("--orig__a"))
            //   System.out.printf ("regular orig__a%n");

          }
        }
        if (seq.length > 1) {
          contents = "(AND " + contentsBuf.toString() + ")";
        } else if (seq.length == 1) {
          contents = contentsBuf.toString().substring(1);
        } else if (seq.length == 0) {
          contents = null; // back from ""
        }
      }
      if (length == null && contents == null) {
        resultBuf.append(" ");
      } else if (length == null && contents != null) {
        resultBuf.append(" " + contents);
      } else if (length != null && contents == null) {
        resultBuf.append(" " + length);
      } else {
        assert length != null && contents != null;
        resultBuf.append(" (AND " + length + " " + contents + ")");
      }

      }
    if (num_elts > 1) {
      result = "(OR" + resultBuf.toString() + ")";
    } else if (num_elts == 1) {
      // chop leading space
      result = resultBuf.toString().substring(1);
    } else if (num_elts == 0) {
      return format_too_few_samples(OutputFormat.SIMPLIFY, null);
    } else {
      throw new Error("this can't happen");
      // result = null;
    }
    if (result.trim().equals("")) {
      result = "format_simplify() failed on a weird OneOf";
    }
#else
    String classname = this.getClass().toString().substring(6); // remove leading "class "
    result =  "warning: method " + classname + ".format_simplify() needs to be implemented: " + format();
#endif
#if defined(IS_ELT)
    result = form[0] + result + form[2];
#endif
    if (result.indexOf("format_simplify") == -1) {
      daikon.simplify.SimpUtil.assert_well_formed(result);
    }
    return result;
  }


#if defined(IS_ELT)

  public InvariantStatus add_modified(INTARRAY a, int count) {
    return runValue(a, count, true);
  }

  public InvariantStatus check_modified(INTARRAY a, int count) {
    return runValue(a, count, false);
  }

#else

  public InvariantStatus add_modified(INT a, int count) {
    return runValue(a, count, true);
  }

  public InvariantStatus check_modified(INT a, int count) {
    return runValue(a, count, false);
  }

#endif

#if defined(IS_ELT)

  private InvariantStatus runValue(INT[] a, int count, boolean mutate) {
    InvariantStatus finalStatus = InvariantStatus.NO_CHANGE;
    for (int ai=0; ai <a.length; ai++) {
      InvariantStatus status = null;
      if (mutate) {
        status = add_mod_elem(a[ai], count);
      } else {
        status = check_mod_elem(a[ai], count);
      }
      if (status == InvariantStatus.FALSIFIED) {
        return InvariantStatus.FALSIFIED;
      } else if (status == InvariantStatus.WEAKENED) {
        finalStatus = InvariantStatus.WEAKENED;
      }
    }
    return finalStatus;
  }

#else

  private InvariantStatus runValue(INT v, int count, boolean mutate) {
    InvariantStatus status;
    if (mutate) {
      status = add_mod_elem(v, count);
    } else {
      status = check_mod_elem(v, count);
    }
    if (status == InvariantStatus.FALSIFIED) {
      if (logOn() && mutate) {
        StringBuffer eltString = new StringBuffer();
        for (int i = 0; i < num_elts; i++) {
          eltString.append(TOSTRING(elts[i]) + " ");
        }
        log ("destroyed on sample %s previous vals = {%s} num_elts = %s",
             TOSTRING(v), eltString, num_elts);
      }
      return InvariantStatus.FALSIFIED;
    }
    return status;
  }
#endif


  /**
   * Adds a single sample to the invariant.  Returns
   * the appropriate InvariantStatus from the result
   * of adding the sample to this.
   */
  public InvariantStatus add_mod_elem (INT v, int count) {
    InvariantStatus status = check_mod_elem(v, count);
    if (status == InvariantStatus.WEAKENED) {
      elts[num_elts] = v;
      num_elts++;
    }
    return status;
  }


  /**
   * Checks a single sample to the invariant.  Returns
   * the appropriate InvariantStatus from the result
   * of adding the sample to this.
   */
  public InvariantStatus check_mod_elem (INT v, int count) {

    // Look for v in our list of previously seen values.  If it's
    // found, we're all set.
    for (int i=0; i<num_elts; i++) {
      //if (logDetail())
      //  log ("add_modified (" + v + ")");
      if (EQUALS(elts[i], v)) {
        return InvariantStatus.NO_CHANGE;
      }
    }

    if (num_elts == dkconfig_size) {
      return InvariantStatus.FALSIFIED;
    }

#if defined(STRING) || defined(ELTSTRING)
    if (is_type() && (num_elts == 1)) {
      return InvariantStatus.FALSIFIED;
    }
#elif defined(SEQUENCE)
    if (is_hashcode() && (num_elts == 1)) {
      return InvariantStatus.FALSIFIED;
    }
#elif defined(SCALAR) || defined(ELT)
    if ((is_boolean() && (num_elts == 1)) || (is_hashcode() && (num_elts == 2))) {
      return InvariantStatus.FALSIFIED;
    }

    if (is_hashcode() && (num_elts == 1)) {
      // Permit two object values only if one of them is null
      if ((elts[0] != 0) && (v != 0)) {
        return InvariantStatus.FALSIFIED;
      }
    }
#endif


    return InvariantStatus.WEAKENED;
  }

#if defined(IS_ELT)
  // It is possible to have seen many (array) samples, but no (INT)
  // array element values.
  public boolean enoughSamples(/*>>>@GuardSatisfied ONEOFSCALAR this*/) {
    return num_elts > 0;
  }
#endif

  protected double computeConfidence() {
    // This is not ideal.
    if (num_elts == 0) {
      return Invariant.CONFIDENCE_UNJUSTIFIED;
#if defined(SCALAR) || defined(ELT)
    } else if (is_hashcode() && (num_elts > 1)) {
      // This should never happen
      return Invariant.CONFIDENCE_UNJUSTIFIED;
#endif
    } else {
      return Invariant.CONFIDENCE_JUSTIFIED;
    }
  }

  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousStatically(VarInfo[] vis) {
    // Static constants are necessarily OneOf precisely one value.
    // This removes static constants from the output, which might not be
    // desirable if the user doesn't know their actual value.
    if (vis[0].isStaticConstant()) {
      assert num_elts <= 1;
      return new DiscardInfo(this, DiscardCode.obvious, vis[0].name() + " is a static constant.");
    }
    return super.isObviousStatically(vis);
  }

#if defined(IS_NUMERIC)
  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v = vis[0];

    Debug dlog = new Debug (getClass(), ppt, vis);

    if (logOn()) {
      dlog.log ("enter isObviousDynamically");
    }

      // We can use the minvalue and maxvalue custom attributes here: if
      // minimum value and maximum value are the same as the reported
      // value, then we can suppress this invariant
      if (num_elts == 1
          && v.aux.hasValue(VarInfoAux.MINIMUM_VALUE)
          && v.aux.hasValue(VarInfoAux.MAXIMUM_VALUE))
      {
        @SuppressWarnings("keyfor")   // needs EnsuresQualifier
        int min = v.aux.getInt(VarInfoAux.MINIMUM_VALUE);
        @SuppressWarnings("keyfor")   // needs EnsuresQualifier
        int max = v.aux.getInt(VarInfoAux.MAXIMUM_VALUE);
        if (min == max && min == elts[0]) {
          return new DiscardInfo(this,
            DiscardCode.obvious,
            v.name() + "'s value matches with the expected value");
        }
      }

      // We can check if all values in the list match with the ones we know about
      // (useful for booleans and numeric enumerations).
      if (v.aux.hasValue(VarInfoAux.VALID_VALUES)) {
        @SuppressWarnings("keyfor")   // needs EnsuresQualifier
        String[] vsValidValues         = v.aux.getList(VarInfoAux.VALID_VALUES);
        Set<NUMWRAPPER> setValidValues = new TreeSet<NUMWRAPPER>();
        for (String s : vsValidValues) {
          setValidValues.add(new NUMWRAPPER(s));
        }
        Set<NUMWRAPPER> setValuesInvariant = new TreeSet<NUMWRAPPER>();
        for (INT e : elts) {
          setValuesInvariant.add(e);
        }
        if (setValidValues.equals(setValuesInvariant)) {
          return new DiscardInfo(this, DiscardCode.obvious,
            "The value list matches the allowed value list");
        }
      }

    // Obvious if we are 'size(array) == 0'  The thinking is that this
    // will also always show up as 'array == []' which is a little more
    // illuminating.  At this point we insist that we are a SequenceLength
    // derivation of a base (underived) array.  Its quite possible this should
    // just apply to all arrays.
    if (v.isDerived() && (v.derived instanceof SequenceLength)
      && (num_elts == 1) && (elts[0] == 0)) {
      @SuppressWarnings("nullness") // checker bug: flow
      /*@NonNull*/ VarInfo b = v.derived.getBase(0);
      if (!b.isDerived()) {
        if (logOn()) {
          dlog.log ("isObviousDynamically '" + v.name()
                    + " == 0' ==> '" + b.name() + " == []'");
        }
        return new DiscardInfo(this, DiscardCode.obvious, "size(array) == 0 is implied by array == []");
      }
    }

    if (v.isDerived() && (v.derived instanceof SequenceLength)) {
      @SuppressWarnings("nullness") // checker bug: flow
      /*@NonNull*/ SequenceLength sl = (SequenceLength) v.derived;
      if (sl.shift != 0) {
        String discardString = v.name() + " is derived with shift!=0 (shift==" + sl.shift + ")";
        return new DiscardInfo(this, DiscardCode.obvious, discardString);
      }
    }

    // For every ELTONEOF at this program point, see if this variable is
    // an obvious member of that sequence.
    PptTopLevel parent = ppt.parent;
    for (Iterator<Invariant> itor = parent.invariants_iterator(); itor.hasNext(); ) {
      Invariant inv = itor.next();
      if ((inv instanceof ELTONEOF) && inv.enoughSamples()) {
        VarInfo v1 = var();
        VarInfo v2 = inv.ppt.var_infos[0];
        // System.out.println("isObviousImplied: calling  Member.isObviousMember(" + v1.name + ", " + v2.name + ")");
        // Don't use isEqualToObviousMember:  that is too subtle
        // and eliminates desirable invariants such as "return == null".
        if (Member.isObviousMember(v1, v2)) {
          ELTONEOF other = (ELTONEOF) inv;
          if (num_elts == other.num_elts()) {
            sort_rep();
            if (other.compare_rep(num_elts, elts)) {
              // System.out.println("isObviousImplied true");
              String discardString = v1.name()+" is a member of "+v2.name()+" for which this Invariant also holds";
              return new DiscardInfo(this, DiscardCode.obvious, discardString);
            }
          }
        }
      }
    }

    return null;
  }
#elif defined(IS_SEQUENCE)
  /** {@inheritDoc} */
  @SuppressWarnings("keyfor")   // needs EnsureQualifier
  @Override
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v = vis[0];

    // We can check if all values in the element sequence match
    // with the ones we know about (useful for booleans and numeric
    // enumerations).
    if (v.aux.hasValue(VarInfoAux.VALID_VALUES)
        && v.aux.hasValue(VarInfoAux.MAXIMUM_LENGTH)
        && v.aux.hasValue(VarInfoAux.MINIMUM_LENGTH)
        && v.aux.getInt(VarInfoAux.MAXIMUM_LENGTH) == 1
        && v.aux.getInt(VarInfoAux.MINIMUM_LENGTH) == 1)
    {
      #if defined(SEQUENCE)
      #define BASETYPE Long
      #elif defined(FLOATSEQUENCE)
      #define BASETYPE Double
      #else
      #define BASETYPE String
      #endif

      @SuppressWarnings("keyfor")   // needs EnsuresQualifier
      String[] vsValidValues       = v.aux.getList(VarInfoAux.VALID_VALUES);
      Set<BASETYPE> setValidValues = new TreeSet<BASETYPE>();
      for (String s : vsValidValues) {
        setValidValues.add(new BASETYPE(s));
      }
      Set<BASETYPE> setValuesInvariant = new TreeSet<BASETYPE>();
      for (INT e : elts) {
        if (e == null) continue;
        for (BASETYPE b : e) {
          setValuesInvariant.add(b);
        }
      }
      if (setValidValues.equals(setValuesInvariant)) {
        return new DiscardInfo(this, DiscardCode.obvious,
          "The value list matches the allowed value list");
      }
    }

    return null;
  }
#elif defined(IS_ELT_NUMERIC)
  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v = vis[0];

    // We can check if all values in the list match with the ones we know about
    // (useful for booleans and numeric enumerations).
    if (v.aux.hasValue(VarInfoAux.VALID_VALUES)) {
      @SuppressWarnings("keyfor")   // needs EnsuresQualifier
      String[] vsValidValues         = v.aux.getList(VarInfoAux.VALID_VALUES);
      Set<NUMWRAPPER> setValidValues = new TreeSet<NUMWRAPPER>();
      for (String s : vsValidValues) {
        setValidValues.add(new NUMWRAPPER(s));
      }
      Set<NUMWRAPPER> setValuesInvariant = new TreeSet<NUMWRAPPER>();
      for (INT e : elts) {
        setValuesInvariant.add(e);
      }
      if (setValidValues.equals(setValuesInvariant)) {
        return new DiscardInfo(this, DiscardCode.obvious,
          "The value list matches the allowed value list");
      }
    }

    // Look for the same property over a supersequence of this one.
    PptTopLevel pptt = ppt.parent;
    for (Iterator<Invariant> inv_itor = pptt.invariants_iterator(); inv_itor.hasNext(); ) {
      Invariant inv = inv_itor.next();
      if (inv == this) {
        continue;
      }
      if (inv instanceof ONEOFSCALAR) {
        ONEOFSCALAR other = (ONEOFSCALAR) inv;
        if (isSameFormula(other)
          && SubSequence.isObviousSubSequenceDynamically(this, v, other.var())) {
          debug.fine ("isObviousDyn: Returning true because isObviousSubSequenceDynamically");
          return new DiscardInfo(this, DiscardCode.obvious, "The same property holds over a supersequence " + other.var().name());
        }
      }
    }

    return null;
  }
#elif defined(STRING) || defined(ELTSTRING)
  /** {@inheritDoc} */
  @Override
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    VarInfo v = vis[0];

    // We can check if all values in the list match with the ones we know about
    // (useful for booleans and numeric enumerations).
    if (v.aux.hasValue(VarInfoAux.VALID_VALUES)) {
      @SuppressWarnings("keyfor")   // needs EnsuresQualifier
      String[] vsValidValues         = v.aux.getList(VarInfoAux.VALID_VALUES);
      Set<INT> setValidValues = new TreeSet<INT>();
      for (String s : vsValidValues) {
        setValidValues.add(new INT(s));
      }
      Set<INT> setValuesInvariant = new TreeSet<INT>();
      for (INT e : elts) {
        if (e == null) continue;
        setValuesInvariant.add(e);
      }

      if (setValidValues.equals(setValuesInvariant)) {
        return new DiscardInfo(this, DiscardCode.obvious,
          "The value list consists of all possible values");
      }
    }

    return null;
  }
#endif

  /**
   * Oneof can merge different formulas from lower points to create a single
   * formula at an upper point.
   */
  public boolean mergeFormulasOk() {
    return true;
  }

  /*@Pure*/
  public boolean isSameFormula(Invariant o) {
    ONEOFSCALAR other = (ONEOFSCALAR) o;
    if (num_elts != other.num_elts) {
      return false;
    }
    if (num_elts == 0 && other.num_elts == 0) {
      return true;
    }

    sort_rep();
    other.sort_rep();

#if defined(SCALAR) || defined(ELT)
    // All nonzero hashcode values should be considered equal to each other
    //
    // Examples:
    // inv1  inv2  result
    // ----  ----  ------
    // 19    0     false
    // 19    22    true
    // 0     0     true

    if (is_hashcode() && other.is_hashcode()) {
      if (num_elts == 1 && other.num_elts == 1) {
        return ((elts[0] == 0 && other.elts[0] == 0) ||
                (elts[0] != 0 && other.elts[0] != 0));
      } else if (num_elts == 2 && other.num_elts == 2) {
        // add_modified allows two elements iff one is null
        assert elts[0] == 0;
        assert other.elts[0] == 0;
        assert elts[1] != 0;
        assert other.elts[1] != 0;

        // Since we know the first elements of each invariant are
        // zero, and the second elements are nonzero, we can immediately
        // return true
        return true;
      } else {
        return false;
      }
    }
#elif defined(SEQUENCE)
    // All nonzero hashcode values should be considered equal to each other
    //
    // Examples:
    // inv1     inv2     result
    // -------  -------  ------
    // {19,23}  {91,0}   false
    // {19,23}  {91,32}  true
    // {19,0}   {91,0}   true
    // {0,0}    {0,0}    true

    if (is_hashcode() && other.is_hashcode()) {
      // we only have one value, because add_modified dies if more
      assert num_elts == 1 && other.num_elts == 1;

      INT thisSeq = elts[0];
      INT otherSeq = other.elts[0];
      if (thisSeq.length != otherSeq.length) {
        return false;
      }

      for (int i=0; i < thisSeq.length; i++) {
        if ((thisSeq[i] == 0 && otherSeq[i] != 0) ||
            (thisSeq[i] != 0 && otherSeq[i] == 0)) {
          return false;
        }
      }

      return true;
    }
#endif

    for (int i=0; i < num_elts; i++) {
      if (! EQUALS(elts[i],other.elts[i])) {
        return false;
      }
    }

    return true;
  }

  /*@Pure*/
  public boolean isExclusiveFormula(Invariant o) {
    if (o instanceof ONEOFSCALAR) {
      ONEOFSCALAR other = (ONEOFSCALAR) o;

      if (num_elts == 0 || other.num_elts == 0) {
        return false;
      }
      for (int i=0; i < num_elts; i++) {
        for (int j=0; j < other.num_elts; j++) {
          if (EQUALS(elts[i],other.elts[j])) // elements are interned
            return false;
        }
      }
#if defined(SCALAR) || defined(ELT)
      // Don't consider two instances of "non-null" as exclusive.
      if (is_hashcode() && num_elts == 1
          && other.is_hashcode() && other.num_elts == 1
          && elts[0] != 0 && other.elts[0] != 0) {
        return false;
      }
#endif

#ifdef BASE_INT
      // Be even more aggressive about rejecting these for use in
      // implications in this case, since, we'd be printing them as
      // "true"
      /*
      if (dkconfig_omit_hashcode_values_Simplify &&
          (is_hashcode() || other.is_hashcode())) {
        return false;
      }
      */
#endif

      return true;
    }
#if defined(IS_NUMERIC) || defined(IS_ELT_NUMERIC)
    // Many more checks can be added here:  against nonzero, modulus, etc.
    if ((o instanceof NONZERO) && (num_elts == 1) && (elts[0] == 0)) {
      return true;
    }
    INT elts_min = NUMWRAPPER.MAX_VALUE;
    INT elts_max = NUMWRAPPER.MIN_VALUE;
    for (int i=0; i < num_elts; i++) {
      elts_min = Math.min(elts_min, elts[i]);
      elts_max = Math.max(elts_max, elts[i]);
    }
    if ((o instanceof LOWERBOUND) && (elts_max < ((LOWERBOUND)o).min())) {
      return true;
    }
    if ((o instanceof UPPERBOUND) && (elts_min > ((UPPERBOUND)o).max())) {
      return true;
    }
#endif

    return false;
  }

  // OneOf invariants that indicate a small set of possible values are
  // uninteresting.  OneOf invariants that indicate exactly one value
  // are interesting.
  /*@Pure*/
  public boolean isInteresting() {
    if (num_elts() > 1) {
      return false;
    } else {
      return true;
    }
  }

  public boolean hasUninterestingConstant() {
#if defined(SCALAR) || defined(ELT)
    for (int i = 0; i < num_elts; i++) {
      if (elts[i] < -1 || elts[i] > 2) {
        return true;
      }
    }
#elif defined(FLOAT) || defined(ELTFLOAT)
    for (int i = 0; i < num_elts; i++) {
      if (elts[i] < -1.0 || elts[i] > 2.0 || elts[i] != (long)elts[i]) {
        return true;
      }
    }
#elif defined(SEQUENCE)
    for (int i = 0; i < num_elts; i++) {
      for (int j = 0; j < elts[i].length; j++)
        if (elts[i][j] < -1 || elts[i][j] > 2) {
          return true;
        }
    }
#elif defined(SEQUENCEFLOAT)
    for (int i = 0; i < num_elts; i++) {
      for (int j = 0; j < elts[i].length; j++)
        if (elts[i][j] < -1.0 || elts[i][j] > 2.0
            || elts[i][j] != (long)elts[i][j])
          return true;
    }
#endif
    return false;
  }


  /*@Pure*/
  public boolean isExact() {
    return (num_elts == 1);
  }

  // Look up a previously instantiated invariant.
  public static /*@Nullable*/ ONEOFSCALAR find(PptSlice ppt) {
    assert ppt.arity() == 1;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof ONEOFSCALAR) {
        return (ONEOFSCALAR) inv;
      }
    }
    return null;
  }

  // Interning is lost when an object is serialized and deserialized.
  // Manually re-intern any interned fields upon deserialization.
  @SuppressWarnings("interning") // readObject re-interns
  private void readObject(ObjectInputStream in) throws IOException,
    ClassNotFoundException {
    in.defaultReadObject();
    #if defined (STRINGSEQUENCE)
      for (int i = 0; i < num_elts; i++) {
        for (int j = 0; j < elts[i].length; j++) {
          elts[i][j] = Intern.intern (elts[i][j]);
        }
      }
    #endif
    for (int i=0; i < num_elts; i++) {
      elts[i] = Intern.intern(elts[i]);
    }
  }

  /**
   * Merge the invariants in invs to form a new invariant.  Each must be
   * a ONEOFSCALAR invariant.  This code finds all of the oneof values
   * from each of the invariants and returns the merged invariant (if any).
   *
   * @param invs       list of invariants to merge.  The invariants must all be
   *                   of the same type and should come from the children of
   *                   parent_ppt.  They should also all be permuted to match
   *                   the variable order in parent_ppt.
   * @param parent_ppt slice that will contain the new invariant
   */
  @SuppressWarnings("interning") // cloning requires re-interning
  public /*@Nullable*/ Invariant merge (List<Invariant> invs, PptSlice parent_ppt) {

    // Create the initial parent invariant from the first child
    ONEOFSCALAR  first = (ONEOFSCALAR) invs.get(0);
    ONEOFSCALAR result = first.clone();
    result.ppt = parent_ppt;
    #if defined (IS_SEQUENCE)
      for (int i = 0; i < result.num_elts; i++) {
        result.elts[i] = Intern.intern (result.elts[i]);
      }
    #endif

    // Loop through the rest of the child invariants
    for (int i = 1; i < invs.size(); i++ ) {

      // Get this invariant
      ONEOFSCALAR inv = (ONEOFSCALAR) invs.get (i);

      // Loop through each distinct value found in this child and add
      // it to the parent.  If the invariant is falsified, there is no parent
      // invariant
      for (int j = 0; j < inv.num_elts; j++) {
        INT val = inv.elts[j];
        #if defined (IS_SEQUENCE)
        val = Intern.intern (val);
        #endif
        InvariantStatus status = result.add_mod_elem(val, 1);
        if (status == InvariantStatus.FALSIFIED) {
          result.log ("%s", "child value '" + val + "' destroyed oneof");
          return null;
        }
      }
    }

    result.log ("Merged '%s' from %s child invariants", result.format(), invs.size());
    return result;
  }

  /**
   * Setup the invariant with the specified elements.  Normally
   * used when searching for a specified OneOf.  The elements of vals
   * are not necessarily interned; this method interns each element.
   */
  public void set_one_of_val (INTARRAY_UNINTERNED vals) {

    num_elts = vals.length;
    for (int i = 0; i < num_elts; i++) {
      elts[i] = Intern.intern (vals[i]);
    }
  }

  /**
   * Returns true if every element in this invariant is contained in
   * the specified state.  For example if x = 1 and the state contains
   * 1 and 2, true will be returned.
   */
  public boolean state_match (Object state) {

    if (num_elts == 0) {
      return false;
    }

    if (!(state instanceof INT[])) {
      System.out.println ("state is of class '" + state.getClass().getName()
                          + "'");
    }
    INTARRAY e = (INTARRAY) state;
    for (int i = 0; i < num_elts; i++) {
      boolean match = false;
      for (int j = 0; j < e.length; j++) {
        if (elts[i] == e[j]) {
          match = true;
          break;
        }
      }
      if (!match) {
        return false;
      }
    }
    return true;
  }

#ifdef BASE_INT
  /**
   * Map that holds dummy hashcode values for hashcodes.  Each hashcode
   * seen is assigned a small integer in the order they are seen.  These
   * values will be consistent as long as new hashcodes do not appear
   * in the output.  Not a perfect fix for regressions consistency, but
   * workable.
   */
  private static Map<Long,Long> dummy_hashcode_vals
    = new LinkedHashMap<Long,Long>();
  private static long next_dummy_hashcode = 1001;

  private long get_hashcode_val (/*>>>@GuardSatisfied ONEOFSCALAR this,*/ long hashcode) {
    if (!dkconfig_omit_hashcode_values_Simplify) {
      return hashcode;
    }

    Long val = dummy_hashcode_vals.get (hashcode);
    if (val != null) {
      return val;
    }
    dummy_hashcode_vals.put (hashcode, next_dummy_hashcode);
    return (next_dummy_hashcode++);
  }
#endif
}
