#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(LOWER) || defined(UPPER) || defined(LOWERFLOAT) || defined(UPPERFLOAT))
  #error "LOWER, UPPER, LOWERFLOAT, or UPPERFLOAT must be defined"
#endif

#if defined(LOWER)
  #define PRIMITIVE long
  #define LT <
  #define GT >
  #define MIN min
  #define MIN1 min1
  #define NUM_MIN1 num_min1
  #define MIN2 min2
  #define NUM_MIN2 num_min2
  #define MIN3 min3
  #define NUM_MIN3 num_min3
  #define MAX max
  #define LONGMAX Long.MAX_VALUE
  #define LONGMIN Long.MIN_VALUE
  #define SIGNADJUST
  #define MINSTR "min"
  #define MAXSTR "max"
  #define GTSTR ">"
  #define MAX1 max1
  #define LOWERBOUNDCORE LowerBoundCore
  #define LOWERBOUNDCORESTR "LowerBoundCore"
  #define UPPERBOUNDCORE UpperBoundCore
#elif defined(UPPER)
  #define PRIMITIVE long
  #define LT >
  #define GT <
  #define MIN max
  #define MIN1 max1
  #define NUM_MIN1 num_max1
  #define MIN2 max2
  #define NUM_MIN2 num_max2
  #define MIN3 max3
  #define NUM_MIN3 num_max3
  #define MAX min
  #define LONGMAX Long.MIN_VALUE
  #define LONGMIN Long.MAX_VALUE
  #define SIGNADJUST -
  #define MINSTR "max"
  #define MAXSTR "min"
  #define GTSTR "<"
  #define MAX1 min1
  #define LOWERBOUNDCORE UpperBoundCore
  #define LOWERBOUNDCORESTR "UpperBoundCore"
  #define UPPERBOUNDCORE LowerBoundCore
#elif defined(LOWERFLOAT)
  #define PRIMITIVE double
  #define LT <
  #define GT >
  #define MIN min
  #define MIN1 min1
  #define NUM_MIN1 num_min1
  #define MIN2 min2
  #define NUM_MIN2 num_min2
  #define MIN3 min3
  #define NUM_MIN3 num_min3
  #define MAX max
  #define LONGMAX Double.MAX_VALUE
  #define LONGMIN Double.MIN_VALUE
  #define SIGNADJUST
  #define MINSTR "min"
  #define MAXSTR "max"
  #define GTSTR ">"
  #define MAX1 max1
  #define LOWERBOUNDCORE LowerBoundCoreFloat
  #define LOWERBOUNDCORESTR "LowerBoundCoreFloat"
  #define UPPERBOUNDCORE UpperBoundCoreFloat
#elif defined(UPPERFLOAT)
  #define PRIMITIVE double
  #define LT >
  #define GT <
  #define MIN max
  #define MIN1 max1
  #define NUM_MIN1 num_max1
  #define MIN2 max2
  #define NUM_MIN2 num_max2
  #define MIN3 max3
  #define NUM_MIN3 num_max3
  #define MAX min
  #define LONGMAX Double.MIN_VALUE
  #define LONGMIN Double.MAX_VALUE
  #define SIGNADJUST -
  #define MINSTR "max"
  #define MAXSTR "min"
  #define GTSTR "<"
  #define MAX1 min1
  #define LOWERBOUNDCORE UpperBoundCoreFloat
  #define LOWERBOUNDCORESTR "UpperBoundCoreFloat"
  #define UPPERBOUNDCORE LowerBoundCoreFloat
#else
  #error "LOWER, UPPER, LOWERFLOAT, or UPPERFLOAT must be defined"
#endif

// ***** This file is automatically generated from BoundCore.java.jpp

package daikon.inv.unary;

import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.checkerframework.dataflow.qual.SideEffectFree;
import daikon.*;
import daikon.inv.*;
import java.io.Serializable;
import java.text.DecimalFormat;

// One reason not to combine LowerBound and Upperbound is that they have
// separate justifications:  one may be justified when the other is not.

// What should we do if there are few values in the range?
// This can make justifying that invariant easier, because with few values
// naturally there are more instances of each value.
// This might also make justifying that invariant harder, because to get more
// than (say) twice the expected number of samples (under the assumption of
// uniform distribution) requires many samples.
// Which of these dominates?  Is the behavior what I want?

public class LOWERBOUNDCORE implements Serializable, Cloneable {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  static final int required_samples = 5; // for enoughSamples
  static final int required_samples_at_bound = 3; // for justification

  // MIN1 LT MIN2 LT MIN3
  public PRIMITIVE MIN1 = LONGMAX;
  public int NUM_MIN1 = 0;
  public PRIMITIVE MIN2 = LONGMAX;
  public int NUM_MIN2 = 0;
  public PRIMITIVE MIN3 = LONGMAX;
  public int NUM_MIN3 = 0;
  public PRIMITIVE MAX = LONGMIN;

  int samples = 0;

  public Invariant wrapper;

  public LOWERBOUNDCORE(Invariant wrapper) {
    this.wrapper = wrapper;
  }

  public PRIMITIVE MIN() {
    return MIN1;
  }

  @SideEffectFree
  @Override
  public LOWERBOUNDCORE clone(@GuardSatisfied LOWERBOUNDCORE this) {
    try {
      return (LOWERBOUNDCORE) super.clone();
    } catch (CloneNotSupportedException e) {
      throw new Error(); // can't happen
    }
  }

  private static DecimalFormat two_decimals = new java.text.DecimalFormat("#.##");

  public String repr(@GuardSatisfied LOWERBOUNDCORE this) {
    PRIMITIVE modulus = calc_modulus();
    PRIMITIVE range = calc_range();
    double avg_samples_per_val = calc_avg_samples_per_val(modulus, range);
    return MINSTR + "1=" + MIN1
      + ", num_" + MINSTR + "1=" + NUM_MIN1
      + ", " + MINSTR + "2=" + MIN2
      + ", num_" + MINSTR + "2=" + NUM_MIN2
      + ", " + MINSTR + "3=" + MIN3
      + ", num_" + MINSTR + "3=" + NUM_MIN3
      + ", " + MAXSTR + "=" + MAX + ", range=" + range + ", "
      + "avg_samp=" + two_decimals.format(avg_samples_per_val);
  }

  private double calc_avg_samples_per_val(@GuardSatisfied LOWERBOUNDCORE this, PRIMITIVE modulus, double range) {
    // int num_samples = wrapper.ppt.num_mod_samples();
    int num_samples = wrapper.ppt.num_samples();
    double avg_samples_per_val =
      ((double) num_samples) * modulus / range;
    avg_samples_per_val = Math.min(avg_samples_per_val, 100);
#ifdef LOWER
    if (MIN1 == 0) {
      avg_samples_per_val /= 5;
    }
#endif
    return avg_samples_per_val;
  }

  private PRIMITIVE calc_range(@GuardSatisfied LOWERBOUNDCORE this) {
    // If I used Math.abs, the order of arguments to minus would not matter.
    return SIGNADJUST(MAX - MIN1) + 1;
  }

  private PRIMITIVE calc_modulus(@GuardSatisfied LOWERBOUNDCORE this) {
    // Need to reinstate this at some point.
    // {
    //   for (Invariant inv : wrapper.ppt.invs) {
    //     if ((inv instanceof Modulus) && inv.enoughSamples()) {
    //       modulus = ((Modulus) inv).modulus;
    //       break;
    //     }
    //   }
    // }
    return 1;
  }

  /**
   * Whether this would change if the given value was seen. Used to test for need of cloning and
   * flowing before this would be changed.
   */
  public boolean wouldChange(PRIMITIVE value) {
    return (value LT MIN1);
  }

  public InvariantStatus add_modified(PRIMITIVE value, int count) {
    samples += count;

    // System.out.println(LOWERBOUNDCORESTR + varNames() + ": "
    //                    + "add(" + value + ", " + modified + ", " + count + ")");

    PRIMITIVE v = value;

    if (v GT MAX) {
      MAX = v;
    }

    if (v == MIN1) {
      NUM_MIN1 += count;
    } else if (v LT MIN1) {
      MIN3 = MIN2;
      NUM_MIN3 = NUM_MIN2;
      MIN2 = MIN1;
      NUM_MIN2 = NUM_MIN1;
      MIN1 = v;
      NUM_MIN1 = count;
      return InvariantStatus.WEAKENED;
    } else if (v == MIN2) {
      NUM_MIN2 += count;
    } else if (v LT MIN2) {
      MIN3 = MIN2;
      NUM_MIN3 = NUM_MIN2;
      MIN2 = v;
      NUM_MIN2 = count;
    } else if (v == MIN3) {
      NUM_MIN3 += count;
    } else if (v LT MIN3) {
      MIN3 = v;
      NUM_MIN3 = count;
    }
    return InvariantStatus.NO_CHANGE;
  }

  public InvariantStatus check(PRIMITIVE value) {
    if (value LT MIN1) {
      return InvariantStatus.WEAKENED;
    } else {
      return InvariantStatus.NO_CHANGE;
    }
  }

  public boolean enoughSamples(@GuardSatisfied LOWERBOUNDCORE this) {
    return samples > required_samples;
  }

  // Convenience methods; avoid need for "Invariant." prefix.
  private final double prob_is_ge(double x, double goal) {
    return Invariant.prob_is_ge(x, goal);
  }
  private final double prob_and(double p1, double p2) {
    return Invariant.prob_and(p1, p2);
  }
  private final double prob_or(double p1, double p2) {
    return Invariant.prob_or(p1, p2);
  }

  public double computeConfidence() {
    if (PrintInvariants.dkconfig_static_const_infer && matchConstant()) {
      return Invariant.CONFIDENCE_JUSTIFIED;
    }

    return 1 - computeProbability();
  }

  public boolean matchConstant() {
    PptTopLevel pptt = wrapper.ppt.parent;

    for (VarInfo vi : pptt.var_infos) {
      if (vi.isStaticConstant()) {
        if (vi.rep_type == ProglangType.DOUBLE) {
          // If variable is a double, then use fuzzy comparison
          Double constantVal = (Double)vi.constantValue();
          if (Global.fuzzy.eq(constantVal, MIN1) || (Double.isNaN(constantVal) && Double.isNaN(MIN1))) {
            return true;
          }
        } else {
          // Otherwise just use the equals method
          Object constantVal = vi.constantValue();
          if (constantVal.equals(MIN1)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  // used by computeConfidence
  public double computeProbability() {
    // The bound is justified if both of two conditions is satisfied:
    //  1. there are at least required_samples_at_bound samples at the bound
    //  2. one of the following holds:
    //      2a. the bound has five times the expected number of samples (the
    //          number it would have if the values were uniformly distributed)
    //      2b. the bound and the two next elements all have at least half
    //          the expected number of samples.
    // The expected number of samples is the total number of samples
    // divided by the range of the samples; it is the average number
    // of samples at each point.

    // Value "1" from above.
    double bound_samples_prob = prob_is_ge(NUM_MIN1, required_samples_at_bound);

    PRIMITIVE modulus = calc_modulus();

    double range = calc_range();
    double avg_samples_per_val = calc_avg_samples_per_val(modulus, range);

    // Value "2a" from above
    double trunc_prob = prob_is_ge(NUM_MIN1, 5 * avg_samples_per_val);

    // Value "2b" from above
    double unif_prob;
    boolean unif_mod_OK = ((SIGNADJUST(MIN3 - MIN2) == modulus)
                           && (SIGNADJUST(MIN2 - MIN1) == modulus));
    if (unif_mod_OK) {
      double half_avg_samp = avg_samples_per_val / 2;
      double unif_prob_1 = prob_is_ge(NUM_MIN1, half_avg_samp);
      double unif_prob_2 = prob_is_ge(NUM_MIN2, half_avg_samp);
      double unif_prob_3 = prob_is_ge(NUM_MIN3, half_avg_samp);
      unif_prob = Invariant.prob_and(unif_prob_1, unif_prob_2, unif_prob_3);
      // System.out.println("Unif_probs: " + unif_prob + " <-- " + unif_prob_1 + " " + unif_prob_2 + " " + unif_prob_3);
    } else {
      unif_prob = 1;
    }

    // Value "2" from above
    double bound_prob = prob_or(trunc_prob, unif_prob);

    // Final result
    return prob_and(bound_samples_prob, bound_prob);

    // System.out.println(LOWERBOUNDCORESTR + ".computeProbability(): ");
    // System.out.println("  " + repr());
    // System.out.println("  ppt=" + wrapper.ppt.name()
    //                    + ", wrapper.ppt.num_mod_samples()="
    //                    + wrapper.ppt.num_mod_samples()
    //                    // + ", values=" + values
    //                    + ", avg_samples_per_val=" + avg_samples_per_val
    //                    + ", result = " + result
    //                    + ", bound_samples_prob=" + bound_samples_prob
    //                    + ", bound_prob=" + bound_prob
    //                    + ", trunc_prob=" + trunc_prob
    //                    + ", unif_prob=" + unif_prob);
    // PptSlice pptsg = (PptSlice) ppt;
    // System.out.println("  " + ppt.name());

  }

  @Pure
  public boolean isSameFormula(LOWERBOUNDCORE other) {
    return MIN1 == other.MIN1;
  }

  @Pure
  public boolean isExact() {
    return false;
  }

  // Merge lbc into this.
  public void add(LOWERBOUNDCORE lbc) {

    // Pass each value and its count to this invariant's add_modified.  Since
    // bound is never destroyed, we don't need to check the results.
    if (lbc.NUM_MIN1 > 0) {
      add_modified(lbc.MIN1, lbc.NUM_MIN1);
    }
    if (lbc.NUM_MIN2 > 0) {
      add_modified(lbc.MIN2, lbc.NUM_MIN2);
    }
    if (lbc.NUM_MIN3 > 0) {
      add_modified(lbc.MIN3, lbc.NUM_MIN3);
    }
    // NUM_MIN1 will be positive if and only if we've ever seen any
    // real samples. Only then does MAX represent a real sample.
    if (lbc.NUM_MIN1 > 0) {
      add_modified(lbc.MAX, 1);
    }
    if (Debug.logDetail()) {
      wrapper.log("Added vals %s of %s, %s of %s, %s of %s, %s from ppt %s",
                   lbc.NUM_MIN1, lbc.MIN1, lbc.NUM_MIN2, lbc.MIN2,
                   lbc.NUM_MIN3, lbc.MIN3,
                   ((lbc.NUM_MIN1 > 0) ?  "1 of " + lbc.MAX : ""),
                   lbc.wrapper.ppt.parent.ppt_name);
    }
  }
}
