#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SUB) || defined(SUBFLOAT) || defined(SUP) || defined(SUPFLOAT))
  #error "SUBSET, SUBSETFLOAT, SUPERSET, or SUPERSETFLOAT  must be defined"
#endif

#if (defined(SUB) || defined(SUP))
  #define TWOSEQUENCE TwoSequence
  #define LONG long
  #define SUBSEQUENCE SubSequence
  #define IS_SUBSET(a,b) ArraysPlume.isSubset(a,b)
  #define BASE_IS_TYPE baseIsScalar()
  #define PAIRWISE_EQ PairwiseIntEqual
  #define SEQSEQ_EQ SeqSeqIntEqual
#elif (defined(SUBFLOAT) || defined(SUPFLOAT))
  #define TWOSEQUENCE TwoSequenceFloat
  #define LONG double
  #define SUBSEQUENCE SubSequenceFloat
  #define IS_SUBSET(a,b) Global.fuzzy.isSubset(a,b)
  #define BASE_IS_TYPE baseIsFloat()
  #define SEQSEQ_EQ SeqSeqFloatEqual
  #define PAIRWISE_EQ PairwiseFloatEqual
#endif

#if defined(SUB)
  #define SUBSET SubSet
  #define SUBSETSTRING "SubSet"
  #define SUBSET_SWAP SuperSet
#elif defined(SUBFLOAT)
  #define SUBSET SubSetFloat
  #define SUBSETSTRING "SubSetFloat"
  #define SUBSET_SWAP SuperSetFloat
#elif defined(SUP)
  #define SUBSET SuperSet
  #define SUBSETSTRING "SuperSet"
  #define SUBSET_SWAP SubSet
#elif defined(SUPFLOAT)
  #define SUBSET SuperSetFloat
  #define SUBSETSTRING "SuperSetFloat"
  #define SUBSET_SWAP SubSetFloat
#endif

// ***** This file is automatically generated from SubSet.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.inv.*;
import daikon.suppress.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.dataflow.qual.SideEffectFree;
import org.plumelib.util.ArraysPlume;
import typequals.prototype.qual.NonPrototype;
import typequals.prototype.qual.Prototype;

/**
 * Represents two sequences of LONG values where one of the sequences is a subset of the other; that
 * is each element of one sequence appears in the other. Prints as either
 * {@code x[] is a subset of y[]} or as {@code x[] is a superset of y[]}.
 */
public class SUBSET extends TWOSEQUENCE {
  static final long serialVersionUID = 20031024L;

  private static final Logger debug =
    Logger.getLogger("daikon.inv.binary.twoSequence." + SUBSETSTRING);

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /** Boolean. True iff SubSet invariants should be considered. */
  public static boolean dkconfig_enabled = false;

  protected SUBSET(PptSlice ppt) {
    super(ppt);
  }

  protected @Prototype SUBSET() {
    super();
  }

  private static @Prototype SUBSET proto = new @Prototype SUBSET();

  /** Returns the prototype invariant for SUBSET */
  public static @Prototype SUBSET get_proto() {
    return proto;
  }

  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  @Override
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

    #if 0
      // JHP: This code is removed because these sorts of static checks
      // can't be reliability performed with equality sets (just because
      // the leaders are obvious subsets, does not imply that all members
      // are.  Eventually this should be moved to isObviousStatically()

      VarInfo var1 = vis[0];
      VarInfo var2 = vis[1];
      // System.out.println("SubSet.isObviousDerived(" + format() + ") = "
      //                    + ((SubSet.isObviousDerived(var1(), var2()))
      //                       || (SubSet.isObviousDerived(var2(), var1()))));
      DiscardInfo obvDeriv1 = SUBSET.isObviousSubSet(this, var1, var2);
      DiscardInfo obvDeriv2 = SUBSET.isObviousSubSet(this, var2, var1);
      if (obvDeriv1[1]!=null || obvDeriv2[1]!=null) {
        Global.implied_noninstantiated_invariants++;
        if (debug.isLoggable(Level.FINE)) {
          debug.fine(var1 + ", " + var2);
          debug.fine("Obvious derived, returning null");
        }
        return null;
      }
    #endif

    return true;
  }

  @Override
  public SUBSET instantiate_dyn(@Prototype SUBSET this, PptSlice slice) {
    return new SUBSET(slice);
  }

  @Override
  protected Invariant resurrect_done_swapped() {
    return new SUBSET_SWAP(ppt);
  }

  @Override
  public String repr(@GuardSatisfied SUBSET this) {
    return SUBSETSTRING + varNames() + ": ,falsified=" + falsified;
  }

  @SideEffectFree
  @Override
  public String format_using(@GuardSatisfied SUBSET this, OutputFormat format) {
    if (format == OutputFormat.DAIKON) {
      return format();
    }
    if (format == OutputFormat.ESCJAVA) {
      return format_esc();
    }
    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }
    if (format == OutputFormat.CSHARPCONTRACT) {
      return format_csharp_contract();
    }
    if (format.isJavaFamily()) {
      return format_java_family(format);
    }

    return format_unimplemented(format);
  }

  @SideEffectFree
  @Override
  public String format(@GuardSatisfied SUBSET this) {
    String v1 = var1().name();
    String v2 = var2().name();
    #if (defined(SUB) || defined(SUBFLOAT))
    return v1 + " is a subset of " + v2;
    #else
    return v1 + " is a superset of " + v2;
    #endif
  }

  public String format_csharp_contract(@GuardSatisfied SUBSET this) {
    String v1 = var1().csharp_collection_string();
    String v2 = var2().csharp_collection_string();

    #if (defined(SUB) || defined(SUBFLOAT))
    return "Contract.ForAll(" + v1 + ", i => " + v2 + ".Contains(i))";
    #else
    return "Contract.ForAll(" + v2 + ", i => " + v1 + ".Contains(i))";
    #endif
  }

  public String format_esc(@GuardSatisfied SUBSET this) {
    String classname = this.getClass().toString().substring(6); // remove leading "class"
    return "warning: method " + classname + ".format_esc() needs to be implemented: " + format();
  }

  public String format_simplify(@GuardSatisfied SUBSET this) {
    if (Invariant.dkconfig_simplify_define_predicates) {
      return format_simplify_defined();
    } else {
      return format_simplify_explicit();
    }
  }

  private String format_simplify_defined(@GuardSatisfied SUBSET this) {
#if defined(SUB) || defined(SUBFLOAT)
    VarInfo subvar = var1();
    VarInfo supervar = var2();
#else
    VarInfo subvar = var2();
    VarInfo supervar = var1();
#endif
    String[] sub_name = subvar.simplifyNameAndBounds();
    String[] super_name = supervar.simplifyNameAndBounds();

    if (sub_name == null || super_name == null) {
      return String.format("%s.format_simplify_defined(%s): sub_name=%s, super_name=%s, for %s",
                           getClass().getSimpleName(), this,
                           Arrays.toString(sub_name), Arrays.toString(super_name), format());
    }

    return "(subset "
      + sub_name[0] + " " + sub_name[1] + " " + sub_name[2] + " "
      + super_name[0] + " " + super_name[1] + " " + super_name[2] + ")";
  }

  private String format_simplify_explicit(@GuardSatisfied SUBSET this) {
#if defined(SUB) || defined(SUBFLOAT)
    VarInfo subvar = var1();
    VarInfo supervar = var2();
#else
    VarInfo subvar = var2();
    VarInfo supervar = var1();
#endif
    String[] sub_name = subvar.simplifyNameAndBounds();
    String[] super_name = supervar.simplifyNameAndBounds();

    if (sub_name == null || super_name == null) {
      return String.format("%s.format_simplify_explicit(%s): sub_name=%s, super_name=%s, for %s",
                           getClass().getSimpleName(), this,
                           Arrays.toString(sub_name), Arrays.toString(super_name), format());
    }

    String indices[] = VarInfo.get_simplify_free_indices(subvar, supervar);

    // (FORALL (a i j b ip jp)
    //    (IFF (subset a i j b ip jp)
    //         (FORALL (x)
    //           (IMPLIES
    //              (AND (<= i x) (<= x j))
    //              (EXISTS (y)
    //                  (AND (<= ip y) (<= y jp)
    //                        (EQ (select (select elems a) x)
    //                            (select (select elems b) y))))))))

    return "(FORALL (" + indices[0] + ") (IMPLIES (AND (<= " + sub_name[1]
      + " " + indices[0] + ") (<= " + indices[0] + " " + sub_name[2] + "))"
      + "(EXISTS (" + indices[1] + ")(AND (<= " + super_name[1] + " "
      + indices[1] + ") (<= " + indices[1] + " " + super_name[2]+ ")"
      + "(EQ (select (select elems " + sub_name[0] + ") " + indices[0] + ") "
      + "(select (select elems " + super_name[0] +") " + indices[1] + "))))))";

  }

  public String format_java_family(@GuardSatisfied SUBSET this, OutputFormat format) {

    String v1 = var1().name_using(format);
    String v2 = var2().name_using(format);
    #if (defined(SUB) || defined(SUBFLOAT))
    return "daikon.Quant.subsetOf(" + v1 + ", " + v2 + ")";
    #else
    return "daikon.Quant.subsetOf(" + v2 + ", " + v1 + ")";
    #endif

  }

  @Override
  public InvariantStatus check_modified(LONG[] a1, LONG[] a2, int count) {
#if (defined(SUB) || defined(SUBFLOAT))
    if (!IS_SUBSET(a1, a2)) {
#else
    if (!IS_SUBSET(a2, a1)) {
#endif
      return InvariantStatus.FALSIFIED;
    } else {
      return InvariantStatus.NO_CHANGE;
    }
#if (defined(balance_curlies_in_cpp_file))
    }
#endif
  }

  @Override
  public InvariantStatus add_modified(LONG[] a1, LONG[] a2, int count) {
    if (debug.isLoggable(Level.FINE)) {
      debug.fine(Arrays.toString(a1));
      debug.fine(Arrays.toString(a2));
    }
    return check_modified(a1, a2, count);
  }

  @Override
  protected double computeConfidence() {
    return Invariant.CONFIDENCE_JUSTIFIED;
  }

  // Convenience name to make this easier to find.
  @Pure
  public static @Nullable DiscardInfo isObviousSubSet(Invariant inv, VarInfo subvar, VarInfo supervar) {
    return SUBSEQUENCE.isObviousSubSequence(inv, subvar, supervar);
  }

  @Pure
  @Override
  public @Nullable DiscardInfo isObviousStatically(VarInfo[] vis) {
    VarInfo var1 = vis[0];
    VarInfo var2 = vis[1];

    DiscardInfo di;
    di = SUBSET.isObviousSubSet(this, var1, var2);
    if (di == null) {
      di = SUBSET.isObviousSubSet(this, var2, var1);
    }
    if (di != null) {
      return di;
    }

    VarInfo subvar, supervar;
    #if (defined(SUB) || defined(SUBFLOAT))
    subvar = var1;
    supervar = var2;
    #else
    subvar = var2;
    supervar = var2;
    #endif

    // Uninteresting if this is of the form x[0..i] subsequence
    // x[0..j].  Not necessarily obvious.
    VarInfo subvar_super = subvar.isDerivedSubSequenceOf();
    if (subvar_super == supervar) {
      debug.fine("  returning true because subvar_super == supervar");
      return new DiscardInfo(this, DiscardCode.obvious, "x[0..i] subsequence of x[0..j] is uninteresting");
    }

    VarInfo supervar_super = supervar.isDerivedSubSequenceOf();
    if (subvar_super != null && subvar_super == supervar_super) {
      debug.fine("  returning true because subvar_super == supervar_super");
      return new DiscardInfo(this, DiscardCode.obvious, "x[0..i] subsequence of x[0..j] is uninteresting");
    }

    di = SubSequence.isObviousSubSequence(this, var1, var2);
    if (di == null) {
      di = SubSequence.isObviousSubSequence(this, var2, var1);
    }
    if (di != null) {
      return di;
    }
    return super.isObviousStatically(vis);
  }

  // Look up a previously instantiated SubSet relationship.
  public static @Nullable SUBSET find(PptSlice ppt) {
    assert ppt.arity() == 2;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof SUBSET) {
        return (SUBSET) inv;
      }
    }
    return null;
  }

  @Pure
  @Override
  public boolean isSameFormula(Invariant other) {
    assert other instanceof SUBSET;
    return true;
  }

  /** NI suppressions, initialized in get_ni_suppressions() */
  private static @Nullable NISuppressionSet suppressions = null;

  /** returns the ni-suppressions for SUBSET */
  @Pure
  @Override
  public NISuppressionSet get_ni_suppressions() {
    if (suppressions == null) {
      NISuppressee suppressee = new NISuppressee(SUBSET.class, 2);

      // suppressor definitions (used in suppressions below)
      NISuppressor v1_eq_v2 = new NISuppressor(0, 1, SEQSEQ_EQ.class);
      NISuppressor v1_pw_eq_v2 = new NISuppressor(0, 1, PAIRWISE_EQ.class);

      // sub/super set suppressions.  We have both SeqSeq and Pairwise
      // as suppressions because each can be enabled separately.
      suppressions = new NISuppressionSet(
          new NISuppression[] {
              // a[] == b[] ==> a[] sub/superset b[]
              new NISuppression(v1_eq_v2, suppressee),
              // a[] == b[] ==> a[] sub/superset b[]
              new NISuppression(v1_pw_eq_v2, suppressee),
          });
    }

    return suppressions;
  }
}
