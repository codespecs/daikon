#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPEDOUBLE) || defined(TYPELONG))
  #error "TYPEDOUBLE or TYPELONG must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME LinearBinary
  #define SUPERCLASS TwoScalar
  #define CORECLASS LinearBinaryCore
  #define PRIMITIVE long
  #define CLASSSTRING "LinearBinary"
#elif defined(TYPEDOUBLE)
  #define CLASSNAME LinearBinaryFloat
  #define SUPERCLASS TwoFloat
  #define CORECLASS LinearBinaryCoreFloat
  #define PRIMITIVE double
  #define CLASSSTRING "LinearBinaryFloat"
#endif

// ***** This file is automatically generated from LinearBinary.java.jpp

package daikon.inv.binary.twoScalar;

import daikon.*;
import daikon.derive.unary.SequenceLength;
import daikon.inv.*;
import java.util.*;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.dataflow.qual.Pure;
import org.checkerframework.dataflow.qual.SideEffectFree;
import typequals.prototype.qual.NonPrototype;
import typequals.prototype.qual.Prototype;

/**
 * Represents a Linear invariant between two PRIMITIVE scalars {@code x} and {@code y}, of
 * the form {@code ax + by + c = 0}. The constants {@code a}, {@code b} and
 * {@code c} are mutually relatively prime, and the constant {@code a} is always positive.
 */
public class CLASSNAME extends SUPERCLASS {
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /** Boolean. True iff LinearBinary invariants should be considered. */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  public CORECLASS core;

  @SuppressWarnings("nullness") // circular initialization
  protected CLASSNAME(PptSlice ppt) {
    super(ppt);
    core = new CORECLASS(this);
  }

  @SuppressWarnings("nullness") // circular initialization
  protected @Prototype CLASSNAME() {
    super();
    // Do we need core to be set for a prototype invariant?
    core = new CORECLASS(this);
  }

  private static @Prototype CLASSNAME proto = new @Prototype CLASSNAME();

  /** Returns a prototype CLASSNAME invariant. */
  public static @Prototype CLASSNAME get_proto() {
    return proto;
  }

  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  @Override
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

    #if defined (TYPELONG)
      // Don't look for linearbinary over hashcodes and booleans
      if (!vis[0].file_rep_type.isIntegral()
          || !vis[1].file_rep_type.isIntegral())
        return false;
    #endif

    return true;
  }

  @Override
  protected CLASSNAME instantiate_dyn(@Prototype CLASSNAME this, PptSlice slice) {
    return new CLASSNAME(slice);
  }

  @SideEffectFree
  @Override
  public CLASSNAME clone(@GuardSatisfied CLASSNAME this) {
    CLASSNAME result = (CLASSNAME) super.clone();
    result.core = core.clone();
    result.core.wrapper = result;
    return result;
  }

  @Override
  protected Invariant resurrect_done_swapped() {
    core.swap();
    return this;
  }

  @Override
  public String repr(@GuardSatisfied CLASSNAME this) {
    return CLASSSTRING + varNames() + ": falsified=" + falsified
      + "; " + core.repr();
  }

  @SideEffectFree
  @Override
  public String format_using(@GuardSatisfied CLASSNAME this, OutputFormat format) {
    return core.format_using(format, var1().name_using(format),
                             var2().name_using(format));
  }

  @Pure
  @Override
  public boolean isActive() {
    return core.isActive();
  }

  @Override
  public boolean mergeFormulasOk() {
    return core.mergeFormulasOk();
  }

  /**
   * Merge the invariants in invs to form a new invariant. Each must be a CLASSNAME invariant. The
   * work is done by the LinearBinary core
   *
   * @param invs list of invariants to merge. They should all be permuted to match the variable
   *     order in parent_ppt.
   * @param parent_ppt slice that will contain the new invariant
   */
  @Override
  public @Nullable CLASSNAME merge(List<Invariant> invs, PptSlice parent_ppt) {

    // Create a matching list of cores
    List<CORECLASS> cores = new ArrayList<>();
    for (Invariant inv : invs) {
      cores.add(((CLASSNAME) inv).core);
    }

    // Merge the cores and build a new invariant containing the merged core
    CLASSNAME result = new CLASSNAME(parent_ppt);
    CORECLASS newcore = core.merge(cores, result);
    if (newcore == null) {
      return null;
    }
    result.core = newcore;
    return result;
  }

  @Override
  public InvariantStatus check_modified(PRIMITIVE x, PRIMITIVE y, int count) {
    return clone().add_modified(x, y, count);
  }

  @Override
  public InvariantStatus add_modified(PRIMITIVE x, PRIMITIVE y, int count) {
    return core.add_modified(x, y, count);
  }

  @Override
  public boolean enoughSamples(@GuardSatisfied CLASSNAME this) {
    return core.enoughSamples();
  }

  @Override
  protected double computeConfidence() {
    return core.computeConfidence();
  }

  @Pure
  @Override
  public boolean isExact() {
    return true;
  }

  @Pure
  @Override
  public @Nullable DiscardInfo isObviousStatically(VarInfo[] vis) {
    // Obvious derived
    VarInfo var1 = vis[0];
    VarInfo var2 = vis[1];
    // avoid comparing "size(a)" to "size(a)-1"; yields "size(a)-1 = size(a) - 1"
    if (var1.isDerived()
        && (var1.derived instanceof SequenceLength)
        && var2.isDerived()
        && (var2.derived instanceof SequenceLength)) {
      @NonNull SequenceLength sl1 = (SequenceLength) var1.derived;
      @NonNull SequenceLength sl2 = (SequenceLength) var2.derived;
      if (sl1.base == sl2.base) {
        String discardString = var1.name()+" and "+var2.name()+" derived from "+
          "same sequence: "+sl1.base.name();
        return new DiscardInfo(this, DiscardCode.obvious, discardString);
      }
    }
    // avoid comparing "size(a)-1" to anything; should compare "size(a)" instead
    if (var1.isDerived()
        && (var1.derived instanceof SequenceLength)
        && ((SequenceLength) var1.derived).shift != 0) {
      String discardString = "Variables of the form 'size(a)-1' are not compared since 'size(a)' "+
        "will be compared";
      return new DiscardInfo(this, DiscardCode.obvious, discardString);
    }
    if (var2.isDerived()
        && (var2.derived instanceof SequenceLength)
        && ((SequenceLength) var2.derived).shift != 0) {
      String discardString = "Variables of the form 'size(a)-1' are not compared since 'size(a)' "+
        "will be compared";
      return new DiscardInfo(this, DiscardCode.obvious, discardString);
    }

    return super.isObviousStatically(vis);
  }

  @Pure
  @Override
  public @Nullable DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    if (core.a == 0) {
      return new DiscardInfo(this, DiscardCode.obvious, var2().name() + " is constant");
    }
    if (core.b == 0) {
      return new DiscardInfo(this, DiscardCode.obvious, var1().name() + " is constant");
    }
//    if (core.a == 1 && core.b == 0) {
//      return new DiscardInfo(this, DiscardCode.obvious, "Variables are equal");
//    }
    if (core.a == -core.b && core.c == 0) {
     return new DiscardInfo(this, DiscardCode.obvious, "Variables are equal");
    }
    return null;
  }

  @Pure
  @Override
  public boolean isSameFormula(Invariant other) {
    return core.isSameFormula(((CLASSNAME) other).core);
  }

  @Pure
  @Override
  public boolean isExclusiveFormula(Invariant other) {
    if (other instanceof CLASSNAME) {
      return core.isExclusiveFormula(((CLASSNAME) other).core);
    }
    return false;
  }

  // Look up a previously instantiated invariant.
  public static @Nullable CLASSNAME find(PptSlice ppt) {
    assert ppt.arity() == 2;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof CLASSNAME) {
        return (CLASSNAME) inv;
      }
    }
    return null;
  }

  // Returns a vector of LinearBinary objects.
  // This ought to produce an iterator instead.
  public static List<CLASSNAME> findAll(VarInfo vi) {
    List<CLASSNAME> result = new ArrayList<>();
    for (PptSlice view : vi.ppt.views_iterable()) {
      if ((view.arity() == 2) && view.usesVar(vi)) {
        CLASSNAME lb = CLASSNAME.find(view);
        if (lb != null) {
          result.add(lb);
        }
      }
    }
    return result;
  }
}
