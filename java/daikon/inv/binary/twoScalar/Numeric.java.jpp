#if 0
// Do not attempt to compile this file with a Java compiler such as javac.
// You first need to preprocess it with cpp, the C preprocessor.
// The correct way to build the system is to run 'make'.
#endif

#if (defined(TYPELONG))
  #define PACKAGE twoScalar
  #define CLASSNAME NumericInt
  #define SUPERCLASS TwoScalar
  #define PRIMITIVE long
  #define EQUALS(a,b) (a == b)
  #define VALUE_SET ValueSet.ValueSetScalarArray
  #define ONEOF OneOfScalar
  #define ONEOF_ZERO InvDef.elts_zero
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one
  #define ONEOF_ONE InvDef.elts_one
  #define SEQ_SUBSCRIPT SequenceScalarSubscript
  #define NONZERO NonZero
  #define BASE_IS_TYPE isIntegral()
  #define EQUAL_ONE  RangeInt.EqualOne
  #define EQUAL_MINUS_ONE  RangeInt.EqualMinusOne
  #define EQUAL_ZERO RangeInt.EqualZero
  #define GREATER_EQUAL_ZERO RangeInt.GreaterEqualZero
  #define EQUALITY IntEqual
  #define LESS_EQUAL IntLessEqual
  #define BOUND0_63 RangeInt.Bound0_63
#elif defined(TYPEDOUBLE)
  #define PACKAGE twoScalar
  #define CLASSNAME NumericFloat
  #define SUPERCLASS TwoFloat
  #define PRIMITIVE double
  #define EQUALS(a,b) (Global.fuzzy.eq (a, b))
  #define VALUE_SET ValueSet.ValueSetFloatArray
  #define ONEOF OneOfFloat
  #define ONEOF_ZERO InvDef.elts_zero_float
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one_float
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one_float
  #define ONEOF_ONE InvDef.elts_one_float
  #define SEQ_SUBSCRIPT SequenceFloatSubscript
  #define EQUALITY FloatEqual
  #define NONZERO NonZeroFloat
  #define BASE_IS_TYPE isFloat()
  #define EQUAL_ONE  RangeFloat.EqualOne
  #define EQUAL_MINUS_ONE  RangeFloat.EqualMinusOne
  #define EQUAL_ZERO RangeFloat.EqualZero
  #define GREATER_EQUAL_ZERO RangeFloat.GreaterEqualZero
  #define EQUALITY FloatEqual
  #define LESS_EQUAL FloatLessEqual
  #define BOUND0_63 RangeFloat.Bound0_63
#elif (defined(TYPESTRING))
  #define STRING
  #define PACKAGE twoString
  #define CLASSNAME StdString
  #define SUPERCLASS TwoString
  #define PRIMITIVE String
  #define EQUALS(a,b) (a.equals(b))
  #define VALUE_SET
  #define ONEOF
  #define ONEOF_ZERO
  #define ONEOF_PLUS_MINUS_ONE
  #define ONEOF_MINUS_ONE
  #define ONEOF_ONE
  #define SEQ_SUBSCRIPT SequenceStringSubscript
  #define NONZERO
  #define BASE_IS_TYPE isString()
  #define EQUAL_ONE
  #define EQUAL_MINUS_ONE
  #define EQUAL_ZERO
  #define GREATER_EQUAL_ZERO
  #define EQUALITY StringEqual
  #define LESS_EQUAL
  #define BOUND0_63
#elif defined(TYPELONGSEQ)
  #define PACKAGE twoSequence
  #define SEQ
  #define CLASSNAME PairwiseNumericInt
  #define SUPERCLASS TwoSequence
  #define PRIMITIVE long
  #define EQUALS(a,b) (a == b)
  #define VALUE_SET ValueSet.ValueSetScalarArray
  #define ONEOF EltOneOf
  #define ONEOF_ZERO InvDef.elts_zero
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one
  #define SEQ_SUBSEQUENCE SequenceScalarSubsequence
  #define EQUAL_ONE  EltRangeInt.EqualOne
  #define EQUAL_MINUS_ONE  EltRangeInt.EqualMinusOne
  #define EQUAL_ZERO EltRangeInt.EqualZero
  #define GREATER_EQUAL_ZERO EltRangeInt.GreaterEqualZero
  #define EQUALITY PairwiseIntEqual
  #define LESS_EQUAL PairwiseIntLessEqual
  #define BOUND0_63 EltRangeInt.Bound0_63
  #define NONZERO EltNonZero
  #define GREATER_EQUAL_ZERO EltRangeInt.GreaterEqualZero
  #define BASE_IS_TYPE baseIsIntegral()
#elif defined(TYPEDOUBLESEQ)
  #define PACKAGE twoSequence
  #define SEQ
  #define CLASSNAME PairwiseNumericFloat
  #define SUPERCLASS TwoSequenceFloat
  #define PRIMITIVE double
  #define EQUALS(a,b) (Global.fuzzy.eq (a, b))
  #define VALUE_SET ValueSet.ValueSetFloatArray
  #define ONEOF EltOneOfFloat
  #define ONEOF_ZERO InvDef.elts_zero_float
  #define ONEOF_PLUS_MINUS_ONE InvDef.elts_plus_minus_one_float
  #define ONEOF_MINUS_ONE InvDef.elts_minus_one_float
  #define SEQ_SUBSEQUENCE SequenceFloatSubsequence
  #define EQUAL_ONE  EltRangeFloat.EqualOne
  #define EQUAL_MINUS_ONE  EltRangeFloat.EqualMinusOne
  #define EQUAL_ZERO EltRangeFloat.EqualZero
  #define GREATER_EQUAL_ZERO EltRangeFloat.GreaterEqualZero
  #define EQUALITY PairwiseFloatEqual
  #define LESS_EQUAL PairwiseFloatLessEqual
  #define NONZERO EltNonZeroFloat
  #define GREATER_EQUAL_ZERO EltRangeFloat.GreaterEqualZero
  #define BASE_IS_TYPE baseIsFloat()
#elif defined (TYPESTRINGSEQ)
  #define PACKAGE twoSequence
  #define STRING
  #define SEQ
  #define CLASSNAME PairwiseString
  #define SUPERCLASS TwoSequenceString
  #define PRIMITIVE String
  #define EQUALS(a,b) (a.equals(b))
  #define VALUE_SET ValueSet.ValueSetStringArray
  #define ONEOF EltOneOf
  #define ONEOF_ZERO
  #define ONEOF_PLUS_MINUS_ONE
  #define ONEOF_MINUS_ONE
  #define SEQ_SUBSEQUENCE SequenceStringSubsequence
  #define EQUAL_ONE
  #define EQUAL_MINUS_ONE
  #define EQUAL_ZERO
  #define GREATER_EQUAL_ZERO
  #define EQUALITY PairwiseStringEqual
  #define LESS_EQUAL
  #define BOUND0_63
  #define NONZERO
  #define GREATER_EQUAL_ZERO
  #define BASE_IS_TYPE baseIsString()
#else
  #error "TYPELONG, TYPEDOUBLE, TYPESTRING, TYPELONGSEQ, TYPESTRINGSEQ or TYPEDOUBLESEQ  must be defined"
#endif

#if (defined(SEQ))
  #define VAR1 x[]
  #define VAR2 y[]
  #define COMMENT_TXT corresponding elements of two sequences of PRIMITIVE
#else
  #define VAR1 x
  #define VAR2 y
  #define COMMENT_TXT two PRIMITIVE scalars
#endif

// ***** This file is automatically generated from Numeric.java.jpp

package daikon.inv.binary.PACKAGE;

import daikon.*;
import daikon.inv.*;
import daikon.inv.unary.sequence.*;
import daikon.inv.unary.scalar.*;
import daikon.inv.binary.twoScalar.*;
import daikon.inv.binary.twoString.*;
import daikon.derive.binary.*;
import daikon.suppress.*;
import daikon.Quantify.QuantFlags;
import static daikon.inv.Invariant.asInvClass;

import plume.*;
import java.util.*;

/*>>>
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.checker.signature.qual.*;
import org.checkerframework.dataflow.qual.*;
import typequals.*;
*/

/**
 * Baseclass for binary numeric invariants.
 *
 * Each specific invariant is implemented in a subclass (typically, in
 * this file).  The subclass must provide the methods instantiate(),
 * check(), and format(). Symmetric functions should define
 * is_symmetric() to return true.
 */
public abstract class CLASSNAME extends SUPERCLASS {

  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20060609L;

  protected CLASSNAME(PptSlice ppt, boolean swap) {
    super(ppt);
    this.swap = swap;
  }

  protected CLASSNAME(boolean swap) {
    super();
    this.swap = swap;
  }

  /**
   * Returns true if it is ok to instantiate a numeric invariant over the
   * specified slice.
   */
  public boolean instantiate_ok (VarInfo[] vis) {

    ProglangType type1 = vis[0].file_rep_type;
    ProglangType type2 = vis[1].file_rep_type;
    if (!type1.BASE_IS_TYPE || !type2.BASE_IS_TYPE) {
      return false;
    }

    return true;
  }

  /*@Pure*/
  public boolean isExact() {
    return true;
  }

  public String repr(/*>>>@GuardSatisfied CLASSNAME this*/) {
    return getClass().getSimpleName() + ": " + format() +
      (swap ? " [swapped]" : " [unswapped]");
  }

  /**
   * Returns a string in the specified format that describes the invariant.
   *
   * The generic format string is obtained from the subclass specific
   * get_format_str().  Instances of %varN% are replaced by the variable
   * name in the specified format.
   */
  /*@SideEffectFree*/
  public String format_using(/*>>>@GuardSatisfied CLASSNAME this,*/ OutputFormat format) {

    if (ppt == null) {
      return (String.format ("proto ppt [class %s] format %s", getClass(),
                             get_format_str (format)));
    }
    String fmt_str = get_format_str (format);
    String v1 = null;
    String v2 = null;

    #if defined(SEQ)
        if (format.isJavaFamily()) {
          #if defined(STRING)
            return format_unimplemented(format);
          #else
            v1 = var1().name_using(format);
            v2 = var2().name_using(format);
            if (this instanceof Divides) {
              return "daikon.Quant.pairwiseDivides(" + v1 + ", " + v2 + ")";
            } else if (this instanceof Square) {
              return "daikon.Quant.pairwiseSquare(" + v1 + ", " + v2 + ")";
          #if defined(TYPELONG) || defined(TYPELONGSEQ)
            } else if (this instanceof BitwiseComplement) {
              return "daikon.Quant.pairwiseBitwiseComplement(" +v1+", "+v2+ ")";
            } else if (this instanceof BitwiseSubset) {
              return "daikon.Quant.pairwiseBitwiseSubset(" +v1+ ", " + v2 + ")";
          #endif
            } else {
              return format_unimplemented(format);
            }
          #endif
        }

        if (format == OutputFormat.CSHARPCONTRACT) {
          #if defined(STRING)
            fmt_str = UtilMDE.replaceString(fmt_str, "%var1%", var1().csharp_name());
            fmt_str = UtilMDE.replaceString(fmt_str, "%var2%", var2().csharp_name());
            return fmt_str;
          #else
            v1 = var1().csharp_name();
            v2 = var2().csharp_name();
            String[] split1 = var1().csharp_array_split();
            String[] split2 = var2().csharp_array_split();
            if (this instanceof Divides) {
              return "Contract.ForAll(0, " + split1[0] + ".Count(), i => " + split1[0] + " [i]" + split1[1] + " % " + split2[0] + "[i]" + split2[1] + " == 0)";
            } else if (this instanceof Square) {
              return "Contract.ForAll(0, " + split1[0] + ".Count(), i => " + split1[0] + " [i]" + split1[1] + " == " + split2[0] + "[i]" + split2[1] + "*" + split2[0] + "[i]" + split2[1] + ")";
          #if defined(TYPELONG) || defined(TYPELONGSEQ)
            } else if (this instanceof BitwiseComplement) {
              return "Contract.ForAll(0, " + split1[0] + ".Count(), i => " + split1[0] + " [i]" + split1[1] + " == ~" + split2[0] + "[i]" + split2[1] + ")";
            } else if (this instanceof BitwiseSubset) {
              return "Contract.ForAll(0, " + split1[0] + ".Count(), i => " + split1[0] + " [i]" + split1[1] + " == " + split1[0] + "[i]" + split1[1] + " | " + split2[0] + "[i]" + split2[1] + ")";
          #endif
            } else {
              return format_unimplemented(format);
            }
          #endif
        }

      if (format == OutputFormat.ESCJAVA) {
        String[] form = VarInfo.esc_quantify (var1(), var2());
        fmt_str = form[0] + "(" + fmt_str + ")" + form[3];
        v1 = form[1];
        v2 = form[2];
      } else if (format == OutputFormat.SIMPLIFY) {
        String[] form = VarInfo.simplify_quantify (QuantFlags.element_wise(),
                                                   var1(), var2());
        fmt_str = form[0] + " " + fmt_str + " " + form[3];
        v1 = form[1];
        v2 = form[2];
      } else if (format == OutputFormat.DAIKON) {
        fmt_str += " (elementwise)";
      }
      if (v1 == null) {
        v1 = var1().name_using(format);
      }
      if (v2 == null) {
        v2 = var2().name_using(format);
      }
    #else
      v1 = var1().name_using(format);
      v2 = var2().name_using(format);
    #endif


    // Note that we do not use String.replaceAll here, because that's
    // inseparable from the regex library, and we don't want to have to
    // escape v1 with something like
    // v1.replaceAll("([\\$\\\\])", "\\\\$1")
    fmt_str = UtilMDE.replaceString(fmt_str, "%var1%", v1);
    fmt_str = UtilMDE.replaceString(fmt_str, "%var2%", v2);

    if (false && (format == OutputFormat.DAIKON)) {
      fmt_str = "[" + getClass() + "]" + fmt_str + " ("
             + var1().get_value_info() + ", " + var2().get_value_info() +  ")";
    }
    return fmt_str;
  }

  /**
   * Calls the function specific equal check and returns the correct
   * status.
   */
#if (defined(SEQ))
  public InvariantStatus check_modified(PRIMITIVE[] x, PRIMITIVE[] y,
                                        int count) {
    if (x.length != y.length) {
      if (Debug.logOn()) {
        log ("Falsified - x length = %s y length = %s", x.length, y.length);
      }
      return InvariantStatus.FALSIFIED;
    }

    if (Debug.logDetail()) {
      log ("testing values %s, %s", ArraysMDE.toString (x),
           ArraysMDE.toString(y));
    }

    try {
      for (int i = 0; i < x.length; i++) {
        if (!eq_check (x[i], y[i])) {
          if (Debug.logOn()) {
            log ("Falsified - x[%s]=%s y[%s]=%s", i, x[i], i, y[i]);
          }
          return InvariantStatus.FALSIFIED;
        }
      }
      return InvariantStatus.NO_CHANGE;
    } catch (Exception e) {
      if (Debug.logOn()) {
        log ("Falsified - exception %s", e);
      }
      return InvariantStatus.FALSIFIED;
    }
  }
#else
  public InvariantStatus check_modified(PRIMITIVE x, PRIMITIVE y, int count) {

    try {
      if (eq_check (x, y)) {
        return InvariantStatus.NO_CHANGE;
      } else {
        return InvariantStatus.FALSIFIED;
      }
    } catch (Exception e) {
      return InvariantStatus.FALSIFIED;
    }
  }
#endif

#if defined(SEQ)
  /**
   * Checks to see if this invariant is over subsequences and if the
   * same relationship holds over the full sequence.  This is obvious
   * if it does.  For example 'x[foo..] op y[bar..]' would be obvious
   * if 'x[] op y[]'  This can't fully be handled as a suppression since
   * a suppression needs to insure that foo == bar as well.  But that
   * is not a requirement here (the fact that 'x[] op y[]' implies that
   * foo == bar when x[] and y[] are not missing).
   */
  public /*@Nullable*/ DiscardInfo is_subsequence (VarInfo[] vis) {

    VarInfo v1 = var1(vis);
    VarInfo v2 = var2(vis);

    // Make sure each var is a sequence subsequence
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSEQUENCE)) {
      return null;
    }
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSEQUENCE)) {
      return null;
    }

    @SuppressWarnings("nullness") // checker bug: flow
    /*@NonNull*/ SEQ_SUBSEQUENCE der1 = (SEQ_SUBSEQUENCE) v1.derived;
    @SuppressWarnings("nullness") // checker bug: flow
    /*@NonNull*/ SEQ_SUBSEQUENCE der2 = (SEQ_SUBSEQUENCE) v2.derived;

    // Both of the indices must be either from the start or up to the end.
    // It is not necessary to check that they match in any other way since
    // if the supersequence holds, that implies that the sequences are
    // of the same length.  Thus any subsequence that starts from the
    // beginning or finishes at the end must end or start at the same
    // spot (or it would have been falsified when it didn't)
    if (der1.from_start != der2.from_start) {
      return null;
    }

    // Look up this class over the sequence variables
    Invariant inv = find (getClass(), der1.seqvar(), der2.seqvar());
    if (inv == null) {
      return null;
    }
    return new DiscardInfo(this, DiscardCode.obvious, "Implied by " +
                           inv.format());
  }
#endif

#if !defined(SEQ)
  /**
   * Checks to see if 'x[a] op y[b]' where 'x[] op y[]' and 'a == b'.
   * Doesn't catch the case where a = b+1.
   */
  public /*@Nullable*/ DiscardInfo is_subscript (VarInfo[] vis) {

    VarInfo v1 = var1(vis);
    VarInfo v2 = var2(vis);

    // Make sure each var is a sequence subscript
    if (!v1.isDerived() || !(v1.derived instanceof SEQ_SUBSCRIPT)) {
      return null;
    }
    if (!v2.isDerived() || !(v2.derived instanceof SEQ_SUBSCRIPT)) {
      return null;
    }

    @SuppressWarnings("nullness") // checker bug: flow
    /*@NonNull*/ SEQ_SUBSCRIPT der1 = (SEQ_SUBSCRIPT) v1.derived;
    @SuppressWarnings("nullness") // checker bug: flow
    /*@NonNull*/ SEQ_SUBSCRIPT der2 = (SEQ_SUBSCRIPT) v2.derived;

    // Make sure the shifts match
    if (der1.index_shift != der2.index_shift) {
      return null;
    }

    // Look for this invariant over a sequence
    String cstr = getClass().getName();
    cstr = cstr.replaceFirst ("Numeric", "PairwiseNumeric");
    cstr = cstr.replaceFirst ("twoScalar", "twoSequence");
    cstr = cstr.replaceFirst ("twoFloat", "twoSequence");
    Class<? extends Invariant> pairwise_class;
    try {
      @SuppressWarnings("signature") // string manipulation; application invariants
      /*@ClassGetName*/ String cstr_cgn = cstr;
      pairwise_class = asInvClass(Class.forName (cstr_cgn));
    } catch (Exception e) {
      throw new Error ("can't create class for " + cstr, e);
    }
    Invariant inv = find (pairwise_class, der1.seqvar(), der2.seqvar());
    if (inv == null) {
      return null;
    }

    // Look to see if the subscripts are equal
    Invariant subinv = find (EQUALITY.class, der1.sclvar(), der2.sclvar());
    if (subinv == null) {
      return null;
    }

    return new DiscardInfo(this, DiscardCode.obvious, "Implied by " +
                           inv.format() + " and " + subinv.format());
  }
#endif

  /*@Pure*/
  public /*@Nullable*/ DiscardInfo isObviousDynamically (VarInfo[] vis) {

    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }

    #if (defined (SEQ))
      // any elementwise relation across subsequences is made obvious by
      // the same relation across the original sequence
      DiscardInfo result = is_subsequence (vis);
      if (result != null) return result;
    #else
      // any relation across subscripts is made obvious by the same
      // relation across the original sequence if the subscripts are equal
      DiscardInfo result = is_subscript (vis);
      if (result != null) return result;
    #endif

    // Check for invariant specific obvious checks.  The obvious_checks
    // method returns an array of arrays of antecedents.  If all of the
    // antecedents in an array are true, then the invariant is obvoius.
    InvDef[][] obvious_arr = obvious_checks (vis);
    obvious_loop:
    for (int i = 0; i < obvious_arr.length; i++) {
      InvDef[] antecedents = obvious_arr[i];
      StringBuffer why = null;
      for (int j = 0; j < antecedents.length; j++) {
        Invariant inv = antecedents[j].find ();
        if (inv == null) {
          continue obvious_loop;
        }
        if (why == null) {
          why = new StringBuffer(inv.format());
        } else {
          why.append(" and ");
          why.append(inv.format());
        }
      }
      return new DiscardInfo (this, DiscardCode.obvious, "Implied by " + why);
    }

    return null;
  }

#if defined (SEQ)
  /**
   * Returns an invariant that is true when the size(v1) == size(v2).
   * There are a number of possible cases for an array:
   * <pre>
   *    x[]         - entire array, size usually available as size(x[])
   *    x[..(n-1)]  - size is n
   *    x[..n]      - size is n+1
   *    x[n..]      - size is size(x[]) - n
   *    x[(n+1)..]  - size is size(x[]) - (n+1)
   * </pre>
   * Each combination of the above must be considered in creating the
   * equality invariant.  Not all possibilities can be handled.  Null is
   * returned in that case.  In the following table, s stands for the size
   * <pre>
   *                    x[]     x[..(n-1)]  x[..n]  x[n..]    x[(n+1)..]
   *                  --------- ----------  ------  ------    ----------
   *    y[]           s(y)=s(x)   s(y)=n
   *    y[..(m-1)]        x         m=n
   *    y[..m]            x         x         m=n
   *    y[m..]            x         x          x     m=n &and;
   *                                                s(y)=s(x)
   *    y[(m+1)..]        x         x          x        x       m=n &and;
   *                                                           s(y)=s(x)
   * </pre>
   * NOTE: this is not currently used.  Many (if not all) of the missing
   * table cells above could be filled in with linear binary invariants
   * (eg, m = n + 1).
   */
  public /*@Nullable*/ InvDef array_sizes_eq (VarInfo v1, VarInfo v2) {

    VarInfo v1_size = get_array_size (v1);
    VarInfo v2_size = get_array_size (v2);

    // If we can find a size variable for each side build the invariant
    if ((v1_size != null) && (v2_size != null)) {
      return (new InvDef (v1_size, v2_size, IntEqual.class));
    }

    // If either variable is not derived, there is no possible invariant
    // (since we covered all of the direct size comparisons above)
    if ((v1.derived == null) || (v2.derived == null)) {
      return null;
    }

    // Get the sequence subsequence derivations
    SEQ_SUBSEQUENCE v1_ss = (SEQ_SUBSEQUENCE) v1.derived;
    SEQ_SUBSEQUENCE v2_ss = (SEQ_SUBSEQUENCE) v2.derived;

    // If both are from_start and have the same index_shift, just compare
    // the variables
    if (v1_ss.from_start && v2_ss.from_start
        && (v1_ss.index_shift == v2_ss.index_shift))
      return (new InvDef (v1_ss.sclvar(), v2_ss.sclvar(), IntEqual.class));

    return null;
  }


  /**
   * Returns a variable that corresponds to the size of v.  Returns null
   * if no such variable exists.
   *
   * There are two cases that are
   * not handled:  x[..n] with an index shift and x[n..].
   */
  public /*@Nullable*/ VarInfo get_array_size (VarInfo v) {

    assert v.rep_type.isArray();

    if (v.derived == null) {
      return (v.sequenceSize());
    } else if (v.derived instanceof SEQ_SUBSEQUENCE) {
      SEQ_SUBSEQUENCE ss = (SEQ_SUBSEQUENCE) v.derived;
      if (ss.from_start && (ss.index_shift == -1)) {
        return (ss.sclvar());
      }
    }

    return null;
  }
#endif

  /**
   * Return a format string for the specified output format.  Each instance
   * of %varN% will be replaced by the correct name for varN.
   */
  public abstract String get_format_str (/*>>>@GuardSatisfied CLASSNAME this,*/ OutputFormat format);

  /**
   * Returns true if x and y don't invalidate the invariant.
   */
  public abstract boolean eq_check (PRIMITIVE x, PRIMITIVE y);

  /**
   * Returns an array of arrays of antecedents.  If all of the
   * antecedents in any array are true, then the invariant is obvious.
   */
  public InvDef[][] obvious_checks (VarInfo[] vis) {
    return (new InvDef[][] {});
  }

  public static List</*@Prototype*/ Invariant> get_proto_all() {

    List</*@Prototype*/ Invariant> result = new ArrayList</*@Prototype*/ Invariant>();
    #if (defined(STRING))
        result.add (SubString.get_proto(false));
        result.add (SubString.get_proto(true));
    #else
      result.add (Divides.get_proto (false));
      result.add (Divides.get_proto (true));
      result.add (Square.get_proto (false));
      result.add (Square.get_proto (true));
    #endif
    #if defined(TYPELONG) || defined(TYPELONGSEQ)
      result.add (BitwiseComplement.get_proto());
      result.add (BitwiseSubset.get_proto (false));
      result.add (BitwiseSubset.get_proto (true));
    #endif
    #if defined (TYPELONG) || defined (TYPEDOUBLE)
      result.add (ZeroTrack.get_proto (false));
      result.add (ZeroTrack.get_proto (true));
    #endif
    #if defined (TYPELONG)
      result.add (BitwiseAndZero.get_proto ());
      result.add (ShiftZero.get_proto (false));
      result.add (ShiftZero.get_proto (true));
    #endif
    // System.out.printf ("%s get proto: %s\n", CLASSNAME.class, result);
    return result;
  }

  // suppressor definitions, used by many of the classes below
  protected static NISuppressor
    #if !defined(STRING)
      var1_eq_0       = new NISuppressor (0, EQUAL_ZERO.class),
      var2_eq_0       = new NISuppressor (1, EQUAL_ZERO.class),
      var1_ge_0       = new NISuppressor (0, GREATER_EQUAL_ZERO.class),
      var2_ge_0       = new NISuppressor (1, GREATER_EQUAL_ZERO.class),
      var1_eq_1       = new NISuppressor (0, EQUAL_ONE.class),
      var2_eq_1       = new NISuppressor (1, EQUAL_ONE.class),
      var1_eq_minus_1 = new NISuppressor (0, EQUAL_MINUS_ONE.class),
      var2_eq_minus_1 = new NISuppressor (1, EQUAL_MINUS_ONE.class),
      var1_ne_0       = new NISuppressor (0, NONZERO.class),
      var2_ne_0       = new NISuppressor (1, NONZERO.class),
      var1_le_var2    = new NISuppressor (0, 1, LESS_EQUAL.class),
    #endif
    var1_eq_var2    = new NISuppressor (0, 1, EQUALITY.class),
    var2_eq_var1    = new NISuppressor (0, 1, EQUALITY.class);

  #if defined(TYPELONG) || defined(TYPELONGSEQ)
    protected static NISuppressor var2_valid_shift =
      new NISuppressor (1, BOUND0_63.class);
  #endif

  //
  // Int and Float Numeric Invariants
  //

#if !defined(STRING)
  /**
   * Represents the divides without remainder invariant between
   * COMMENT_TXT.  Prints as <code>VAR1 % VAR2 == 0</code>.
   */
  public static class Divides extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040113L;

    protected Divides (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected Divides (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ Divides proto = new /*@Prototype*/ Divides (false);
    private static /*@Prototype*/ Divides proto_swap = new /*@Prototype*/ Divides (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ CLASSNAME get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff divides invariants should be considered. */
    public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    protected Divides instantiate_dyn (/*>>> @Prototype Divides this,*/ PptSlice slice) {
      return new Divides (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied Divides this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ 0 (MOD %var1% %var2%))";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "%var1% % %var2% == 0";
      #if defined(TYPEDOUBLE)
      } else if (format.isJavaFamily()) {
        return "daikon.Quant.fuzzy.eq(%var1% % %var2%, 0)";
      #endif
      } else {
        return "%var1% % %var2% == 0";
      }
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS(0, (x % y)));
    }


    #if defined(SEQ)
      /**
       * This needs to be an obvious check and not a suppression for
       * sequences because there is no consistent way to check that
       * var1 and var2 have the same length (for derivations).
       */
      public InvDef[][] obvious_checks (VarInfo[] vis) {

        return new InvDef[][] {
          new InvDef[] {
            new InvDef (var2(vis), ONEOF.class, ONEOF_PLUS_MINUS_ONE)
          },
          new InvDef[] {
            new InvDef (var1(), ONEOF.class, ONEOF_ZERO)
          }
        };
      }
    #endif

    /**
     * Returns a list of non-instantiating suppressions for this invariant.
     */
    /*@Pure*/
    public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
      if (swap) {
        return suppressions_swap;
      } else {
        return suppressions;
      }
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (Divides.class, false);

    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {

        #if !defined (SEQ)
          // These suppressions are only valid on scalars because the length
          // of var1 and var2 must also be the same and there is no suppressor
          // for that.

          // var2 == 1 ==> var1 % var2 == 0
          new NISuppression (var2_eq_1, suppressee),

          // var2 == -1 ==> var1 % var2 == 0
          new NISuppression (var2_eq_minus_1, suppressee),

          // (var1 == 0) ^ (var2 != 0) ==> var1 % var2 == 0
          new NISuppression (var1_eq_0, var2_ne_0, suppressee),
        #endif

         // (var1 == var2) ^ (var2 != 0) ==> var1 % var2 == 0
         new NISuppression (var1_eq_var2, var2_ne_0, suppressee),

         // (var2 == var1) ^ (var1 != 0) ==> var2 % var1 == 0
         new NISuppression (var2_eq_var1, var1_ne_0, suppressee),

      });
    private static NISuppressionSet suppressions_swap = suppressions.swap();

    /**
     * Returns non-null if this invariant is obvious from an existing,
     * non-falsified linear binary invariant in the same slice as this
     * invariant.  This invariant of the form "x % y == 0" is falsified
     * if a linear binary invariant is found of the form "a*y - 1*x + 0 == 0"
     *
     * @return non-null value iff this invariant is obvious from
     *          other invariants in the same slice
     */
    /*@Pure*/
    public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
      // First call super type's method, and if it returns non-null, then
      // this invariant is already known to be obvious, so just return
      // whatever reason the super type returned.
      DiscardInfo di = super.isObviousDynamically(vis);
      if (di != null) {
        return di;
      }

      VarInfo var1 = vis[0];
      VarInfo var2 = vis[1];

      // ensure that var1.varinfo_index <= var2.varinfo_index
      if (var1.varinfo_index > var2.varinfo_index) {
        var1 = vis[1];
        var2 = vis[0];
      }

      // Find slice corresponding to these two variables.
      // Ideally, this should always just be ppt if all
      // falsified invariants have been removed.
      PptSlice2 ppt2 = ppt.parent.findSlice(var1,var2);

      // If no slice is found , no invariants exist to make this one obvious.
      if (ppt2 == null) {
        return null;
      }

      // For each invariant, check to see if it's a linear binary
      // invariant of the form "a*y - 1*x + 0 == 0" and if so,
      // you know this invariant of the form "x % y == 0" is obvious.
      for(Invariant inv : ppt2.invs) {
        #if defined(TYPEDOUBLE)
        if (inv instanceof LinearBinaryFloat) {
          LinearBinaryFloat linv = (LinearBinaryFloat) inv;
        #else
        if (inv instanceof LinearBinary) {
          LinearBinary linv = (LinearBinary) inv;
        #endif

          // General form for linear binary: a*x + b*y + c == 0,
          // but a and b can be switched with respect to vis, and either
          // one may be negative, so instead check:
          //  - c == 0
          //  - a*b < 0   (a and b have different signs)
          //  - |a| == 1 or |b| == 1, so one will divide the other
          //     While this means that both x % y == 0 and y % x == 0,
          //     only one of these invariants will still be true at this
          //     time, and only that one will be falsified by this test.
          if ((!linv.is_false()) &&
             Global.fuzzy.eq(linv.core.c, 0) &&
             linv.core.b*linv.core.a < 0 &&
             (Global.fuzzy.eq(linv.core.a*linv.core.a, 1) ||
              Global.fuzzy.eq(linv.core.b*linv.core.b, 1))) {
            return new DiscardInfo(this, DiscardCode.obvious,
                                   "Linear binary invariant implies divides");
          }
        }
      }

      return null;
    }

  }

  /**
   * Represents the square invariant between
   * COMMENT_TXT.  Prints as <code>VAR1 = VAR2**2</code>.
   */
  public static class Square extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040113L;

    protected Square (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected Square (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ Square proto = new /*@Prototype*/ Square (false);
    private static /*@Prototype*/ Square proto_swap = new /*@Prototype*/ Square (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ Square get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff square invariants should be considered. */
    public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }
    protected Square instantiate_dyn (/*>>> @Prototype Square this,*/ PptSlice slice) {
      return new Square (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied Square this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ %var1% (* %var2% %var2))";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "%var1% == %var2%*%var2%";
      } else if (format.isJavaFamily()) {
        #if defined(TYPEDOUBLE)
        return "daikon.Quant.fuzzy.eq(%var1%, %var2%*%var2%)";
        #else
        return "%var1% == %var2%*%var2%";
        #endif
      } else {
        return "%var1% == %var2%**2";
      }
    }

    /** Check to see if x == y squared. */
    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS(x, y*y));
    }

    // Note there are no NI Suppressions for Square.  Two obvious
    // suppressions are:
    //
    //      (var2 == 1) ^ (var1 == 1)  ==> var1 = var2*var2
    //      (var2 == 0) ^ (var1 == 0)  ==> var1 = var2*var2
    //
    // But all of the antecedents would be constants, so we would
    // never need to create this slice, so there is no reason to create
    // these.

  }

  /**
   * Represents the zero tracks invariant between
   * COMMENT_TXT; that is, when <code>VAR1</code> is zero,
   * <code>VAR2</code> is also zero.
   * Prints as <code>VAR1 = 0 &rArr; VAR2 = 0</code>.
   */
  public static class ZeroTrack extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040313L;

    protected ZeroTrack (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected /*@Prototype*/ ZeroTrack (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ ZeroTrack proto = new /*@Prototype*/ ZeroTrack (false);
    private static /*@Prototype*/ ZeroTrack proto_swap = new /*@Prototype*/ ZeroTrack (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ ZeroTrack get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff zero-track invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    protected ZeroTrack instantiate_dyn (/*>>> @Prototype ZeroTrack this,*/ PptSlice slice) {
      return new ZeroTrack (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied ZeroTrack this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(IMPLIES (EQ %var1% 0) (EQ %var2% 0))";
      } else if (format.isJavaFamily() || format == OutputFormat.CSHARPCONTRACT) {
        return "(!(%var1% == 0)) || (%var2% == 0)";
      } else {
        return "(%var1% == 0) ==> (%var2% == 0)";
      }
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      if (x == 0) {
        return (y == 0);
      } else {
        return true;
      }
    }

    /** Returns a list of non-instantiating suppressions for this invariant. */
    /*@Pure*/
    public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
      if (swap) {
        return suppressions_swap;
      } else {
        return suppressions;
      }
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (ZeroTrack.class, false);

    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {
        // (var1 == var2) ==> (var1=0 ==> var2=0)
        new NISuppression (var1_eq_var2, suppressee),
        // (var1 != 0)    ==> (var1=0 ==> var2=0)
        new NISuppression (var1_ne_0, suppressee),
        // (var2 == 0) ==> (var1=0 ==> var2=0)
        new NISuppression (var2_eq_0, suppressee),
      });
    private static NISuppressionSet suppressions_swap = suppressions.swap();

  }

#endif !STRING

#if defined(TYPELONG) || defined(TYPELONGSEQ)

  /**
   * Represents the bitwise complement invariant between
   * COMMENT_TXT.  Prints as <code>VAR1 = ~VAR2</code>.
   */
  public static class BitwiseComplement extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040113L;

    protected BitwiseComplement (PptSlice ppt) {
      super(ppt, false);
    }

    protected /*@Prototype*/ BitwiseComplement () {
      super(false);
    }

    private static /*@Prototype*/ BitwiseComplement proto = new /*@Prototype*/ BitwiseComplement ();

    /** Returns the prototype invariant */
    public static /*@Prototype*/ BitwiseComplement get_proto() {
      return proto;
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff bitwise complement invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    protected BitwiseComplement instantiate_dyn (/*>>> @Prototype BitwiseComplement this,*/ PptSlice slice) {
      return new BitwiseComplement (slice);
    }

    /*@Pure*/
    public boolean is_symmetric() {
      return true;
    }

    public String get_format_str (/*>>>@GuardSatisfied BitwiseComplement this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ %var1% (~ %var2%))";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "%var1% == ~%var2%";
      #if defined(TYPEDOUBLE)
      } else if (format.isJavaFamily()) {
        return "daikon.Quant.fuzzy.eq(%var1%, ~%var2%)";
      #endif
      } else {
        return "%var1% == ~%var2%";
      }
    }

    /** Check to see if x == ~y . */
    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS(x, ~y));
    }
  }

  /**
   * Represents the bitwise subset invariant between
   * COMMENT_TXT; that is, the bits of <code>VAR2</code> are a subset of the
   * bits of <code>VAR1</code>.  Prints as <code>VAR1 = VAR2 | VAR1</code>.
   */
  public static class BitwiseSubset extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040113L;

    protected BitwiseSubset (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected BitwiseSubset (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ BitwiseSubset proto = new /*@Prototype*/ BitwiseSubset (false);
    private static /*@Prototype*/ BitwiseSubset proto_swap = new /*@Prototype*/ BitwiseSubset (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ BitwiseSubset get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff bitwise subset invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    public BitwiseSubset instantiate_dyn (/*>>> @Prototype BitwiseSubset this,*/ PptSlice slice) {
      return new BitwiseSubset (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied BitwiseSubset this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ %var1% (|java-bitwise-or| %var2% %var1%))";
      } else if (format == OutputFormat.DAIKON) {
        return "%var2% is a bitwise subset of %var1%";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "%var1% == (%var2% | %var1%)";
      #if defined(TYPEDOUBLE)
      } else if (format.isJavaFamily()) {
        return "daikon.Quant.fuzzy.eq(%var1%, %var2% | %var1%)";
      #endif
      } else {
        return "%var1% == (%var2% | %var1%)";
      }
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (EQUALS(x, (y | x)));
    }

    #if defined(SEQ)
      /**
       * This needs to be an obvious check and not a suppression for
       * sequences because there is no consistent way to check that
       * var1 and var2 have the same length (for derivations).
       */
      public InvDef[][] obvious_checks (VarInfo[] vis) {

        return new InvDef[][] {
          // suppress if var2 == 0
          new InvDef[] {new InvDef (var2(), ONEOF.class, ONEOF_ZERO)},
          // suppress if var1 == -1 (all of its bits are on)
          new InvDef[] {new InvDef (var1(), ONEOF.class,ONEOF_MINUS_ONE)}
        };
      }
    #endif

    /** Returns a list of non-instantiating suppressions for this invariant. */
    /*@Pure*/
    public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
      if (swap) {
        return suppressions_swap;
      } else {
        return suppressions;
      }
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (BitwiseSubset.class, false);

    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {
        #if !defined(SEQ)
          // (var2 == 0) ==> var1 = (var2 | var1)
          new NISuppression (var2_eq_0, suppressee),

          // (var1 == -1) ==> var1 = (var2 | var1)
          new NISuppression (var1_eq_minus_1, suppressee),
        #endif
        // (var1 == var2) ==> var1 = (var2 | var1)
        new NISuppression (var1_eq_var2, suppressee),

      });
    private static NISuppressionSet suppressions_swap = suppressions.swap();
  }

  /**
   * Represents the BitwiseAnd == 0 invariant between
   * COMMENT_TXT; that is, <code>VAR1</code> and <code>VAR2</code> have no
   * bits in common.  Prints as <code>VAR1 &amp; VAR2 == 0</code>.
   */
  public static class BitwiseAndZero extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040313L;

    protected BitwiseAndZero (PptSlice ppt) {
      super(ppt, false);
    }

    protected /*@Prototype*/ BitwiseAndZero () {
      super(false);
    }

    private static /*@Prototype*/ BitwiseAndZero proto = new /*@Prototype*/ BitwiseAndZero ();

    /** Returns the prototype invariant */
    public static /*@Prototype*/ BitwiseAndZero get_proto () {
      return proto;
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff BitwiseAndZero invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    public BitwiseAndZero instantiate_dyn (/*>>> @Prototype BitwiseAndZero this,*/ PptSlice slice) {
      return new BitwiseAndZero (slice);
    }

    public String get_format_str (/*>>>@GuardSatisfied BitwiseAndZero this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ (|java-&| %var1% %var2%) 0)";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "(%var1% & %var2%) == 0";
      #if defined(TYPEDOUBLE)
      } else if (format.isJavaFamily()) {
        return "daikon.Quant.fuzzy.eq(%var1% & %var2%, 0)";
      #endif
      } else {
        return "(%var1% & %var2%) == 0";
      }
    }

    /*@Pure*/
    public boolean is_symmetric() {
      return true;
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return ((x & y) == 0);
    }

    /** Returns a list of non-instantiating suppressions for this invariant. */
    /*@Pure*/
    public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
      return suppressions;
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (BitwiseAndZero.class, 2);

    #if !defined(SEQ)
    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {
        // (var1 == 0) ==> (var1 & var2) == 0
        new NISuppression (var1_eq_0, suppressee),

        // (var2 == 0) ==> (var1 & var2) == 0
        new NISuppression (var2_eq_0, suppressee),

    });
    #else
    private static /*@Nullable*/ NISuppressionSet suppressions = null;
    #endif
  }

  /**
   * Represents the ShiftZero invariant between
   * COMMENT_TXT;
   * that is, <code>VAR1</code> right-shifted by <code>VAR2</code>
   * is always zero.  Prints as <code>VAR1 &gt;&gt; VAR2 = 0</code>.
   */
  public static class ShiftZero  extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20040313L;

    protected ShiftZero (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected ShiftZero (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ ShiftZero proto = new /*@Prototype*/ ShiftZero (false);
    private static /*@Prototype*/ ShiftZero proto_swap = new /*@Prototype*/ ShiftZero (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ ShiftZero get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff ShiftZero invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    protected ShiftZero instantiate_dyn (/*>>> @Prototype ShiftZero this,*/ PptSlice slice) {
      return new ShiftZero (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied ShiftZero this,*/ OutputFormat format) {
      if (format == OutputFormat.SIMPLIFY) {
        return "(EQ (|java->>| %var1% %var2%) 0)";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        return "(%var1% >> %var2% == 0)";
      #if defined(TYPEDOUBLE)
      } else if (format.isJavaFamily()) {
        return "daikon.Quant.fuzzy.eq(%var1% >> %var2%, 0)";
      #endif
      } else {
        return "(%var1% >> %var2% == 0)";
      }
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      if ((y < 0) || (y > 63)) {
        throw new ArithmeticException ("shift op (" + y + ") is out of range");
      }
      return ((x >> y) == 0);
    }

    /** Returns a list of non-instantiating suppressions for this invariant. */
    /*@Pure*/
    public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
      if (swap) {
        return suppressions_swap;
      } else {
        return suppressions;
      }
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (ShiftZero.class, false);

    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {
          // (var1>=0) ^ (var1<=var2) ^ (0<=var2<=63) ==> (var1 >> var2) == 0
          new NISuppression (var1_ge_0, var1_le_var2, var2_valid_shift,
                             suppressee),
      });
    private static NISuppressionSet suppressions_swap = suppressions.swap();
  }

#endif

//
// Standard String invariants
//

#if defined(STRING)
  /**
   * Represents the substring invariant between
   * COMMENT_TXT.  Prints as <code>VAR1 is a substring of VAR2</code>.
   */
  public static class SubString extends CLASSNAME {
    // We are Serializable, so we specify a version to allow changes to
    // method signatures without breaking serialization.  If you add or
    // remove fields, you should change this number to the current date.
    static final long serialVersionUID = 20081113L;

    protected SubString (PptSlice ppt, boolean swap) {
      super(ppt, swap);
    }

    protected SubString (boolean swap) {
      super(swap);
    }

    private static /*@Prototype*/ SubString proto = new /*@Prototype*/ SubString (false);
    private static /*@Prototype*/ SubString proto_swap = new /*@Prototype*/ SubString (true);

    /** Returns the prototype invariant */
    public static /*@Prototype*/ SubString get_proto (boolean swap) {
      if (swap) {
        return proto_swap;
      } else {
        return proto;
      }
    }

    // Variables starting with dkconfig_ should only be set via the
    // daikon.config.Configuration interface.
    /** Boolean.  True iff SubString invariants should be considered. */
    public static boolean dkconfig_enabled = false;

    /** Returns whether or not this invariant is enabled */
    public boolean enabled() { return dkconfig_enabled; }

    protected SubString instantiate_dyn (/*>>> @Prototype SubString this,*/ PptSlice slice) {
      return new SubString (slice, swap);
    }

    public String get_format_str (/*>>>@GuardSatisfied SubString this,*/ OutputFormat format) {
      if (format == OutputFormat.DAIKON) {
        return "%var1% is a substring of %var2%";
      } else if (format.isJavaFamily()) {
        return "%var2%.contains(%var1%)";
      } else if (format == OutputFormat.CSHARPCONTRACT) {
        #if defined(TYPESTRINGSEQ)
           return "Contract.ForAll(0, %var2%.Count(), i => %var2%[i].Contains(%var1%[i]))";
        #elif defined(TYPESTRING)
          return "%var2%.Contains(%var1%)";
        #endif
      } else {
        return format_unimplemented(format);
      }
    }

    public boolean eq_check (PRIMITIVE x, PRIMITIVE y) {
      return (y.contains (x));
    }

    /** Justified as long as there are samples */
    protected double computeConfidence() {
      if (ppt.num_samples() == 0) {
        return Invariant.CONFIDENCE_UNJUSTIFIED;
      }

      return Invariant.CONFIDENCE_JUSTIFIED;
    }

    /**
     * Returns a list of non-instantiating suppressions for this invariant.
     */
    /*@Pure*/
    public /*@NonNull*/ NISuppressionSet get_ni_suppressions() {
      if (swap) {
        return suppressions_swap;
      } else {
        return suppressions;
      }
    }

    /** definition of this invariant (the suppressee) (unswapped) */
    private static NISuppressee suppressee
      = new NISuppressee (SubString.class, false);

    private static NISuppressionSet suppressions =
      new NISuppressionSet (new NISuppression[] {
          // v1 == v2 ==> v1 subsequence v2
          new NISuppression (var1_eq_var2, suppressee),
      });
    private static NISuppressionSet suppressions_swap = suppressions.swap();
  }
#endif

}
