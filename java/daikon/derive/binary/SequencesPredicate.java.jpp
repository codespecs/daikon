#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG OR TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SequencesPredicate
  #define PRIMITIVE long
  #define NUMWRAPPER Long
  #define CLASSSTRING "SequencesPredicate"
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SequencesPredicateFloat
  #define PRIMITIVE double
  #define NUMWRAPPER Double
  #define CLASSSTRING "SequencesPredicateFloat"
#endif

// ***** This file is automatically generated from SequencesPredicate.java.jpp

package daikon.derive.binary;

import daikon.*;
import daikon.derive.*;

import plume.*;

import java.util.logging.Logger;

/*>>>
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.dataflow.qual.*;
*/

/**
 * Derived variable representing the selecting of elements of one
 * sequence based on the values of another sequence.  We only
 * predicate if we know that both sequences came from the same
 * original data structure.  Derived type is the same as that of
 * the first sequence.
 */
public final class CLASSNAME
  extends BinaryDerivation
{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20020122L;

  /** Debug tracer. */
  public static final Logger debug
    = Logger.getLogger("daikon.derive.binary." + CLASSSTRING);

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /**
   * Boolean.  True iff SequencesPredicate derived variables should be generated.
   */
  public static boolean dkconfig_enabled = false;

  /**
   * Boolean.  True if Daikon should only generate derivations on fields
   * of the same data structure.
   */
  public static boolean dkconfig_fieldOnly = true;

  /**
   * Boolean.  True if Daikon should only generate derivations on boolean
   * predicates.
   */
  public static boolean dkconfig_boolOnly = true;



  public VarInfo var1(/*>>>@GuardSatisfied CLASSNAME this*/) { return base1; }
  public VarInfo var2(/*>>>@GuardSatisfied CLASSNAME this*/) { return base2; }

  /**
   * What value to predicate on.
   */
  private PRIMITIVE choose;

  /**
   * Whether we keep or discard values that match this.choose.
   */
  private boolean keep;


  /**
   * What this predication is called (e.g. for choose == 0 and 1, use "false"
   * and "true").
   */
  private String name;

  /**
   * Create a new SequencesJoin derivation.
   * @param vi1 the first of the two variables this is based on
   * @param vi2 the second of the two variables this is based on
   */
  public CLASSNAME(VarInfo vi1, VarInfo vi2, PRIMITIVE argChoose, String argName) {
    this (vi1, vi2, argChoose, argName, true);
  }

  /**
   * Create a new SequencesJoin derivation.
   * @param vi1 the first of the two variables this is based on
   * @param vi2 the second of the two variables this is based on
   */
  public CLASSNAME(VarInfo vi1, VarInfo vi2, PRIMITIVE argChoose, String argName, boolean argKeep) {
    super(vi1, vi2);
    choose = argChoose;
    name = argName;
    keep = argKeep;
  }

  /**
   * Returns a subset of val1 such that the corresponding element in
   * var2 equals this.choose.  It is assumed that val1 and val2
   * originated from the same, larger data structure.
   * @param full_vt the value tuple of a program point to compute the
   * derived value from
   */
  public ValueAndModified computeValueAndModifiedImpl (ValueTuple full_vt) {
    Object val1 = var1().getValue(full_vt);
    Object val2 = var2().getValue(full_vt);

    int length1 = -1;
    int length2 = -2; // They must equal in the end

    if (val1 == null) {
      length1 = 0;
    }

    if (val2 == null) {
      length2 = 0;
    }

    if (val1 instanceof PRIMITIVE[]) {
      length1 = ((PRIMITIVE[]) val1).length;
    }

    if (val2 instanceof PRIMITIVE[]) {
      length2 = ((PRIMITIVE[]) val2).length;
    }

    if (val1 instanceof Object[]) {
      length1 = ((Object[]) val1).length;
    }

    assert val2 == null || val2 instanceof PRIMITIVE[];

    if (length1 != length2) {
      // This derived variable is no longer interesting
      return new ValueAndModified(null, ValueTuple.MISSING_NONSENSICAL);
    }

    assert length1 == length2;

    int mod = ValueTuple.UNMODIFIED;
    int mod1 = var1().getModified(full_vt);
    int mod2 = var2().getModified(full_vt);
    if (mod1 == ValueTuple.MODIFIED) mod = ValueTuple.MODIFIED;
    if (mod2 == ValueTuple.MODIFIED) mod = ValueTuple.MODIFIED;
    if (mod1 == ValueTuple.MISSING_NONSENSICAL) mod = ValueTuple.MISSING_NONSENSICAL;
    if (mod2 == ValueTuple.MISSING_NONSENSICAL) mod = ValueTuple.MISSING_NONSENSICAL;
    /*
     * v1\v2  Unm  Mod  Mis
     *
     * Unm    Unm  Mod  Mis
     * Mod    Mod  Mod  Mis
     * Mis    Mis  Mis  Mis
     */

    PRIMITIVE[] predicate = (PRIMITIVE[]) val2;
    int count = 0;
    // Find length of output first
    for (int i = 0; i < predicate.length; i++) {
      if ((predicate[i] == choose) ^ !keep) count += 1;
    }

    if (val1 instanceof PRIMITIVE[]) {
      PRIMITIVE[] result = new PRIMITIVE[count];
      PRIMITIVE[] values = (PRIMITIVE[]) val1;
      int j = 0;
      for (int i = 0; i < length1; i++) {
        if ((predicate[i] == choose) ^ !keep) {
          result[j] = (values[i]);
          j++;
        }
      }
      return new ValueAndModified (Intern.intern(result), mod);
    } else if (val1 instanceof Object[]) {
      /*@Interned*/ Object[] result = new /*@Interned*/ Object[count];
      @SuppressWarnings("interning") // object invariant: array elements are interned
      /*@Interned*/ Object[] values = (/*@Interned*/ Object[]) val1;
      int j = 0;
      for (int i = 0; i < length1; i++) {
        if ((predicate[i] == choose) ^ !keep) {
          result[j] = (values[i]);
          j++;
        }
      }
      return new ValueAndModified (Intern.intern(result), mod);
    } else if (val1 == null) {
      return new ValueAndModified (null, mod);
    } else {
      throw new RuntimeException("Invalid input arrays");
    }


  }



  protected VarInfo makeVarInfo() {
    return VarInfo.make_function ("predicateSlice", var1(), var2());
  }

  /*@SideEffectFree*/
  public String toString(/*>>>@GuardSatisfied CLASSNAME this*/) {
    return "[" + CLASSSTRING + " of " + var1().name() + " " +
      var2().name() + " for " + name + "]";
  }

  /*@Pure*/
  public boolean isSameFormula(Derivation other) {
    // For Toh (tohn) to do.
    if (other instanceof CLASSNAME) {
      CLASSNAME o = (CLASSNAME) other;
      return o.var1().equals(var1())
        && o.var2().equals(var2())
        && choose == o.choose;
    }
    return false;
  }

  /** Returns the ESC name */
  /*@SideEffectFree*/
  public String esc_name(String index) {
    return String.format ("predicate(%s,%s)", var1().esc_name(),
                          var2().esc_name());
  }

}
