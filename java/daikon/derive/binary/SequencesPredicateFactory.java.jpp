#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(TYPELONG) || defined(TYPEDOUBLE))
  #error "TYPELONG or TYPEDOUBLE must be defined"
#endif

#if defined(TYPELONG)
  #define CLASSNAME SequencesPredicateFactory
  #define PRIMITIVE long
  #define SEQUENCESPREDICATE SequencesPredicate
  #define CLASSSTRING "SequencesPredicateFactory"
#elif defined(TYPEDOUBLE)
  #define CLASSNAME SequencesPredicateFactoryFloat
  #define PRIMITIVE double
  #define SEQUENCESPREDICATE SequencesPredicateFloat
  #define CLASSSTRING "SequencesPredicateFactoryFloat"
#endif

// ***** This file is automatically generated from SequencesPredicateFactory.java.jpp

package daikon.derive.binary;

import org.checkerframework.checker.nullness.qual.Nullable;
import daikon.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/** Factory for SequencesPredicate derived variables. */
public final class CLASSNAME extends BinaryDerivationFactory {

  /** Debug tracer. */
  public static final Logger debug =
    Logger.getLogger("daikon.derive.binary." + CLASSSTRING);

  @Override
  public BinaryDerivation @Nullable [] instantiate(VarInfo var1, VarInfo var2) {
    boolean enabled = SEQUENCESPREDICATE.dkconfig_enabled;
    if (!enabled) {
      return null;
    }

    if (debug.isLoggable(Level.FINE)) {
      debug.fine("Trying to instantiate " + var1.name() + " and " + var2.name());
    }

    if (!var1.rep_type.isArray() || !var2.rep_type.isArray()) {
      return null;
    }

    if (!var1.aux.hasOrder() || !var2.aux.hasOrder()) {
      // Order doesn't matter, then predication is meaningless
      return null;
    }

    if (SEQUENCESPREDICATE.dkconfig_boolOnly) {
      if (var2.file_rep_type != ProglangType.BOOLEAN_ARRAY) {
        return null;
      }
    }

    if (var1.derived != null || var2.derived != null) {
      // From derived variables.  Don't derive.
      return null;
    }

    if (SEQUENCESPREDICATE.dkconfig_fieldOnly) {

      if (!var1.is_field() || !var2.is_field()) {
        return null;
      }

      if (!var1.has_same_parent(var2)) {
        return null;
      }

    } else {
      // There may be predications that aren't of the x.a and x.b type
    }

    // Now we finally can derive

    if (debug.isLoggable(Level.FINE)) {
      debug.fine(
         var1.ppt + ": " + var1.name() + " and " + var2.name() + " are worth deriving from");
    }

    return new BinaryDerivation[] {
      new SEQUENCESPREDICATE(var1, var2, 0, "false"),
      new SEQUENCESPREDICATE(var1, var2, 1, "true"),
      // new SequencesPredicate (var1, var2, 0, "nonNull", false),
    };
  }
}
