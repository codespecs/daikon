#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#if !(defined(SCALAR) || defined(STRING) || defined(FLOAT))
  #error "One of SCALAR, FLOAT, or STRING must be defined"
#endif

#if defined(SCALAR)
  #undef SCALAR
  #define PROGLANG_INT ProglangType.INT
  #define PROGLANG_INT_ARRAY ProglangType.INT_ARRAY
  #define SCALARSEQUENCESUNIONFACTORY SequenceScalarUnionFactory
  #define SCALARSEQUENCESUNION SequenceScalarUnion
#elif defined(FLOAT)
  #define PROGLANG_INT ProglangType.DOUBLE
  #define PROGLANG_INT_ARRAY ProglangType.DOUBLE_ARRAY
  #define SCALARSEQUENCESUNIONFACTORY SequenceFloatUnionFactory
  #define SCALARSEQUENCESUNION SequenceFloatUnion
#elif defined(STRING)
  #define THIS_UNDEF_OF_STRING is for "ProglangType.STRING"
  #undef STRING
  #define PROGLANG_INT ProglangType.STRING
  #define PROGLANG_INT_ARRAY ProglangType.STRING_ARRAY
  #define SCALARSEQUENCESUNIONFACTORY SequenceStringUnionFactory
  #define SCALARSEQUENCESUNION SequenceStringUnion
#else
  #error "One of SCALAR, FLOAT, or STRING must be defined"
#endif

// ***** This file is automatically generated from SequencesUnionFactory.java.jpp

package daikon.derive.binary;

import org.checkerframework.checker.nullness.qual.Nullable;
import org.checkerframework.checker.nullness.qual.Nullable;
import daikon.*;

// This controls derivations which use the scalar as an index into the
// sequence, such as getting the element at that index or a subsequence up
// to that index.

public final class SCALARSEQUENCESUNIONFACTORY extends BinaryDerivationFactory {

  @Override
  public BinaryDerivation @Nullable [] instantiate(VarInfo seq1, VarInfo seq2) {
    if (!SCALARSEQUENCESUNION.dkconfig_enabled) {
      return null;
    }

    if ((seq1.rep_type != PROGLANG_INT_ARRAY) || (seq2.rep_type != PROGLANG_INT_ARRAY)) {
      return null;
    }

    // Intersect only sets with the same declared element type
    if (!seq1.type.base().equals(seq2.type.base())) {
      return null;
    }

    // For now, do nothing if the sequences are derived.
    if ((seq1.derived != null) || (seq2.derived != null)) {
      return null;
    }

    return new BinaryDerivation[] {new SCALARSEQUENCESUNION(seq1, seq2)};
  }
}
